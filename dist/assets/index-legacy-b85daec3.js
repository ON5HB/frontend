;
(function () {
  var _excluded = ["offset"];
  function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
  function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
  function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
  function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized2(self); }
  function _assertThisInitialized2(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  System.register([], function (exports, module) {
    'use strict';

    var __vite_style__ = document.createElement('style');
    __vite_style__.textContent = "/*! tailwindcss v3.2.4 | MIT License | https://tailwindcss.com*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:\"\"}html{-webkit-text-size-adjust:100%;font-feature-settings:normal;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{color:inherit;font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}[hidden]{display:none}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.left-0{left:0}.top-0{top:0}.bottom-0{bottom:0}.z-10{z-index:10}.z-0{z-index:0}.z-20{z-index:20}.z-50{z-index:50}.m-2{margin:.5rem}.m-1{margin:.25rem}.m-auto{margin:auto}.m-3{margin:.75rem}.my-1{margin-bottom:.25rem;margin-top:.25rem}.mx-auto{margin-left:auto;margin-right:auto}.block{display:block}.inline{display:inline}.flex{display:flex}.grid{display:grid}.contents{display:contents}.hidden{display:none}.h-1{height:.25rem}.h-4{height:1rem}.h-full{height:100%}.h-8{height:2rem}.h-auto{height:auto}.h-1\\/4{height:25%}.h-5{height:1.25rem}.h-px{height:1px}.h-12{height:3rem}.h-16{height:4rem}.max-h-full{max-height:100%}.max-h-0{max-height:0}.w-full{width:100%}.w-1\\/4{width:25%}.w-1\\/6{width:16.666667%}.w-2\\/3{width:66.666667%}.w-1\\/3{width:33.333333%}.w-1\\/2{width:50%}.w-px{width:1px}.w-2{width:.5rem}.w-1{width:.25rem}.flex-grow{flex-grow:1}.origin-bottom-left{transform-origin:bottom left}.scale-90{--tw-scale-x:.9;--tw-scale-y:.9}.scale-90,.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.cursor-crosshair{cursor:crosshair}.cursor-ew-resize{cursor:ew-resize}.cursor-w-resize{cursor:w-resize}.cursor-e-resize{cursor:e-resize}.appearance-none{-webkit-appearance:none;-moz-appearance:none;appearance:none}.grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}.flex-col-reverse{flex-direction:column-reverse}.flex-wrap{flex-wrap:wrap}.content-center{align-content:center}.items-center{align-items:center}.justify-center{justify-content:center}.overflow-hidden{overflow:hidden}.overflow-x-hidden{overflow-x:hidden}.overflow-y-scroll{overflow-y:scroll}.truncate{overflow:hidden;text-overflow:ellipsis}.truncate,.whitespace-nowrap{white-space:nowrap}.whitespace-pre{white-space:pre}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.border{border-width:1px}.border-l-0{border-left-width:0}.border-t-0{border-top-width:0}.border-r-0{border-right-width:0}.border-black{--tw-border-opacity:1;border-color:rgb(0 0 0/var(--tw-border-opacity))}.border-blue-500{--tw-border-opacity:1;border-color:rgb(59 130 246/var(--tw-border-opacity))}.border-blue-400{--tw-border-opacity:1;border-color:rgb(96 165 250/var(--tw-border-opacity))}.border-yellow-600{--tw-border-opacity:1;border-color:rgb(202 138 4/var(--tw-border-opacity))}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0/var(--tw-bg-opacity))}.bg-blue-800{--tw-bg-opacity:1;background-color:rgb(30 64 175/var(--tw-bg-opacity))}.bg-gray-500{--tw-bg-opacity:1;background-color:rgb(107 114 128/var(--tw-bg-opacity))}.bg-gray-400{--tw-bg-opacity:1;background-color:rgb(156 163 175/var(--tw-bg-opacity))}.bg-green-800{--tw-bg-opacity:1;background-color:rgb(22 101 52/var(--tw-bg-opacity))}.bg-red-800{--tw-bg-opacity:1;background-color:rgb(153 27 27/var(--tw-bg-opacity))}.bg-gray-300{--tw-bg-opacity:1;background-color:rgb(209 213 219/var(--tw-bg-opacity))}.bg-green-500{--tw-bg-opacity:1;background-color:rgb(34 197 94/var(--tw-bg-opacity))}.bg-red-500{--tw-bg-opacity:1;background-color:rgb(239 68 68/var(--tw-bg-opacity))}.bg-transparent{background-color:transparent}.bg-blue-600{--tw-bg-opacity:1;background-color:rgb(37 99 235/var(--tw-bg-opacity))}.bg-yellow-600{--tw-bg-opacity:1;background-color:rgb(202 138 4/var(--tw-bg-opacity))}.bg-yellow-400{--tw-bg-opacity:1;background-color:rgb(250 204 21/var(--tw-bg-opacity))}.bg-white{--tw-bg-opacity:1;background-color:rgb(255 255 255/var(--tw-bg-opacity))}.bg-yellow-500{--tw-bg-opacity:1;background-color:rgb(234 179 8/var(--tw-bg-opacity))}.stroke-current{stroke:currentColor}.stroke-1{stroke-width:1}.p-0{padding:0}.p-px{padding:1px}.p-1{padding:.25rem}.px-1{padding-left:.25rem;padding-right:.25rem}.px-0{padding-left:0;padding-right:0}.px-2{padding-left:.5rem;padding-right:.5rem}.py-px{padding-bottom:1px;padding-top:1px}.py-1{padding-bottom:.25rem;padding-top:.25rem}.pl-2{padding-left:.5rem}.pb-1{padding-bottom:.25rem}.pt-1{padding-top:.25rem}.text-left{text-align:left}.text-center{text-align:center}.align-middle{vertical-align:middle}.font-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.text-xs{font-size:.75rem;line-height:1rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-2xl{font-size:1.5rem;line-height:2rem}.font-bold{font-weight:700}.uppercase{text-transform:uppercase}.text-gray-400{--tw-text-opacity:1;color:rgb(156 163 175/var(--tw-text-opacity))}.text-white{--tw-text-opacity:1;color:rgb(255 255 255/var(--tw-text-opacity))}.text-blue-500{--tw-text-opacity:1;color:rgb(59 130 246/var(--tw-text-opacity))}.text-black{--tw-text-opacity:1;color:rgb(0 0 0/var(--tw-text-opacity))}.text-yellow-500{--tw-text-opacity:1;color:rgb(234 179 8/var(--tw-text-opacity))}.line-through{text-decoration-line:line-through}.opacity-0{opacity:0}.outline-none{outline:2px solid transparent;outline-offset:2px}.outline{outline-style:solid}.outline-1{outline-width:1px}.outline-offset-0{outline-offset:0}.outline-black{outline-color:#000}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition-opacity{transition-duration:.15s;transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1)}.transition-all{transition-duration:.15s;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1)}.transition{transition-duration:.15s;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1)}.duration-100{transition-duration:.1s}.duration-1000{transition-duration:1s}.ease-linear{transition-timing-function:linear}.hover\\:z-20:hover{z-index:20}.hover\\:max-h-screen:hover{max-height:100vh}.active\\:bg-blue-600:active{--tw-bg-opacity:1;background-color:rgb(37 99 235/var(--tw-bg-opacity))}.active\\:text-white:active{--tw-text-opacity:1;color:rgb(255 255 255/var(--tw-text-opacity))}.group:hover .group-hover\\:z-20{z-index:20}.group:hover .group-hover\\:stroke-2{stroke-width:2}.peer:checked~.peer-checked\\:block{display:block}.peer:checked~.peer-checked\\:hidden{display:none}.peer:checked~.peer-checked\\:bg-blue-600{--tw-bg-opacity:1;background-color:rgb(37 99 235/var(--tw-bg-opacity))}.peer:checked~.peer-checked\\:no-underline{text-decoration-line:none}.peer:hover~.peer-hover\\:z-20{z-index:20}.peer:hover~.peer-hover\\:block{display:block}.peer:hover~.peer-hover\\:max-h-screen{max-height:100vh}@media (min-width:640px){.sm\\:w-1\\/2{width:50%}.sm\\:scale-75{--tw-scale-x:.75;--tw-scale-y:.75;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.sm\\:flex-row{flex-direction:row}.sm\\:transition-all{transition-duration:.15s;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1)}.sm\\:duration-100{transition-duration:.1s}.sm\\:ease-linear{transition-timing-function:linear}}@media (min-width:768px){.md\\:w-2\\/3{width:66.666667%}.md\\:w-1\\/3{width:33.333333%}.md\\:scale-\\[0\\.70\\]{--tw-scale-x:0.70;--tw-scale-y:0.70;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}}@media (min-width:1024px){.lg\\:w-3\\/4{width:75%}.lg\\:w-1\\/4{width:25%}}input[type=number].svelte-1n8n5wk::-webkit-inner-spin-button,input[type=number].svelte-1n8n5wk::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}input[type=number].svelte-1n8n5wk{-moz-appearance:textfield}#tooltip.svelte-1qky7dz{background:#333;border-radius:4px;color:#fff;display:none;font-size:13px;font-weight:700;padding:4px 8px}#tooltip[data-show]{display:block}#arrow.svelte-1qky7dz,#arrow.svelte-1qky7dz:before{height:8px;position:absolute;width:8px;z-index:-1}#arrow.svelte-1qky7dz:before{background:#333;content:\"\";transform:rotate(45deg)}#tooltip[data-popper-placement^=top]>#arrow{bottom:-4px}#tooltip[data-popper-placement^=bottom]>#arrow{top:-4px}#tooltip[data-popper-placement^=left]>#arrow{right:-4px}#tooltip[data-popper-placement^=right]>#arrow{left:-4px}#popover.svelte-1hel9pb{background:#333;border-radius:4px;color:#fff;display:none;font-size:13px;font-weight:700;padding:4px 8px}#popover[data-show]{display:block}#arrow.svelte-1hel9pb,#arrow.svelte-1hel9pb:before{height:8px;position:absolute;width:8px;z-index:-1}#arrow.svelte-1hel9pb:before{background:#333;content:\"\";transform:rotate(45deg)}#popover[data-popper-placement^=top]>#arrow{bottom:-4px}#popover[data-popper-placement^=bottom]>#arrow{top:-4px}#popover[data-popper-placement^=left]>#arrow{right:-4px}#popover[data-popper-placement^=right]>#arrow{left:-4px}:root{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif}body.light-mode{background-color:#a9a9a9;transition:background-color .3s}body{background-color:#464646}main{margin:0 auto;text-align:center}.thick-line-through{text-decoration-thickness:2px}.basic-button{--tw-border-opacity:1;--tw-text-opacity:1;border-color:rgb(59 130 246/var(--tw-border-opacity));border-width:1px;color:rgb(59 130 246/var(--tw-text-opacity));font-size:.75rem;font-weight:700;line-height:1rem;padding:.25rem .5rem;text-align:center;text-transform:uppercase;transition-duration:.1s;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1)}.peer:checked~.basic-button{--tw-bg-opacity:1;--tw-text-opacity:1;background-color:rgb(37 99 235/var(--tw-bg-opacity))}.basic-button:hover,.peer:checked~.basic-button{color:rgb(255 255 255/var(--tw-text-opacity))}.basic-button:hover{border-color:rgb(96 165 250/var(--tw-border-opacity))}.basic-button:hover,.click-button{--tw-border-opacity:1;--tw-text-opacity:1}.click-button{border-color:rgb(59 130 246/var(--tw-border-opacity));border-width:1px;color:rgb(59 130 246/var(--tw-text-opacity));font-size:.75rem;font-weight:700;line-height:1rem;padding:.25rem .5rem;text-align:center;text-transform:uppercase;transition-duration:.1s;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1)}.click-button:active{--tw-bg-opacity:1;--tw-text-opacity:1;background-color:rgb(37 99 235/var(--tw-bg-opacity));color:rgb(255 255 255/var(--tw-text-opacity))}";
    document.head.appendChild(__vite_style__);
    return {
      execute: function execute() {
        false && function polyfill() {
          var relList = document.createElement('link').relList;
          if (relList && relList.supports && relList.supports('modulepreload')) {
            return;
          }
          var _iterator = _createForOfIteratorHelper(document.querySelectorAll('link[rel="modulepreload"]')),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var link = _step.value;
              processPreload(link);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          new MutationObserver(function (mutations) {
            var _iterator2 = _createForOfIteratorHelper(mutations),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var mutation = _step2.value;
                if (mutation.type !== 'childList') {
                  continue;
                }
                var _iterator3 = _createForOfIteratorHelper(mutation.addedNodes),
                  _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var node = _step3.value;
                    if (node.tagName === 'LINK' && node.rel === 'modulepreload') processPreload(node);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }).observe(document, {
            childList: true,
            subtree: true
          });
          function getFetchOpts(script) {
            var fetchOpts = {};
            if (script.integrity) fetchOpts.integrity = script.integrity;
            if (script.referrerpolicy) fetchOpts.referrerPolicy = script.referrerpolicy;
            if (script.crossorigin === 'use-credentials') fetchOpts.credentials = 'include';else if (script.crossorigin === 'anonymous') fetchOpts.credentials = 'omit';else fetchOpts.credentials = 'same-origin';
            return fetchOpts;
          }
          function processPreload(link) {
            if (link.ep)
              // ep marker = processed
              return;
            link.ep = true;
            // prepopulate the load record
            var fetchOpts = getFetchOpts(link);
            fetch(link.href, fetchOpts);
          }
        }();
        var app = '';
        function noop() {}
        function assign$2(tar, src) {
          // @ts-ignore
          for (var k in src) {
            tar[k] = src[k];
          }
          return tar;
        }
        function run$1(fn) {
          return fn();
        }
        function blank_object() {
          return Object.create(null);
        }
        function run_all(fns) {
          fns.forEach(run$1);
        }
        function is_function(thing) {
          return typeof thing === 'function';
        }
        function safe_not_equal(a, b) {
          return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';
        }
        function is_empty(obj) {
          return Object.keys(obj).length === 0;
        }
        function create_slot(definition, ctx, $$scope, fn) {
          if (definition) {
            var slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
          }
        }
        function get_slot_context(definition, ctx, $$scope, fn) {
          return definition[1] && fn ? assign$2($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
        }
        function get_slot_changes(definition, $$scope, dirty, fn) {
          if (definition[2] && fn) {
            var lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
              return lets;
            }
            if (_typeof(lets) === 'object') {
              var merged = [];
              var len = Math.max($$scope.dirty.length, lets.length);
              for (var i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
              }
              return merged;
            }
            return $$scope.dirty | lets;
          }
          return $$scope.dirty;
        }
        function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
          if (slot_changes) {
            var slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
          }
        }
        function get_all_dirty_from_scope($$scope) {
          if ($$scope.ctx.length > 32) {
            var dirty = [];
            var length = $$scope.ctx.length / 32;
            for (var i = 0; i < length; i++) {
              dirty[i] = -1;
            }
            return dirty;
          }
          return -1;
        }
        function action_destroyer(action_result) {
          return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
        }
        function append(target, node) {
          target.appendChild(node);
        }
        function insert(target, node, anchor) {
          target.insertBefore(node, anchor || null);
        }
        function detach(node) {
          if (node.parentNode) {
            node.parentNode.removeChild(node);
          }
        }
        function destroy_each(iterations, detaching) {
          for (var i = 0; i < iterations.length; i += 1) {
            if (iterations[i]) iterations[i].d(detaching);
          }
        }
        function element(name) {
          return document.createElement(name);
        }
        function svg_element(name) {
          return document.createElementNS('http://www.w3.org/2000/svg', name);
        }
        function text(data) {
          return document.createTextNode(data);
        }
        function space() {
          return text(' ');
        }
        function listen(node, event, handler, options) {
          node.addEventListener(event, handler, options);
          return function () {
            return node.removeEventListener(event, handler, options);
          };
        }
        function self$1(fn) {
          return function (event) {
            // @ts-ignore
            if (event.target === this) fn.call(this, event);
          };
        }
        function attr(node, attribute, value) {
          if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
        }
        function to_number(value) {
          return value === '' ? null : +value;
        }
        function children(element) {
          return Array.from(element.childNodes);
        }
        function set_data(text, data) {
          data = '' + data;
          if (text.wholeText !== data) text.data = data;
        }
        function set_input_value(input, value) {
          input.value = value == null ? '' : value;
        }
        function set_style(node, key, value, important) {
          if (value === null) {
            node.style.removeProperty(key);
          } else {
            node.style.setProperty(key, value, important ? 'important' : '');
          }
        }
        function select_option(select, value) {
          for (var i = 0; i < select.options.length; i += 1) {
            var option = select.options[i];
            if (option.__value === value) {
              option.selected = true;
              return;
            }
          }
          select.selectedIndex = -1; // no option should be selected
        }

        function select_value(select) {
          var selected_option = select.querySelector(':checked') || select.options[0];
          return selected_option && selected_option.__value;
        }
        // unfortunately this can't be a constant as that wouldn't be tree-shakeable
        // so we cache the result instead
        var crossorigin;
        function is_crossorigin() {
          if (crossorigin === undefined) {
            crossorigin = false;
            try {
              if (typeof window !== 'undefined' && window.parent) {
                void window.parent.document;
              }
            } catch (error) {
              crossorigin = true;
            }
          }
          return crossorigin;
        }
        function add_resize_listener(node, fn) {
          var computed_style = getComputedStyle(node);
          if (computed_style.position === 'static') {
            node.style.position = 'relative';
          }
          var iframe = element('iframe');
          iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' + 'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
          iframe.setAttribute('aria-hidden', 'true');
          iframe.tabIndex = -1;
          var crossorigin = is_crossorigin();
          var unsubscribe;
          if (crossorigin) {
            iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
            unsubscribe = listen(window, 'message', function (event) {
              if (event.source === iframe.contentWindow) fn();
            });
          } else {
            iframe.src = 'about:blank';
            iframe.onload = function () {
              unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
          }
          append(node, iframe);
          return function () {
            if (crossorigin) {
              unsubscribe();
            } else if (unsubscribe && iframe.contentWindow) {
              unsubscribe();
            }
            detach(iframe);
          };
        }
        function custom_event(type, detail) {
          var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
            _ref6$bubbles = _ref6.bubbles,
            bubbles = _ref6$bubbles === void 0 ? false : _ref6$bubbles,
            _ref6$cancelable = _ref6.cancelable,
            cancelable = _ref6$cancelable === void 0 ? false : _ref6$cancelable;
          var e = document.createEvent('CustomEvent');
          e.initCustomEvent(type, bubbles, cancelable, detail);
          return e;
        }
        var current_component;
        function set_current_component(component) {
          current_component = component;
        }
        function get_current_component() {
          if (!current_component) throw new Error('Function called outside component initialization');
          return current_component;
        }
        /**
         * Schedules a callback to run immediately before the component is updated after any state change.
         *
         * The first time the callback runs will be before the initial `onMount`
         *
         * https://svelte.dev/docs#run-time-svelte-beforeupdate
         */
        function beforeUpdate(fn) {
          get_current_component().$$.before_update.push(fn);
        }
        /**
         * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
         * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
         * it can be called from an external module).
         *
         * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
         *
         * https://svelte.dev/docs#run-time-svelte-onmount
         */
        function onMount(fn) {
          get_current_component().$$.on_mount.push(fn);
        }
        /**
         * Schedules a callback to run immediately after the component has been updated.
         *
         * The first time the callback runs will be after the initial `onMount`
         */
        function afterUpdate(fn) {
          get_current_component().$$.after_update.push(fn);
        }
        /**
         * Schedules a callback to run immediately before the component is unmounted.
         *
         * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
         * only one that runs inside a server-side component.
         *
         * https://svelte.dev/docs#run-time-svelte-ondestroy
         */
        function onDestroy(fn) {
          get_current_component().$$.on_destroy.push(fn);
        }
        /**
         * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
         * Event dispatchers are functions that can take two arguments: `name` and `detail`.
         *
         * Component events created with `createEventDispatcher` create a
         * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
         * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
         * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
         * property and can contain any type of data.
         *
         * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
         */
        function createEventDispatcher() {
          var component = get_current_component();
          return function (type, detail) {
            var _ref7 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
              _ref7$cancelable = _ref7.cancelable,
              cancelable = _ref7$cancelable === void 0 ? false : _ref7$cancelable;
            var callbacks = component.$$.callbacks[type];
            if (callbacks) {
              // TODO are there situations where events could be dispatched
              // in a server (non-DOM) environment?
              var event = custom_event(type, detail, {
                cancelable: cancelable
              });
              callbacks.slice().forEach(function (fn) {
                fn.call(component, event);
              });
              return !event.defaultPrevented;
            }
            return true;
          };
        }
        // TODO figure out if we still want to support
        // shorthand events, or if we want to implement
        // a real bubbling mechanism
        function bubble(component, event) {
          var _this4 = this;
          var callbacks = component.$$.callbacks[event.type];
          if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(function (fn) {
              return fn.call(_this4, event);
            });
          }
        }
        var dirty_components = [];
        var binding_callbacks = [];
        var render_callbacks = [];
        var flush_callbacks = [];
        var resolved_promise = Promise.resolve();
        var update_scheduled = false;
        function schedule_update() {
          if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
          }
        }
        function add_render_callback(fn) {
          render_callbacks.push(fn);
        }
        function add_flush_callback(fn) {
          flush_callbacks.push(fn);
        }
        // flush() calls callbacks in this order:
        // 1. All beforeUpdate callbacks, in order: parents before children
        // 2. All bind:this callbacks, in reverse order: children before parents.
        // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
        //    for afterUpdates called during the initial onMount, which are called in
        //    reverse order: children before parents.
        // Since callbacks might update component values, which could trigger another
        // call to flush(), the following steps guard against this:
        // 1. During beforeUpdate, any updated components will be added to the
        //    dirty_components array and will cause a reentrant call to flush(). Because
        //    the flush index is kept outside the function, the reentrant call will pick
        //    up where the earlier call left off and go through all dirty components. The
        //    current_component value is saved and restored so that the reentrant call will
        //    not interfere with the "parent" flush() call.
        // 2. bind:this callbacks cannot trigger new flush() calls.
        // 3. During afterUpdate, any updated components will NOT have their afterUpdate
        //    callback called a second time; the seen_callbacks set, outside the flush()
        //    function, guarantees this behavior.
        var seen_callbacks = new Set();
        var flushidx = 0; // Do *not* move this inside the flush() function
        function flush() {
          var saved_component = current_component;
          do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
              var component = dirty_components[flushidx];
              flushidx++;
              set_current_component(component);
              update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length) {
              binding_callbacks.pop()();
            }
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (var i = 0; i < render_callbacks.length; i += 1) {
              var callback = render_callbacks[i];
              if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
              }
            }
            render_callbacks.length = 0;
          } while (dirty_components.length);
          while (flush_callbacks.length) {
            flush_callbacks.pop()();
          }
          update_scheduled = false;
          seen_callbacks.clear();
          set_current_component(saved_component);
        }
        function update($$) {
          if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            var dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
          }
        }
        var outroing = new Set();
        var outros;
        function transition_in(block, local) {
          if (block && block.i) {
            outroing.delete(block);
            block.i(local);
          }
        }
        function transition_out(block, local, detach, callback) {
          if (block && block.o) {
            if (outroing.has(block)) return;
            outroing.add(block);
            outros.c.push(function () {
              outroing.delete(block);
              if (callback) {
                if (detach) block.d(1);
                callback();
              }
            });
            block.o(local);
          } else if (callback) {
            callback();
          }
        }
        var globals = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : global;
        function destroy_block(block, lookup) {
          block.d(1);
          lookup.delete(block.key);
        }
        function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
          var o = old_blocks.length;
          var n = list.length;
          var i = o;
          var old_indexes = {};
          while (i--) {
            old_indexes[old_blocks[i].key] = i;
          }
          var new_blocks = [];
          var new_lookup = new Map();
          var deltas = new Map();
          i = n;
          while (i--) {
            var child_ctx = get_context(ctx, list, i);
            var key = get_key(child_ctx);
            var block = lookup.get(key);
            if (!block) {
              block = create_each_block(key, child_ctx);
              block.c();
            } else if (dynamic) {
              block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
          }
          var will_move = new Set();
          var did_move = new Set();
          function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
          }
          while (o && n) {
            var new_block = new_blocks[n - 1];
            var old_block = old_blocks[o - 1];
            var new_key = new_block.key;
            var old_key = old_block.key;
            if (new_block === old_block) {
              // do nothing
              next = new_block.first;
              o--;
              n--;
            } else if (!new_lookup.has(old_key)) {
              // remove old block
              destroy(old_block, lookup);
              o--;
            } else if (!lookup.has(new_key) || will_move.has(new_key)) {
              insert(new_block);
            } else if (did_move.has(old_key)) {
              o--;
            } else if (deltas.get(new_key) > deltas.get(old_key)) {
              did_move.add(new_key);
              insert(new_block);
            } else {
              will_move.add(old_key);
              o--;
            }
          }
          while (o--) {
            var _old_block = old_blocks[o];
            if (!new_lookup.has(_old_block.key)) destroy(_old_block, lookup);
          }
          while (n) {
            insert(new_blocks[n - 1]);
          }
          return new_blocks;
        }
        function bind$4(component, name, callback, value) {
          var index = component.$$.props[name];
          if (index !== undefined) {
            component.$$.bound[index] = callback;
            if (value === undefined) {
              callback(component.$$.ctx[index]);
            }
          }
        }
        function create_component(block) {
          block && block.c();
        }
        function mount_component(component, target, anchor, customElement) {
          var _component$$$ = component.$$,
            fragment = _component$$$.fragment,
            after_update = _component$$$.after_update;
          fragment && fragment.m(target, anchor);
          if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(function () {
              var new_on_destroy = component.$$.on_mount.map(run$1).filter(is_function);
              // if the component was destroyed immediately
              // it will update the `$$.on_destroy` reference to `null`.
              // the destructured on_destroy may still reference to the old array
              if (component.$$.on_destroy) {
                var _component$$$$on_dest;
                (_component$$$$on_dest = component.$$.on_destroy).push.apply(_component$$$$on_dest, _toConsumableArray(new_on_destroy));
              } else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
              }
              component.$$.on_mount = [];
            });
          }
          after_update.forEach(add_render_callback);
        }
        function destroy_component(component, detaching) {
          var $$ = component.$$;
          if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
          }
        }
        function make_dirty(component, i) {
          if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
          }
          component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
        }
        function init$1(component, options, instance, create_fragment, not_equal, props, append_styles) {
          var dirty = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [-1];
          var parent_component = current_component;
          set_current_component(component);
          var $$ = component.$$ = {
            fragment: null,
            ctx: [],
            // state
            props: props,
            update: noop,
            not_equal: not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty: dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
          };
          append_styles && append_styles($$.root);
          var ready = false;
          $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {
            var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
              if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
              if (ready) make_dirty(component, i);
            }
            return ret;
          }) : [];
          $$.update();
          ready = true;
          run_all($$.before_update);
          // `false` as a special case of no DOM component
          $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
          if (options.target) {
            if (options.hydrate) {
              var nodes = children(options.target);
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              $$.fragment && $$.fragment.l(nodes);
              nodes.forEach(detach);
            } else {
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              $$.fragment && $$.fragment.c();
            }
            if (options.intro) transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
          }
          set_current_component(parent_component);
        }
        /**
         * Base class for Svelte components. Used when dev=false.
         */
        var SvelteComponent = /*#__PURE__*/function () {
          function SvelteComponent() {
            _classCallCheck(this, SvelteComponent);
          }
          _createClass(SvelteComponent, [{
            key: "$destroy",
            value: function $destroy() {
              destroy_component(this, 1);
              this.$destroy = noop;
            }
          }, {
            key: "$on",
            value: function $on(type, callback) {
              if (!is_function(callback)) {
                return noop;
              }
              var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
              callbacks.push(callback);
              return function () {
                var index = callbacks.indexOf(callback);
                if (index !== -1) callbacks.splice(index, 1);
              };
            }
          }, {
            key: "$set",
            value: function $set($$props) {
              if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
              }
            }
          }]);
          return SvelteComponent;
        }();
        var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
        function getAugmentedNamespace(n) {
          var f = n.default;
          if (typeof f == "function") {
            var a = function a() {
              if (this instanceof a) {
                var args = [null];
                args.push.apply(args, arguments);
                var Ctor = Function.bind.apply(f, args);
                return new Ctor();
              }
              return f.apply(this, arguments);
            };
            a.prototype = f.prototype;
          } else a = {};
          Object.defineProperty(a, '__esModule', {
            value: true
          });
          Object.keys(n).forEach(function (k) {
            var d = Object.getOwnPropertyDescriptor(n, k);
            Object.defineProperty(a, k, d.get ? d : {
              enumerable: true,
              get: function get() {
                return n[k];
              }
            });
          });
          return a;
        }
        var toggleSelection = function toggleSelection() {
          var selection = document.getSelection();
          if (!selection.rangeCount) {
            return function () {};
          }
          var active = document.activeElement;
          var ranges = [];
          for (var i = 0; i < selection.rangeCount; i++) {
            ranges.push(selection.getRangeAt(i));
          }
          switch (active.tagName.toUpperCase()) {
            // .toUpperCase handles XHTML
            case 'INPUT':
            case 'TEXTAREA':
              active.blur();
              break;
            default:
              active = null;
              break;
          }
          selection.removeAllRanges();
          return function () {
            selection.type === 'Caret' && selection.removeAllRanges();
            if (!selection.rangeCount) {
              ranges.forEach(function (range) {
                selection.addRange(range);
              });
            }
            active && active.focus();
          };
        };
        var deselectCurrent = toggleSelection;
        var clipboardToIE11Formatting = {
          "text/plain": "Text",
          "text/html": "Url",
          "default": "Text"
        };
        var defaultMessage = "Copy to clipboard: #{key}, Enter";
        function format(message) {
          var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
          return message.replace(/#{\s*key\s*}/g, copyKey);
        }
        function copy(text, options) {
          var debug,
            message,
            reselectPrevious,
            range,
            selection,
            mark,
            success = false;
          if (!options) {
            options = {};
          }
          debug = options.debug || false;
          try {
            reselectPrevious = deselectCurrent();
            range = document.createRange();
            selection = document.getSelection();
            mark = document.createElement("span");
            mark.textContent = text;
            // avoid screen readers from reading out loud the text
            mark.ariaHidden = "true";
            // reset user styles for span element
            mark.style.all = "unset";
            // prevents scrolling to the end of the page
            mark.style.position = "fixed";
            mark.style.top = 0;
            mark.style.clip = "rect(0, 0, 0, 0)";
            // used to preserve spaces and line breaks
            mark.style.whiteSpace = "pre";
            // do not inherit user-select (it may be `none`)
            mark.style.webkitUserSelect = "text";
            mark.style.MozUserSelect = "text";
            mark.style.msUserSelect = "text";
            mark.style.userSelect = "text";
            mark.addEventListener("copy", function (e) {
              e.stopPropagation();
              if (options.format) {
                e.preventDefault();
                if (typeof e.clipboardData === "undefined") {
                  // IE 11
                  debug && console.warn("unable to use e.clipboardData");
                  debug && console.warn("trying IE specific stuff");
                  window.clipboardData.clearData();
                  var format = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
                  window.clipboardData.setData(format, text);
                } else {
                  // all other browsers
                  e.clipboardData.clearData();
                  e.clipboardData.setData(options.format, text);
                }
              }
              if (options.onCopy) {
                e.preventDefault();
                options.onCopy(e.clipboardData);
              }
            });
            document.body.appendChild(mark);
            range.selectNodeContents(mark);
            selection.addRange(range);
            var successful = document.execCommand("copy");
            if (!successful) {
              throw new Error("copy command was unsuccessful");
            }
            success = true;
          } catch (err) {
            debug && console.error("unable to copy using execCommand: ", err);
            debug && console.warn("trying IE specific stuff");
            try {
              window.clipboardData.setData(options.format || "text", text);
              options.onCopy && options.onCopy(window.clipboardData);
              success = true;
            } catch (err) {
              debug && console.error("unable to copy using clipboardData: ", err);
              debug && console.error("falling back to prompt");
              message = format("message" in options ? options.message : defaultMessage);
              window.prompt(message, text);
            }
          } finally {
            if (selection) {
              if (typeof selection.removeRange == "function") {
                selection.removeRange(range);
              } else {
                selection.removeAllRanges();
              }
            }
            if (mark) {
              document.body.removeChild(mark);
            }
            reselectPrevious();
          }
          return success;
        }
        var copyToClipboard = copy;
        var efficientRollingStats = {};
        (function (exports) {
          //if(require.main === module) { var  repl = require("repl");repl.start({ useGlobal:true,  useColors:true, }); }

          //rolling min max in probably fast javascript, if you treat javascript as c it is fast as c, i.e. no object arrays
          /*
           	This is the algorithm from http://stackoverflow.com/a/12195098/466363:
           	        at every step:
           	          if (!Deque.Empty) and (Deque.Head.Index <= CurrentIndex - T) then 
                       Deque.ExtractHead;
                    //Head is too old, it is leaving the window
           	          while (!Deque.Empty) and (Deque.Tail.Value > CurrentValue) do
                       Deque.ExtractTail;
                    //remove elements that have no chance to become minimum in the window
           	          Deque.AddTail(CurrentValue, CurrentIndex); 
                    CurrentMin = Deque.Head.Value
                    //Head value is minimum in the current window
                    
            
          */
          // https://gist.github.com/shimondoodkin/f274d6e17c66a8b72779

          function RollingMin(WindowSize)
          // generator
          {
            var DequeIndex = [],
              DequeValue = [],
              CurrentIndex = 0,
              T = WindowSize;
            function atEveryStepDo(CurrentValue) {
              if (DequeIndex.length !== 0 && DequeIndex[0] <= CurrentIndex - T) {
                DequeIndex.shift();
                DequeValue.shift();
              }
              //Head is too old, it is leaving the window

              while (DequeValue.length !== 0 && DequeValue[DequeValue.length - 1] > CurrentValue) {
                DequeIndex.pop();
                DequeValue.pop();
              }
              //remove elements that have no chance to become minimum in the window

              DequeIndex.push(CurrentIndex);
              DequeValue.push(CurrentValue);
              CurrentIndex++;
              return DequeValue[0]; //Head value is minimum in the current window
            }

            atEveryStepDo.setWindowSize = function (WindowSize) {
              T = WindowSize;
            };
            atEveryStepDo.reset = function () {
              DequeIndex.splice(0, DequeIndex.length);
              DequeValue.splice(0, DequeValue.length);
              CurrentIndex = 0;
            };
            return atEveryStepDo;
          }
          function RollingMax(WindowSize)
          // generator
          {
            var DequeIndex = [],
              DequeValue = [],
              CurrentIndex = 0,
              T = WindowSize;
            function atEveryStepDo(CurrentValue) {
              if (DequeIndex.length !== 0 && DequeIndex[0] <= CurrentIndex - T) {
                DequeIndex.shift();
                DequeValue.shift();
              }
              //Head is too old, it is leaving the window

              while (DequeValue.length !== 0 && DequeValue[DequeValue.length - 1] < CurrentValue) {
                DequeIndex.pop();
                DequeValue.pop();
              }
              //remove elements that have no chance to become maxbimum in the window

              DequeIndex.push(CurrentIndex);
              DequeValue.push(CurrentValue);
              CurrentIndex++;
              return DequeValue[0]; //Head value is maximum in the current window
            }

            atEveryStepDo.setWindowSize = function (WindowSize) {
              T = WindowSize;
            };
            atEveryStepDo.reset = function () {
              DequeIndex.splice(0, DequeIndex.length);
              DequeValue.splice(0, DequeValue.length);
              CurrentIndex = 0;
            };
            return atEveryStepDo;
          }
          function RollingAvg(WindowSize)
          // generator
          {
            var DequeValue = [],
              T = WindowSize,
              Sum = 0,
              prev;
            function atEveryStepDo(CurrentValue) {
              if (DequeValue.length >= T) {
                Sum -= DequeValue.shift();
              }
              //Head is too old, it is leaving the window
              if (CurrentValue || CurrentValue === 0)
                //don't break the sum on junk
                {
                  DequeValue.push(CurrentValue);
                  Sum += CurrentValue;
                } else return prev;
              return prev = DequeValue.length == 0 ? 0 : Sum / DequeValue.length; //Head value is maximum in the current window
            }

            atEveryStepDo.setWindowSize = function (WindowSize) {
              T = WindowSize;
            };
            atEveryStepDo.reset = function () {
              Sum = 0;
              DequeValue.splice(0, DequeValue.length);
            };
            return atEveryStepDo;
          }
          function RollingMinIndex(WindowSize)
          // generator
          {
            var DequeIndex = [],
              DequeValue = [],
              T = WindowSize;
            function atEveryStepDo(CurrentValue, CurrentIndex) {
              while (DequeIndex.length !== 0 && DequeIndex[0] <= CurrentIndex - T) {
                DequeIndex.shift();
                DequeValue.shift();
              }
              //Head is too old, it is leaving the window

              while (DequeValue.length !== 0 && DequeValue[DequeValue.length - 1] > CurrentValue) {
                DequeIndex.pop();
                DequeValue.pop();
              }
              //remove elements that have no chance to become minimum in the window

              DequeIndex.push(CurrentIndex);
              DequeValue.push(CurrentValue);
              return DequeValue[0]; //Head value is minimum in the current window
            }

            atEveryStepDo.setWindowSize = function (WindowSize) {
              T = WindowSize;
            };
            atEveryStepDo.reset = function () {
              DequeIndex.splice(0, DequeIndex.length);
              DequeValue.splice(0, DequeValue.length);
            };
            return atEveryStepDo;
          }
          function RollingMaxIndex(WindowSize)
          // generator
          {
            var DequeIndex = [],
              DequeValue = [],
              T = WindowSize;
            function atEveryStepDo(CurrentValue, CurrentIndex) {
              while (DequeIndex.length !== 0 && DequeIndex[0] <= CurrentIndex - T) {
                DequeIndex.shift();
                DequeValue.shift();
              }
              //Head is too old, it is leaving the window

              while (DequeValue.length !== 0 && DequeValue[DequeValue.length - 1] < CurrentValue) {
                DequeIndex.pop();
                DequeValue.pop();
              }
              //remove elements that have no chance to become maxbimum in the window

              DequeIndex.push(CurrentIndex);
              DequeValue.push(CurrentValue);
              return DequeValue[0]; //Head value is maximum in the current window
            }

            atEveryStepDo.setWindowSize = function (WindowSize) {
              T = WindowSize;
            };
            atEveryStepDo.reset = function () {
              DequeIndex.splice(0, DequeIndex.length);
              DequeValue.splice(0, DequeValue.length);
            };
            return atEveryStepDo;
          }
          function RollingAvgIndex(WindowSize)
          // generator
          {
            var DequeIndex = [],
              DequeValue = [],
              T = WindowSize,
              Sum = 0;
            function atEveryStepDo(CurrentValue, CurrentIndex) {
              while (DequeIndex.length !== 0 && DequeIndex[0] <= CurrentIndex - T) {
                DequeIndex.shift();
                Sum -= DequeValue.shift();
              }

              //Head is too old, it is leaving the window
              if (CurrentValue || CurrentValue === 0) {
                DequeIndex.push(CurrentIndex);
                DequeValue.push(CurrentValue);
                Sum += CurrentValue;
              } else return prev;
              return prev = DequeValue.length == 0 ? 0 : Sum / DequeValue.length; //Head value is maximum in the current window
            }

            atEveryStepDo.setWindowSize = function (WindowSize) {
              T = WindowSize;
            };
            atEveryStepDo.reset = function () {
              DequeIndex.splice(0, DequeIndex.length);
              DequeValue.splice(0, DequeValue.length);
              Sum = 0;
            };
            return atEveryStepDo;
          }

          //simple binary sorted array
          //add item: array.splice(sortedIndex(array, value),0,value);
          //remove item: var x=sortedIndex(array, value); if(array[x]==value)array.splice(x,1);
          function sortedIndex(array, value) {
            var low = 0,
              high = array.length;
            while (low < high) {
              var mid = low + high >>> 1;
              if (array[mid] < value) low = mid + 1;else high = mid;
            }
            return low;
          }

          // a simple idea to make an efficient algorithm for median
          // is not to realy on old index to remove values, 
          // but add by value and remove by value, and keep values in order,
          // anyway it won't remove more values than inserted.
          //
          // complexity: log(n) add, log(n) remove, performance= 2*log(n)
          function RollingMedian(WindowSize)
          // generator , RollingMedian(WindowSize,DivideEven)
          {
            var DequeValue = [],
              T = WindowSize,
              SortedValues = [],
              LsortedIndex = sortedIndex;
            var prevmedian,
              findcenter = null,
              Sum = 0,
              Sum2 = 0,
              Sum3 = 0,
              Sum4 = 0,
              findmoments = null; //,DevideE=!!DivideEven; 
            function atEveryStepDo(CurrentValue) {
              if (DequeValue.length >= T) {
                //Head is too old, it is leaving the window
                var value = DequeValue.shift();
                var v = value,
                  vv = v * v,
                  vvv = vv * v,
                  vvvv = vvv * v;
                Sum -= v;
                Sum2 -= vv;
                Sum3 -= vvv;
                Sum4 -= vvvv;
                var x = LsortedIndex(SortedValues, value);
                if (SortedValues[x] == value) SortedValues.splice(x, 1);
              }
              if (CurrentValue || CurrentValue === 0) {
                DequeValue.push(CurrentValue);
                SortedValues.splice(LsortedIndex(SortedValues, CurrentValue), 0, CurrentValue);
                findcenter = null;
                findmoments = null;
                var v = CurrentValue,
                  vv = v * v,
                  vvv = vv * v,
                  vvvv = vvv * v;
                Sum += v;
                Sum2 += vv;
                Sum3 += vvv;
                Sum4 += vvvv;
              } else return prevmedian;
              if (SortedValues.length == 0) return prevmedian;
              if (SortedValues.length & 1)
                // if even
                return prevmedian = SortedValues[SortedValues.length - 1 >>> 1]; // index=((SortedValues.length -1 for devide by two))/2)+1 add one back -1 for 0 based index, >>> 1 is faster devide by two by bit shifting
              else {
                //if odd
                var half = (SortedValues.length >>> 1) - 1; // index = (SortedValues.length>>> 1) -1 for zero based index
                //if(DevideE)
                return prevmedian = (SortedValues[half] + SortedValues[half + 1]) / 2; // correct implementation
                //else    return SortedValues[half]; //i don't care,same same for my usage
              }
            }

            atEveryStepDo.setWindowSize = function (WindowSize) {
              T = WindowSize;
            };

            //atEveryStepDo.setDivideEven=function(DivideEven){DevideE=DivideEven};

            atEveryStepDo.reset = function () {
              DequeValue.splice(0, DequeValue.length);
              SortedValues.splice(0, SortedValues.length);
              findcenter = null;
              Sum = 0;
              Sum2 = 0;
              Sum3 = 0;
              Sum4 = 0;
              findmoments = null;
            };
            atEveryStepDo.avg = function () {
              return Sum / DequeValue.length;
            };
            atEveryStepDo.sum = function () {
              return Sum;
            };
            atEveryStepDo.min = function () {
              return SortedValues[0];
            };
            atEveryStepDo.q1 = function () {
              if (SortedValues.length == 1) return SortedValues[0];
              if (SortedValues.length == 2) return SortedValues[0] * 0.75 + SortedValues[1] * 0.25;
              if (SortedValues.length == 3) return SortedValues[0] * 0.5 + SortedValues[1] * 0.5;
              if ((SortedValues.length - 1) % 4 == 0) {
                var n = SortedValues.length - 1 >> 2;
                return SortedValues[n - 1] * 0.25 + SortedValues[n] * 0.75;
                //return SortedValues[n+0-1]*0.25+SortedValues[n+1-1]*0.75 
              }

              if ((SortedValues.length - 3) % 4 == 0) {
                var n = SortedValues.length - 3 >> 2;
                return SortedValues[n] * 0.75 + SortedValues[n + 1] * 0.25;
                //return SortedValues[n+1-1]*0.75+SortedValues[n+2-1]*0.25 
              }
            };

            atEveryStepDo.moments_avg = function ()
            //m1 - not useful
            {
              if (findmoments === null) findmoments = atEveryStepDo.moments();
              return findmoments.average;
            };
            atEveryStepDo.variance = function ()
            //m2
            {
              if (findmoments === null) findmoments = atEveryStepDo.moments();
              return findmoments.variance;
            };
            atEveryStepDo.standardDeviation = function ()
            //sqrt(m2)
            {
              if (findmoments === null) findmoments = atEveryStepDo.moments();
              return findmoments.standardDeviation;
            };
            atEveryStepDo.skew = function ()
            // using m2 , m3
            {
              if (findmoments === null) findmoments = atEveryStepDo.moments();
              return findmoments.skew;
            };
            atEveryStepDo.kurtosis = function ()
            // using m2, m3 ,m4
            {
              if (findmoments === null) findmoments = atEveryStepDo.moments();
              return findmoments.kurtosis;
            };
            atEveryStepDo.exkurtosis = function ()
            // using kurtosis - 3
            {
              if (findmoments === null) findmoments = atEveryStepDo.moments();
              return findmoments.exkurtosis;
            };
            atEveryStepDo.moments = function () {
              var o = {};
              if (this.c > 0) {
                //e(x), e(x*x), e(x*x*x), and e(x*x*x*x)
                var c = DequeValue.length,
                  ex = Sum / c,
                  exx = Sum2 / c,
                  exxx = Sum3 / c,
                  exxxx = Sum4 / c,
                  //central moments:
                  m1 = ex,
                  m2 = Sum2 / c - ex;
                m3 = exxx - 3 * exx * ex + 2 * ex * ex * ex;
                m4 = exxxx - 3 * exxx * ex + 6 * exx * ex * ex - -3 * ex * ex * ex * ex;
                o.average = m1;
                o.variance = m2;
                o.standardDeviation = Math.pow(o.variance, .5);
                if (c > 2) {
                  //http://www.amstat.org/publications/jse/v19n2/doane.pdf
                  //http://en.wikipedia.org/wiki/Skewness
                  o.skew = Math.pow(c * (c - 1), .5) / (c - 2) * m3 / Math.pow(m2, 1.5);
                }
                if (m2 > 0) {
                  //http://en.wikipedia.org/wiki/Kurtosis
                  o.exkurtosis = m4 / m2 / m2 - 3;
                  o.kurtosis = m4 / m2 / m2;
                }
              }
              return o;
            };
            atEveryStepDo.median = function () {
              return prevmedian;
            }; //q2

            atEveryStepDo.q3 = function () {
              if (SortedValues.length == 1) return SortedValues[0];
              if (SortedValues.length == 2) return SortedValues[0] * 0.25 + SortedValues[1] * 0.75;
              if (SortedValues.length == 3) return SortedValues[1] * 0.5 + SortedValues[2] * 0.5;
              if ((SortedValues.length - 1) % 4 == 0) {
                var n3 = (SortedValues.length - 1 >> 2) * 3;
                return SortedValues[n3] * 0.75 + SortedValues[n3 + 1] * 0.25;
                //return SortedValues[n3+1-1]*0.75+SortedValues[n3+2-1]*0.25 
              }

              if ((SortedValues.length - 3) % 4 == 0) {
                var n3 = (SortedValues.length - 3 >> 2) * 3;
                return SortedValues[n3 + 1] * 0.25 + SortedValues[n3 + 2] * 0.75;
                //return SortedValues[n3+2-1]*0.25+SortedValues[n3+3-1]*0.75 
              }
            };

            atEveryStepDo.max = function () {
              return SortedValues[SortedValues.length - 1];
            };
            atEveryStepDo.center = function () {
              return (SortedValues[0] + SortedValues[SortedValues.length - 1]) / 2;
            };

            //atEveryStepDo.nabovecenter=function(){
            // if(findcenter===null) findcenter=LsortedIndex(SortedValues, (SortedValues[0]+SortedValues[SortedValues.length-1])/2 );
            // return SortedValues.length-findcenter-1;
            //}
            //atEveryStepDo.nbelowcenter=function(){
            // if(findcenter===null) findcenter=LsortedIndex(SortedValues, (SortedValues[0]+SortedValues[SortedValues.length-1])/2 );
            // return findcenter-1;
            //}

            //http://books.google.co.il/books?id=4HrJs2o9C5YC&pg=PA32&lpg=PA32&dq=q3+q2+q2+q1+skewness&source=bl&ots=eD24ehhNoz&sig=xxhMOFVL5JngB5JPi5WieIRTCaI&hl=en&sa=X&ei=xfVQVIPzFOLnywPM9YLIAw&ved=0CEoQ6AEwBw#v=onepage&q=Q.D.&f=false

            atEveryStepDo.medianskew = function () {
              //medianskew=(max - median)-(median - min)
              return SortedValues[SortedValues.length - 1] - prevmedian - (prevmedian - SortedValues[0]);
            };
            atEveryStepDo.medianskew_bowleys_coef = function () {
              //medianskew=(max - median)-(median - min)
              return (SortedValues[SortedValues.length - 1] - prevmedian) * (prevmedian - SortedValues[0]) / (SortedValues[SortedValues.length - 1] - SortedValues[0]);
            };
            atEveryStepDo.mediankurt = function () {
              //q.d=quartile deviatin=(q3-q1)/2, mediankurt=q.d/(p90 - p10), mediankurt=((q3-q1)/2	)/(p90 - p10) 	
              var p90 = Math.round((SortedValues.length - 1) * 0.9);
              var p10 = Math.round((SortedValues.length - 1) * 0.1);
              return (SortedValues[SortedValues.length - 1] - prevmedian) * (prevmedian - SortedValues[0]) / (SortedValues[p90] - SortedValues[p10]);
            };
            atEveryStepDo.pabovecenter = function () {
              if (findcenter === null) findcenter = LsortedIndex(SortedValues, (SortedValues[0] + SortedValues[SortedValues.length - 1]) / 2);
              return (SortedValues.length - 1 - findcenter) / (SortedValues.length - 1);
            };
            atEveryStepDo.pbelowcenter = function () {
              if (findcenter === null) findcenter = LsortedIndex(SortedValues, (SortedValues[0] + SortedValues[SortedValues.length - 1]) / 2);
              return findcenter / (SortedValues.length - 1);
            };
            return atEveryStepDo;
          }
          function RollingMedianIndex(WindowSize)
          // generator
          {
            var DequeValue = [],
              DequeIndex = [],
              T = WindowSize,
              SortedValues = [],
              LsortedIndex = sortedIndex;
            var prevmedian,
              findcenter = null,
              Sum = 0,
              Sum2 = 0,
              Sum3 = 0,
              Sum4 = 0,
              findmoments = null; //,DevideE=!!DivideEven; 
            function atEveryStepDo(CurrentValue, CurrentIndex) {
              while (DequeIndex.length !== 0 && DequeIndex[0] <= CurrentIndex - T) {
                //Head is too old, it is leaving the window
                DequeIndex.shift();
                var value = DequeValue.shift();
                var v = value,
                  vv = v * v,
                  vvv = vv * v,
                  vvvv = vvv * v;
                Sum -= v;
                Sum2 -= vv;
                Sum3 -= vvv;
                Sum4 -= vvvv;
                var x = LsortedIndex(SortedValues, value);
                if (SortedValues[x] == value) SortedValues.splice(x, 1);
              }
              if (CurrentValue || CurrentValue === 0) {
                DequeIndex.push(CurrentIndex);
                DequeValue.push(CurrentValue);
                SortedValues.splice(LsortedIndex(SortedValues, CurrentValue), 0, CurrentValue);
                findcenter = null;
                findmoments = null;
                var v = CurrentValue,
                  vv = v * v,
                  vvv = vv * v,
                  vvvv = vvv * v;
                Sum += v;
                Sum2 += vv;
                Sum3 += vvv;
                Sum4 += vvvv;
              } else return prevmedian;
              if (SortedValues.length == 0) return prevmedian;
              if (SortedValues.length & 1)
                // if even
                return prevmedian = SortedValues[SortedValues.length - 1 >>> 1]; // index=((SortedValues.length -1 for devide by two))/2)+1 add one back -1 for 0 based index, >>> 1 is faster devide by two by bit shifting
              else {
                //if odd
                var half = (SortedValues.length >>> 1) - 1; // index = (SortedValues.length>>> 1) -1 for zero based index
                //if(DevideE)
                return prevmedian = (SortedValues[half] + SortedValues[half + 1]) / 2; // correct implementation
                //else    return SortedValues[half]; //i don't care,same same for my usage
              }
            }

            atEveryStepDo.setWindowSize = function (WindowSize) {
              T = WindowSize;
            };

            //atEveryStepDo.setDivideEven=function(DivideEven){DevideE=DivideEven};

            atEveryStepDo.reset = function () {
              DequeValue.splice(0, DequeValue.length);
              DequeIndex.splice(0, DequeIndex.length);
              SortedValues.splice(0, SortedValues.length);
              findcenter = null;
              Sum = 0;
              Sum2 = 0;
              Sum3 = 0;
              Sum4 = 0;
              findmoments = null;
            };
            atEveryStepDo.avg = function () {
              return Sum / DequeValue.length;
            };
            atEveryStepDo.sum = function () {
              return Sum;
            };
            atEveryStepDo.min = function () {
              return SortedValues[0];
            };
            atEveryStepDo.q1 = function () {
              if (SortedValues.length == 1) return SortedValues[0];
              if (SortedValues.length == 2) return SortedValues[0] * 0.75 + SortedValues[1] * 0.25;
              if (SortedValues.length == 3) return SortedValues[0] * 0.5 + SortedValues[1] * 0.5;
              if ((SortedValues.length - 1) % 4 == 0) {
                var n = SortedValues.length - 1 >> 2;
                return SortedValues[n - 1] * 0.25 + SortedValues[n] * 0.75;
                //return SortedValues[n+0-1]*0.25+SortedValues[n+1-1]*0.75 
              }

              if ((SortedValues.length - 3) % 4 == 0) {
                var n = SortedValues.length - 3 >> 2;
                return SortedValues[n] * 0.75 + SortedValues[n + 1] * 0.25;
                //return SortedValues[n+1-1]*0.75+SortedValues[n+2-1]*0.25 
              }
            };

            atEveryStepDo.moments_avg = function ()
            //m1 - not useful
            {
              if (findmoments === null) findmoments = atEveryStepDo.moments();
              return findmoments.average;
            };
            atEveryStepDo.variance = function ()
            //m2
            {
              if (findmoments === null) findmoments = atEveryStepDo.moments();
              return findmoments.variance;
            };
            atEveryStepDo.standardDeviation = function ()
            //sqrt(m2)
            {
              if (findmoments === null) findmoments = atEveryStepDo.moments();
              return findmoments.standardDeviation;
            };
            atEveryStepDo.skew = function ()
            // using m2 , m3
            {
              if (findmoments === null) findmoments = atEveryStepDo.moments();
              return findmoments.skew;
            };
            atEveryStepDo.kurtosis = function ()
            // using m2, m3 ,m4
            {
              if (findmoments === null) findmoments = atEveryStepDo.moments();
              return findmoments.kurtosis;
            };
            atEveryStepDo.exkurtosis = function ()
            // using kurtosis - 3
            {
              if (findmoments === null) findmoments = atEveryStepDo.moments();
              return findmoments.exkurtosis;
            };
            atEveryStepDo.moments = function () {
              var o = {};
              if (this.c > 0) {
                //e(x), e(x*x), e(x*x*x), and e(x*x*x*x)
                var c = DequeValue.length,
                  ex = Sum / c,
                  exx = Sum2 / c,
                  exxx = Sum3 / c,
                  exxxx = Sum4 / c,
                  //central moments:
                  m1 = ex,
                  m2 = Sum2 / c - ex;
                m3 = exxx - 3 * exx * ex + 2 * ex * ex * ex;
                m4 = exxxx - 3 * exxx * ex + 6 * exx * ex * ex - -3 * ex * ex * ex * ex;
                o.average = m1;
                o.variance = m2;
                o.standardDeviation = Math.pow(o.variance, .5);
                if (c > 2) {
                  //http://www.amstat.org/publications/jse/v19n2/doane.pdf
                  //http://en.wikipedia.org/wiki/Skewness
                  o.skew = Math.pow(c * (c - 1), .5) / (c - 2) * m3 / Math.pow(m2, 1.5);
                }
                if (m2 > 0) {
                  //http://en.wikipedia.org/wiki/Kurtosis
                  o.exkurtosis = m4 / m2 / m2 - 3;
                  o.kurtosis = m4 / m2 / m2;
                }
              }
              return o;
            };
            atEveryStepDo.median = function () {
              return prevmedian;
            }; //q2

            atEveryStepDo.q3 = function () {
              if (SortedValues.length == 1) return SortedValues[0];
              if (SortedValues.length == 2) return SortedValues[0] * 0.25 + SortedValues[1] * 0.75;
              if (SortedValues.length == 3) return SortedValues[1] * 0.5 + SortedValues[2] * 0.5;
              if ((SortedValues.length - 1) % 4 == 0) {
                var n3 = (SortedValues.length - 1 >> 2) * 3;
                return SortedValues[n3] * 0.75 + SortedValues[n3 + 1] * 0.25;
                //return SortedValues[n3+1-1]*0.75+SortedValues[n3+2-1]*0.25 
              }

              if ((SortedValues.length - 3) % 4 == 0) {
                var n3 = (SortedValues.length - 3 >> 2) * 3;
                return SortedValues[n3 + 1] * 0.25 + SortedValues[n3 + 2] * 0.75;
                //return SortedValues[n3+2-1]*0.25+SortedValues[n3+3-1]*0.75 
              }
            };

            atEveryStepDo.max = function () {
              return SortedValues[SortedValues.length - 1];
            };
            atEveryStepDo.center = function () {
              return (SortedValues[0] + SortedValues[SortedValues.length - 1]) / 2;
            };

            //atEveryStepDo.nabovecenter=function(){
            // if(findcenter===null) findcenter=LsortedIndex(SortedValues, (SortedValues[0]+SortedValues[SortedValues.length-1])/2 );
            // return SortedValues.length-findcenter-1;
            //}
            //atEveryStepDo.nbelowcenter=function(){
            // if(findcenter===null) findcenter=LsortedIndex(SortedValues, (SortedValues[0]+SortedValues[SortedValues.length-1])/2 );
            // return findcenter-1;
            //}

            //http://books.google.co.il/books?id=4HrJs2o9C5YC&pg=PA32&lpg=PA32&dq=q3+q2+q2+q1+skewness&source=bl&ots=eD24ehhNoz&sig=xxhMOFVL5JngB5JPi5WieIRTCaI&hl=en&sa=X&ei=xfVQVIPzFOLnywPM9YLIAw&ved=0CEoQ6AEwBw#v=onepage&q=Q.D.&f=false

            atEveryStepDo.medianskew = function () {
              //medianskew=(max - median)-(median - min)
              return SortedValues[SortedValues.length - 1] - prevmedian - (prevmedian - SortedValues[0]);
            };
            atEveryStepDo.medianskew_bowleys_coef = function () {
              //medianskew=(max - median)-(median - min)
              return (SortedValues[SortedValues.length - 1] - prevmedian) * (prevmedian - SortedValues[0]) / (SortedValues[SortedValues.length - 1] - SortedValues[0]);
            };
            atEveryStepDo.mediankurt = function () {
              //q.d=quartile deviatin=(q3-q1)/2, mediankurt=q.d/(p90 - p10), mediankurt=((q3-q1)/2	)/(p90 - p10) 	
              var p90 = Math.round((SortedValues.length - 1) * 0.9);
              var p10 = Math.round((SortedValues.length - 1) * 0.1);
              return (SortedValues[SortedValues.length - 1] - prevmedian) * (prevmedian - SortedValues[0]) / (SortedValues[p90] - SortedValues[p10]);
            };
            atEveryStepDo.pabovecenter = function () {
              if (findcenter === null) findcenter = LsortedIndex(SortedValues, (SortedValues[0] + SortedValues[SortedValues.length - 1]) / 2);
              return (SortedValues.length - 1 - findcenter) / (SortedValues.length - 1);
            };
            atEveryStepDo.pbelowcenter = function () {
              if (findcenter === null) findcenter = LsortedIndex(SortedValues, (SortedValues[0] + SortedValues[SortedValues.length - 1]) / 2);
              return findcenter / (SortedValues.length - 1);
            };
            return atEveryStepDo;
          }
          function RollingSumPerIndex(WindowSize, UsualIndexSkipBetweenOccations)
          // generator
          {
            var DequeIndex = [],
              DequeValue = [],
              T = WindowSize,
              Sum = 0,
              PrevIndex = false,
              U = UsualIndexSkipBetweenOccations;
            function atEveryStepDo(CurrentValue, CurrentIndex) {
              while (DequeIndex.length !== 0 && DequeIndex[0] <= CurrentIndex - T && DequeIndex[0] != CurrentIndex)
              // do not remove current index so you will be able to make an avarage to not devide by zero, because current-current =zero assumes raising order in the index and window size of at last two
              {
                PrevIndex = DequeIndex.shift();
                Sum -= DequeValue.shift();
              }
              if (PrevIndex === false) PrevIndex = CurrentIndex - U;

              //Head is too old, it is leaving the window

              DequeIndex.push(CurrentIndex);
              DequeValue.push(CurrentValue);
              Sum += CurrentValue;
              var Div = CurrentIndex - PrevIndex;
              if (Div == 0) Div = U;
              return Sum / Div; //Head value is minimum in the current window
            }

            atEveryStepDo.setWindowSize = function (WindowSize) {
              T = WindowSize;
            };
            atEveryStepDo.setUsualIndexSkipBetweenOccations = function (UsualIndexSkipBetweenOccations) {
              U = UsualIndexSkipBetweenOccations;
            };
            atEveryStepDo.reset = function () {
              DequeIndex.splice(0, DequeIndex.length);
              DequeValue.splice(0, DequeValue.length);
              Sum = 0;
              PrevIndex = false;
            };
            return atEveryStepDo;
          }
          function Delay(WindowSize, UndefinedValue) {
            var DequeValue = [],
              T = WindowSize,
              U = UndefinedValue;
            function atEveryStepDo(CurrentValue) {
              var ret = U;
              if (DequeValue.length == T) {
                ret = DequeValue.shift();
              }
              DequeValue.push(CurrentValue);
              return ret;
            }
            atEveryStepDo.setWindowSize = function (WindowSize) {
              T = WindowSize;
            };
            atEveryStepDo.setUndefinedValue = function (WindowSize) {
              U = UndefinedValue;
            };
            atEveryStepDo.reset = function (WindowSize) {
              DequeValue.splice(0, DequeValue.length);
            };
            return atEveryStepDo;
          }
          function HideFirst(WindowSize, UndefinedValue) {
            var DequeValue = 1,
              T = WindowSize + 1,
              U = UndefinedValue;
            function atEveryStepDo(CurrentValue) {
              if (DequeValue == T) {
                return CurrentValue;
              }
              DequeValue++;
              return U;
            }
            atEveryStepDo.setWindowSize = function (WindowSize) {
              T = WindowSize + 1;
            };
            atEveryStepDo.setUndefinedValue = function (WindowSize) {
              U = UndefinedValue;
            };
            atEveryStepDo.reset = function () {
              DequeValue = 0;
            };
            return atEveryStepDo;
          }
          function DelayIndex(WindowSize, UsualIndexSkipBetweenOccations, UndefinedValue)
          // generator, expects some high frequency of time inserts because if there will be a delay or no inserts it will stop working;
          {
            var DequeIndex = [],
              DequeValue = [],
              T = WindowSize,
              PrevValue = UndefinedValue;
            function atEveryStepDo(CurrentValue, CurrentIndex) {
              DequeIndex.push(CurrentIndex);
              DequeValue.push(CurrentValue);
              //take first to fall off and throw away the rest
              if (DequeIndex.length !== 0 && DequeIndex[0] <= CurrentIndex - T) {
                DequeIndex.shift();
                PrevValue = DequeValue.shift();
                while (DequeIndex.length !== 0 && DequeIndex[0] <= CurrentIndex - T) {
                  DequeIndex.shift();
                  DequeValue.shift();
                }
              }
              return PrevValue;
            }
            atEveryStepDo.setWindowSize = function (WindowSize) {
              T = WindowSize;
            };
            atEveryStepDo.setUsualIndexSkipBetweenOccations = function (UsualIndexSkipBetweenOccations) {};
            atEveryStepDo.reset = function () {
              DequeIndex.splice(0, DequeIndex.length);
              DequeValue.splice(0, DequeValue.length);
              PrevValue = UndefinedValue;
            };
            return atEveryStepDo;
          }
          function PositiveLately(WindowSize) {
            var PositiveCount = -1;
            function atEveryStepDo(CurrentValue) {
              //if(CurrentValue<0)PositiveCount=-1; // should not reset on negative
              if (CurrentValue > 0) PositiveCount = 0; // should reset each time
              if (PositiveCount >= 0) PositiveCount++;
              if (PositiveCount > WindowSize) PositiveCount = -1;
              return PositiveCount > 0;
            }
            atEveryStepDo.setWindowSize = function (WindowSize) {};
            atEveryStepDo.reset = function () {
              PositiveCount = -1;
            };
            return atEveryStepDo;
          }
          function PositiveLatelyIndex(WindowSize)
          // generator, expects some high frequency of time inserts because if there will be a delay or no inserts it will stop working;
          {
            var T = WindowSize,
              PrevIndex = false,
              PositiveCount = -1;
            function atEveryStepDo(CurrentValue, CurrentIndex) {
              //if(CurrentValue<0)PositiveCount=-1;
              if (CurrentValue > 0) {
                PrevIndex = CurrentIndex;
                PositiveCount = 0;
              } // should reset each time
              if (PositiveCount >= 0) PositiveCount++;
              if (PrevIndex != false && PrevIndex <= CurrentIndex - T) PositiveCount = -1;
              return PositiveCount > 0;
            }
            atEveryStepDo.setWindowSize = function (WindowSize) {
              T = WindowSize;
            };
            atEveryStepDo.reset = function () {
              PrevIndex = false;
              PositiveCount = -1;
            };
            return atEveryStepDo;
          }

          // choosing PreRoundingMultiplier, if PreRoundingMultiplier=30 than bins will be like = 0.1,0.2,0.3 .  can be 100 for 0.01 bins,  can be  1000 for 0.001 bins
          //

          // this histogram do not remove anything just accamulates all, until you do hist.reset()
          function Histogram(PreRoundingMultiplier)
          // generator
          {
            var RD = PreRoundingMultiplier,
              hist = new Map();
            function atEveryStepDo(CurrentPosition) {
              var CurrentAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
              //Head is too old, it is leaving the window

              var CurrentPositionRound = parseFloat((Math.round(CurrentPosition * RD) / RD).toFixed(12));
              if (hist.has(CurrentPositionRound)) hist.set(CurrentPositionRound, parseFloat((hist.get(CurrentPositionRound) + CurrentAmount).toFixed(12)));else hist.set(CurrentPositionRound, CurrentAmount);
              return hist;
            }
            atEveryStepDo.hist = hist;
            atEveryStepDo.reset = function () {
              hist.clear();
            };
            return atEveryStepDo;
          }
          function RollingHistogram(WindowSize, PreRoundingMultiplier)
          // generator
          {
            var DequePosition = [],
              DequeAmount = [],
              T = WindowSize,
              RD = PreRoundingMultiplier,
              hist = new Map();
            function atEveryStepDo(CurrentPosition) {
              var CurrentAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
              if (DequePosition.length >= T) {
                var prevpos = DequePosition.shift();
                var prevamount = DequeAmount.shift();
                var newamount = parseFloat((hist.get(prevpos) - prevamount).toFixed(12));
                if (newamount !== 0) hist.set(prevpos, newamount);else hist.delete(prevpos);
              }
              //Head is too old, it is leaving the window

              var CurrentPositionRound = parseFloat((Math.round(CurrentPosition * RD) / RD).toFixed(12));
              DequePosition.push(CurrentPositionRound);
              DequeAmount.push(CurrentAmount);
              if (hist.has(CurrentPositionRound)) hist.set(CurrentPositionRound, parseFloat((hist.get(CurrentPositionRound) + CurrentAmount).toFixed(12)));else hist.set(CurrentPositionRound, CurrentAmount);
              return hist;
            }
            atEveryStepDo.hist = hist;
            atEveryStepDo.setWindowSize = function (WindowSize) {
              T = WindowSize;
            };
            atEveryStepDo.reset = function () {
              Sum = 0;
              DequePosition.splice(0, DequePosition.length);
            };
            return atEveryStepDo;
          }
          function RollingHistogramIndex(WindowSize, PreRoundingMultiplier)
          // generator
          {
            var DequeIndex = [],
              DequePosition = [],
              DequeAmount = [],
              T = WindowSize,
              RD = PreRoundingMultiplier,
              hist = new Map();
            function atEveryStepDo(CurrentPosition, CurrentIndex) {
              var CurrentAmount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
              if (!CurrentAmount && CurrentAmount !== 0 || !CurrentPosition && CurrentPosition !== 0) return hist;
              while (DequeIndex.length !== 0 && DequeIndex[0] <= CurrentIndex - T) {
                DequeIndex.shift();
                var prevpos = DequePosition.shift();
                var prevamount = DequeAmount.shift();
                if (!prevpos && prevpos !== 0) console.log('nana1', {
                  prevamount: prevamount,
                  prevpos: prevpos
                });
                if (!prevamount && prevamount !== 0) console.log('nana2', {
                  prevamount: prevamount,
                  prevpos: prevpos
                });
                if (hist.has(prevpos)) {
                  var newamount = parseFloat((hist.get(prevpos) - prevamount).toFixed(12));
                  if (!newamount && newamount !== 0) console.log('nana3', {
                    newamount: newamount,
                    prevamount: prevamount,
                    prevpos: prevpos
                  });
                  if (newamount !== 0) hist.set(prevpos, newamount);else hist.delete(prevpos);
                }
              }

              //Head is too old, it is leaving the window

              var CurrentPositionRound = parseFloat((Math.round(CurrentPosition * RD) / RD).toFixed(12));
              DequePosition.push(CurrentPositionRound);
              DequeAmount.push(CurrentAmount);
              DequeIndex.push(CurrentIndex);
              if (hist.has(CurrentPositionRound)) {
                var _newamount = parseFloat((hist.get(CurrentPositionRound) + CurrentAmount).toFixed(12));
                hist.set(CurrentPositionRound, _newamount);
              } else hist.set(CurrentPositionRound, CurrentAmount);
              return hist;
            }
            atEveryStepDo.hist = hist;
            atEveryStepDo.setWindowSize = function (WindowSize) {
              T = WindowSize;
            };
            atEveryStepDo.reset = function () {
              DequeIndex.splice(0, DequeIndex.length);
              DequePosition.splice(0, DequePosition.length);
              Sum = 0;
            };
            return atEveryStepDo;
          }

          //example1: // you can compose all sorts of functions like this, this is a simple one
          /*
          var Stats=require('efficient-rolling-stats');
          //useful: 
          // var stats=Stats.AllStats(101,50,15,0.25,7.5) // sample for 15 minutes and usually the input is every 15 seconds so the first input will be more or less not outlier,delay the timed input by 7.5 minutes
          //for testing:
          var stats=Stats.AllStats(11,5,1,0.25,0.5) // sample for 15 minutes and usually the input is every 15 seconds so the first input will be more or less not outlier,delay the timed input by 7.5 minutes
          setInterval(function(){stats(Math.random()*100,new Date().getTime()/60000)},1500) // input in minutes,  than also the configuratin arguments can be in minutes
          stats(Math.random()*100,new Date().getTime()/60000)
          */

          var Stats = exports;
          function AllStats(size, delay, timesize, usualtime, timedelay) {
            var list = [],
              add = function add(v) {
                list.push(v);
                return v;
              };
            var avgtime = add(Stats.RollingAvg(size)),
              stdev = add(Stats.RollingAvg(size)),
              zavg = add(Stats.RollingAvg(size)),
              median = add(Stats.RollingMedian(size)),
              mstdev = add(Stats.RollingAvg(size)),
              mzavg = add(Stats.RollingAvg(size)),
              tzavg = add(Stats.RollingAvgIndex(timesize)),
              tstdev = add(Stats.RollingAvgIndex(timesize)),
              tmedian = add(Stats.RollingMedianIndex(timesize)),
              tmzavg = add(Stats.RollingAvgIndex(timesize)),
              tmstdev = add(Stats.RollingAvgIndex(timesize)),
              tsum = add(Stats.RollingSumPerIndex(timesize, usualtime)) // may be its called momentum or speed
              ,
              value_delay = add(Stats.Delay(delay)) // because i can't move the indicators forewared but i can move the number backwards so it will match with the lagging indicators
              ,
              tvalue_delay = add(Stats.DelayIndex(timedelay, usualtime)),
              index_delay = add(Stats.Delay(delay)) // add the coresponding index to the delaied value, the other option is not to dalay anything and offset it the presentation
              ,
              tindex_delay = add(Stats.DelayIndex(timedelay, usualtime)),
              prev = false,
              count = 0,
              tcount = 0;
            function stats(n, t) {
              var o = {};
              o.median = median(n);
              o.min = median.min();
              o.max = median.max();
              //q0 is min
              o.q1 = median.q1();
              //q2 is median
              o.q3 = median.q3();
              //q4 is max
              o.avg = median.avg();
              o.stdev = Math.sqrt(stdev(Math.pow(n - o.avg, 2)));
              o.z = o.stdev == 0 ? 0 : (n - o.avg) / o.stdev;
              o.zavg = zavg(o.z);
              o.mstdev = Math.sqrt(mstdev(Math.pow(n - o.median, 2)));
              o.mz = o.mstdev == 0 ? 0 : 0.6745 * (n - o.median) / o.mstdev; // mz> 3.5 = outlier http://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm , http://stackoverflow.com/questions/22354094/pythonic-way-of-detecting-outliers-in-one-dimensional-observation-data, http://www.itl.nist.gov/div898/handbook/index.htm , idea from: https://www.npmjs.org/package/stats-analysis , It is possible to Calculate, median absolute deviation, Outlier Detection (using Iglewicz and Hoaglin's method) MADz>3.5, Outlier Filter / Removal
              o.mzavg = mzavg(o.mz);
              o.tmedian = tmedian(n, t);
              o.tmin = tmedian.min();
              o.tmax = tmedian.max();
              o.tavg = tmedian.avg();
              o.tcenter = tmedian.center();
              //q0 is min
              o.tq1 = tmedian.q1();
              //q2 is median
              o.tq3 = tmedian.q3();
              //q4 is max
              o.tsum = tsum(n, t);
              o.tstdev = Math.sqrt(tstdev(Math.pow(n - o.tavg, 2), t));
              o.tz = o.tstdev == 0 ? 0 : (n - o.tavg) / o.tstdev;
              o.tzavg = tzavg(o.tz, t);
              o.tmstdev = Math.sqrt(tmstdev(Math.pow(n - o.tmedian, 2), t));
              o.tmz = o.tmstdev == 0 ? 0 : 0.6745 * (n - o.tmedian) / o.tmstdev; // tmz> 3.5 = outlier 
              o.tmzavg = tmzavg(o.tmz, t);
              if (prev === false) prev = t - usualtime;
              var delta = t - prev;
              prev = t;
              o.avgtime = avgtime(delta); // to have result in minutes

              o.count = count;
              count++; // it is good ide to have count to skip the initial
              o.tcount = tcount;
              tcount += delta;
              o.value_delay = value_delay(n);
              o.tvalue_delay = tvalue_delay(n, t);
              o.index_delay = index_delay(t);
              o.tindex_delay = tindex_delay(t, t);
              return o;
            }
            stats.reset = function () {
              for (var i = 0; i < list.length; i++) {
                list[i].reset();
              }
              prev = false;
              count = 0;
            };
            return stats;
          }

          //example2:

          function SimpleStats(size, delay) {
            var min = Stats.RollingMin(size),
              max = Stats.RollingMax(size),
              avg = Stats.RollingAvg(size),
              value_delay = Stats.Delay(delay);
            function stats(n) {
              var o = {};
              o.min = min(n);
              o.max = max(n);
              o.avg = avg(n);
              o.value_delay = value_delay(n);
              return o;
            }
            stats.reset = function () {
              min.reset();
              max.reset();
              avg.reset();
              value_delay.reset();
            };
            return stats;
          }

          //example3: 
          function SimpleStatsNoDelay(size) {
            var min = Stats.RollingMin(size),
              max = Stats.RollingMax(size),
              avg = Stats.RollingAvg(size);
            function stats(n) {
              var o = {};
              o.min = min(n);
              o.max = max(n);
              o.avg = avg(n);
              return o;
            }
            stats.reset = function () {
              min.reset();
              max.reset();
              avg.reset();
            };
            return stats;
          }
          exports.RollingMin = RollingMin;
          exports.RollingMax = RollingMax;
          exports.RollingAvg = RollingAvg;
          exports.RollingMedian = RollingMedian;
          exports.RollingMinIndex = RollingMinIndex;
          exports.RollingMaxIndex = RollingMaxIndex;
          exports.RollingAvgIndex = RollingAvgIndex;
          exports.RollingMedianIndex = RollingMedianIndex;
          exports.RollingSumPerIndex = RollingSumPerIndex;
          exports.Delay = Delay;
          exports.DelayIndex = DelayIndex;
          exports.AllStats = AllStats;
          exports.SimpleStats = SimpleStats;
          exports.SimpleStatsNoDelay = SimpleStatsNoDelay;
          exports.PositiveLately = PositiveLately;
          exports.PositiveLatelyIndex = PositiveLatelyIndex;
          exports.Histogram = Histogram;
          exports.RollingHistogram = RollingHistogram;
          exports.RollingHistogramIndex = RollingHistogramIndex;
          exports.HideFirst = HideFirst;
        })(efficientRollingStats);

        /* src/lib/CheckButton.svelte generated by Svelte v3.55.0 */

        function create_fragment$8(ctx) {
          var label;
          var input;
          var t0;
          var div;
          var t1;
          var mounted;
          var dispose;
          return {
            c: function c() {
              label = element("label");
              input = element("input");
              t0 = space();
              div = element("div");
              t1 = text( /*name*/ctx[1]);
              attr(input, "type", "checkbox");
              attr(input, "class", "hidden peer");
              attr(input, "autocomplete", "off");
              attr(div, "class", "basic-button");
              attr(div, "type", "button");
            },
            m: function m(target, anchor) {
              insert(target, label, anchor);
              append(label, input);
              input.checked = /*checked*/ctx[0];
              append(label, t0);
              append(label, div);
              append(div, t1);
              if (!mounted) {
                dispose = [listen(input, "change", /*input_change_handler*/ctx[4]), listen(input, "change", /*change_handler*/ctx[3]), listen(label, "click", /*click_handler*/ctx[2])];
                mounted = true;
              }
            },
            p: function p(ctx, _ref8) {
              var _ref9 = _slicedToArray(_ref8, 1),
                dirty = _ref9[0];
              if (dirty & /*checked*/1) {
                input.checked = /*checked*/ctx[0];
              }
              if (dirty & /*name*/2) set_data(t1, /*name*/ctx[1]);
            },
            i: noop,
            o: noop,
            d: function d(detaching) {
              if (detaching) detach(label);
              mounted = false;
              run_all(dispose);
            }
          };
        }
        function instance$8($$self, $$props, $$invalidate) {
          var name = $$props.name;
          var checked = $$props.checked;
          function click_handler(event) {
            bubble.call(this, $$self, event);
          }
          function change_handler(event) {
            bubble.call(this, $$self, event);
          }
          function input_change_handler() {
            checked = this.checked;
            $$invalidate(0, checked);
          }
          $$self.$$set = function ($$props) {
            if ('name' in $$props) $$invalidate(1, name = $$props.name);
            if ('checked' in $$props) $$invalidate(0, checked = $$props.checked);
          };
          return [checked, name, click_handler, change_handler, input_change_handler];
        }
        var CheckButton = /*#__PURE__*/function (_SvelteComponent) {
          _inherits(CheckButton, _SvelteComponent);
          var _super = _createSuper(CheckButton);
          function CheckButton(options) {
            var _this5;
            _classCallCheck(this, CheckButton);
            _this5 = _super.call(this);
            init$1(_assertThisInitialized2(_this5), options, instance$8, create_fragment$8, safe_not_equal, {
              name: 1,
              checked: 0
            });
            return _this5;
          }
          return _createClass(CheckButton);
        }(SvelteComponent);
        /* src/lib/LineThroughButton.svelte generated by Svelte v3.55.0 */
        function create_fragment$7(ctx) {
          var label;
          var input;
          var t0;
          var div;
          var t1;
          var t2;
          var t3;
          var t4;
          var current;
          var mounted;
          var dispose;
          var default_slot_template = /*#slots*/ctx[3].default;
          var default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[2], null);
          return {
            c: function c() {
              label = element("label");
              input = element("input");
              t0 = space();
              div = element("div");
              t1 = text(" ");
              t2 = text( /*name*/ctx[1]);
              t3 = text(" ");
              t4 = space();
              if (default_slot) default_slot.c();
              attr(input, "type", "checkbox");
              attr(input, "class", "hidden peer");
              attr(input, "autocomplete", "off");
              attr(div, "class", "basic-button line-through thick-line-through peer-checked:no-underline");
              attr(div, "type", "button");
            },
            m: function m(target, anchor) {
              insert(target, label, anchor);
              append(label, input);
              input.checked = /*checked*/ctx[0];
              append(label, t0);
              append(label, div);
              append(div, t1);
              append(div, t2);
              append(div, t3);
              append(label, t4);
              if (default_slot) {
                default_slot.m(label, null);
              }
              current = true;
              if (!mounted) {
                dispose = [listen(input, "change", /*input_change_handler*/ctx[6]), listen(input, "change", /*change_handler*/ctx[5]), listen(label, "click", /*click_handler*/ctx[4])];
                mounted = true;
              }
            },
            p: function p(ctx, _ref10) {
              var _ref11 = _slicedToArray(_ref10, 1),
                dirty = _ref11[0];
              if (dirty & /*checked*/1) {
                input.checked = /*checked*/ctx[0];
              }
              if (!current || dirty & /*name*/2) set_data(t2, /*name*/ctx[1]);
              if (default_slot) {
                if (default_slot.p && (!current || dirty & /*$$scope*/4)) {
                  update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[2], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[2]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[2], dirty, null), null);
                }
              }
            },
            i: function i(local) {
              if (current) return;
              transition_in(default_slot, local);
              current = true;
            },
            o: function o(local) {
              transition_out(default_slot, local);
              current = false;
            },
            d: function d(detaching) {
              if (detaching) detach(label);
              if (default_slot) default_slot.d(detaching);
              mounted = false;
              run_all(dispose);
            }
          };
        }
        function instance$7($$self, $$props, $$invalidate) {
          var _$$props$$$slots = $$props.$$slots,
            slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
            $$scope = $$props.$$scope;
          var name = $$props.name;
          var checked = $$props.checked;
          function click_handler(event) {
            bubble.call(this, $$self, event);
          }
          function change_handler(event) {
            bubble.call(this, $$self, event);
          }
          function input_change_handler() {
            checked = this.checked;
            $$invalidate(0, checked);
          }
          $$self.$$set = function ($$props) {
            if ('name' in $$props) $$invalidate(1, name = $$props.name);
            if ('checked' in $$props) $$invalidate(0, checked = $$props.checked);
            if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
          };
          return [checked, name, $$scope, slots, click_handler, change_handler, input_change_handler];
        }
        var LineThroughButton = /*#__PURE__*/function (_SvelteComponent2) {
          _inherits(LineThroughButton, _SvelteComponent2);
          var _super2 = _createSuper(LineThroughButton);
          function LineThroughButton(options) {
            var _this6;
            _classCallCheck(this, LineThroughButton);
            _this6 = _super2.call(this);
            init$1(_assertThisInitialized2(_this6), options, instance$7, create_fragment$7, safe_not_equal, {
              name: 1,
              checked: 0
            });
            return _this6;
          }
          return _createClass(LineThroughButton);
        }(SvelteComponent);
        var scriptRel = 'modulepreload';
        var assetsURL = function assetsURL(dep) {
          return "/" + dep;
        };
        var seen = {};
        var __vitePreload = function preload(baseModule, deps, importerUrl) {
          // @ts-expect-error false will be replaced with boolean later
          if (!false || !deps || deps.length === 0) {
            return baseModule();
          }
          var links = document.getElementsByTagName('link');
          return Promise.all(deps.map(function (dep) {
            // @ts-expect-error assetsURL is declared before preload.toString()
            dep = assetsURL(dep);
            if (dep in seen) return;
            seen[dep] = true;
            var isCss = dep.endsWith('.css');
            var cssSelector = isCss ? '[rel="stylesheet"]' : '';
            var isBaseRelative = !!importerUrl;
            // check if the file is already preloaded by SSR markup
            if (isBaseRelative) {
              // When isBaseRelative is true then we have `importerUrl` and `dep` is
              // already converted to an absolute URL by the `assetsURL` function
              for (var i = links.length - 1; i >= 0; i--) {
                var _link = links[i];
                // The `links[i].href` is an absolute URL thanks to browser doing the work
                // for us. See https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#reflecting-content-attributes-in-idl-attributes:idl-domstring-5
                if (_link.href === dep && (!isCss || _link.rel === 'stylesheet')) {
                  return;
                }
              }
            } else if (document.querySelector("link[href=\"".concat(dep, "\"]").concat(cssSelector))) {
              return;
            }
            var link = document.createElement('link');
            link.rel = isCss ? 'stylesheet' : scriptRel;
            if (!isCss) {
              link.as = 'script';
              link.crossOrigin = '';
            }
            link.href = dep;
            document.head.appendChild(link);
            if (isCss) {
              return new Promise(function (res, rej) {
                link.addEventListener('load', res);
                link.addEventListener('error', function () {
                  return rej(new Error("Unable to preload CSS for ".concat(dep)));
                });
              });
            }
          })).then(function () {
            return baseModule();
          });
        };
        var A, I, B;
        var g = {
          env: {
            emscripten_notify_memory_growth: function emscripten_notify_memory_growth(A) {
              B = new Uint8Array(I.exports.memory.buffer);
            }
          }
        };
        var Q = /*#__PURE__*/function () {
          function Q() {
            _classCallCheck(this, Q);
          }
          _createClass(Q, [{
            key: "init",
            value: function init() {
              return A || (A = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + C).then(function (A) {
                return A.arrayBuffer();
              }).then(function (A) {
                return WebAssembly.instantiate(A, g);
              }).then(this._init) : WebAssembly.instantiate(Buffer.from(C, "base64"), g).then(this._init), A);
            }
          }, {
            key: "_init",
            value: function _init(A) {
              I = A.instance, g.env.emscripten_notify_memory_growth(0);
            }
          }, {
            key: "decode",
            value: function decode(A) {
              var g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              if (!I) throw new Error("ZSTDDecoder: Await .init() before decoding.");
              var _Q = A.byteLength,
                C = I.exports.malloc(_Q);
              B.set(A, C), g = g || Number(I.exports.ZSTD_findDecompressedSize(C, _Q));
              var E = I.exports.malloc(g),
                i = I.exports.ZSTD_decompress(E, g, C, _Q),
                D = B.slice(E, E + i);
              return I.exports.free(C), I.exports.free(E), D;
            }
          }]);
          return Q;
        }();
        var C = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";

        /* Copyright 2020-2022 Ethan Halsall
            
            This file is part of codec-parser.
            
            codec-parser is free software: you can redistribute it and/or modify
            it under the terms of the GNU Lesser General Public License as published by
            the Free Software Foundation, either version 3 of the License, or
            (at your option) any later version.
             codec-parser is distributed in the hope that it will be useful,
            but WITHOUT ANY WARRANTY; without even the implied warranty of
            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
            GNU Lesser General Public License for more details.
             You should have received a copy of the GNU Lesser General Public License
            along with this program.  If not, see <https://www.gnu.org/licenses/>
        */

        var getCrcTable = function getCrcTable(crcTable, crcInitialValueFunction, crcFunction) {
          for (var byte = 0; byte < crcTable.length; byte++) {
            var crc = crcInitialValueFunction(byte);
            for (var bit = 8; bit > 0; bit--) {
              crc = crcFunction(crc);
            }
            crcTable[byte] = crc;
          }
          return crcTable;
        };
        getCrcTable(new Uint8Array(256), function (b) {
          return b;
        }, function (crc) {
          return crc & 0x80 ? 0x07 ^ crc << 1 : crc << 1;
        });
        var flacCrc16Table = [getCrcTable(new Uint16Array(256), function (b) {
          return b << 8;
        }, function (crc) {
          return crc << 1 ^ (crc & 1 << 15 ? 0x8005 : 0);
        })];
        var crc32Table = [getCrcTable(new Uint32Array(256), function (b) {
          return b;
        }, function (crc) {
          return crc >>> 1 ^ (crc & 1) * 0xedb88320;
        })];

        // build crc tables
        for (var i = 0; i < 15; i++) {
          flacCrc16Table.push(new Uint16Array(256));
          crc32Table.push(new Uint32Array(256));
          for (var j = 0; j <= 0xff; j++) {
            flacCrc16Table[i + 1][j] = flacCrc16Table[0][flacCrc16Table[i][j] >>> 8] ^ flacCrc16Table[i][j] << 8;
            crc32Table[i + 1][j] = crc32Table[i][j] >>> 8 ^ crc32Table[0][crc32Table[i][j] & 0xff];
          }
        }
        var reserved = "reserved";

        // channel mappings
        var mappingJoin = ", ";
        var front = "front";
        var side = "side";
        var rear = "rear";
        var left$1 = "left";
        var center = "center";
        var right$1 = "right";

        // prettier-ignore
        /*
        [
          [
            "left, right",
            "left, right, center",
            "left, center, right",
            "center, left, right",
            "center"
          ],
          [
            "front left, front right",
            "front left, front right, front center",
            "front left, front center, front right",
            "front center, front left, front right",
            "front center"
          ],
          [
            "side left, side right",
            "side left, side right, side center",
            "side left, side center, side right",
            "side center, side left, side right",
            "side center"
          ],
          [
            "rear left, rear right",
            "rear left, rear right, rear center",
            "rear left, rear center, rear right",
            "rear center, rear left, rear right",
            "rear center"
          ]
        ]
        */
        var channelMappings = ["", front + " ", side + " ", rear + " "].map(function (x) {
          return [[left$1, right$1], [left$1, right$1, center], [left$1, center, right$1], [center, left$1, right$1], [center]].flatMap(function (y) {
            return y.map(function (z) {
              return x + z;
            }).join(mappingJoin);
          });
        });
        var lfe = "LFE";
        var monophonic = "monophonic (mono)";
        var stereo = "stereo";
        var surround = "surround";
        var channels = [monophonic, stereo, "linear ".concat(surround), "quadraphonic", "5.0 ".concat(surround), "5.1 ".concat(surround), "6.1 ".concat(surround), "7.1 ".concat(surround)];
        var getChannelMapping = function getChannelMapping(channelCount) {
          for (var _len2 = arguments.length, mappings = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            mappings[_key2 - 1] = arguments[_key2];
          }
          return "".concat(channels[channelCount - 1], " (").concat(mappings.join(mappingJoin), ")");
        };

        // prettier-ignore
        [monophonic, getChannelMapping(2, channelMappings[0][0]), getChannelMapping(3, channelMappings[0][2]), getChannelMapping(4, channelMappings[1][0], channelMappings[3][0]), getChannelMapping(5, channelMappings[1][2], channelMappings[3][0]), getChannelMapping(6, channelMappings[1][2], channelMappings[3][0], lfe), getChannelMapping(7, channelMappings[1][2], channelMappings[2][0], channelMappings[3][4], lfe), getChannelMapping(8, channelMappings[1][2], channelMappings[2][0], channelMappings[3][0], lfe)];

        /* Copyright 2020-2022 Ethan Halsall
            
            This file is part of codec-parser.
            
            codec-parser is free software: you can redistribute it and/or modify
            it under the terms of the GNU Lesser General Public License as published by
            the Free Software Foundation, either version 3 of the License, or
            (at your option) any later version.
             codec-parser is distributed in the hope that it will be useful,
            but WITHOUT ANY WARRANTY; without even the implied warranty of
            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
            GNU Lesser General Public License for more details.
             You should have received a copy of the GNU Lesser General Public License
            along with this program.  If not, see <https://www.gnu.org/licenses/>
        */

        // prettier-ignore
        ({
          0: {
            channels: 0,
            description: "Defined in AOT Specific Config"
          },
          /*
          'monophonic (mono)'
          'stereo (left, right)'
          'linear surround (front center, front left, front right)'
          'quadraphonic (front center, front left, front right, rear center)'
          '5.0 surround (front center, front left, front right, rear left, rear right)'
          '5.1 surround (front center, front left, front right, rear left, rear right, LFE)'
          '7.1 surround (front center, front left, front right, side left, side right, rear left, rear right, LFE)'
          */
          64: {
            channels: 1,
            description: monophonic
          },
          128: {
            channels: 2,
            description: getChannelMapping(2, channelMappings[0][0])
          },
          192: {
            channels: 3,
            description: getChannelMapping(3, channelMappings[1][3])
          },
          256: {
            channels: 4,
            description: getChannelMapping(4, channelMappings[1][3], channelMappings[3][4])
          },
          320: {
            channels: 5,
            description: getChannelMapping(5, channelMappings[1][3], channelMappings[3][0])
          },
          384: {
            channels: 6,
            description: getChannelMapping(6, channelMappings[1][3], channelMappings[3][0], lfe)
          },
          448: {
            channels: 8,
            description: getChannelMapping(8, channelMappings[1][3], channelMappings[2][0], channelMappings[3][0], lfe)
          }
        });

        /* Copyright 2020-2022 Ethan Halsall
            
            This file is part of codec-parser.
            
            codec-parser is free software: you can redistribute it and/or modify
            it under the terms of the GNU Lesser General Public License as published by
            the Free Software Foundation, either version 3 of the License, or
            (at your option) any later version.
             codec-parser is distributed in the hope that it will be useful,
            but WITHOUT ANY WARRANTY; without even the implied warranty of
            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
            GNU Lesser General Public License for more details.
             You should have received a copy of the GNU Lesser General Public License
            along with this program.  If not, see <https://www.gnu.org/licenses/>
        */

        /* prettier-ignore */
        ({
          /*'
          'monophonic (mono)'
          'stereo (left, right)'
          'linear surround (left, right, center)'
          'quadraphonic (front left, front right, rear left, rear right)'
          '5.0 surround (front left, front right, front center, rear left, rear right)'
          '5.1 surround (front left, front right, front center, LFE, rear left, rear right)'
          '6.1 surround (front left, front right, front center, LFE, rear center, side left, side right)'
          '7.1 surround (front left, front right, front center, LFE, rear left, rear right, side left, side right)'
          */
          0: {
            channels: 1,
            description: monophonic
          },
          16: {
            channels: 2,
            description: getChannelMapping(2, channelMappings[0][0])
          },
          32: {
            channels: 3,
            description: getChannelMapping(3, channelMappings[0][1])
          },
          48: {
            channels: 4,
            description: getChannelMapping(4, channelMappings[1][0], channelMappings[3][0])
          },
          64: {
            channels: 5,
            description: getChannelMapping(5, channelMappings[1][1], channelMappings[3][0])
          },
          80: {
            channels: 6,
            description: getChannelMapping(6, channelMappings[1][1], lfe, channelMappings[3][0])
          },
          96: {
            channels: 7,
            description: getChannelMapping(7, channelMappings[1][1], lfe, channelMappings[3][4], channelMappings[2][0])
          },
          112: {
            channels: 8,
            description: getChannelMapping(8, channelMappings[1][1], lfe, channelMappings[3][0], channelMappings[2][0])
          },
          128: {
            channels: 2,
            description: "".concat(stereo, " (left, diff)")
          },
          144: {
            channels: 2,
            description: "".concat(stereo, " (diff, right)")
          },
          160: {
            channels: 2,
            description: "".concat(stereo, " (avg, diff)")
          },
          176: reserved,
          192: reserved,
          208: reserved,
          224: reserved,
          240: reserved
        });

        // Some numerical data is initialized as -1 even when it doesn't need initialization to help the JIT infer types
        // aliases for shorter compressed code (most minifers don't do this)
        var ab = ArrayBuffer,
          u8 = Uint8Array,
          u16 = Uint16Array,
          i16 = Int16Array,
          i32 = Int32Array;
        var slc = function slc(v, s, e) {
          if (u8.prototype.slice) return u8.prototype.slice.call(v, s, e);
          if (s == null || s < 0) s = 0;
          if (e == null || e > v.length) e = v.length;
          var n = new u8(e - s);
          n.set(v.subarray(s, e));
          return n;
        };
        var fill = function fill(v, n, s, e) {
          if (u8.prototype.fill) return u8.prototype.fill.call(v, n, s, e);
          if (s == null || s < 0) s = 0;
          if (e == null || e > v.length) e = v.length;
          for (; s < e; ++s) {
            v[s] = n;
          }
          return v;
        };
        var cpw = function cpw(v, t, s, e) {
          if (u8.prototype.copyWithin) return u8.prototype.copyWithin.call(v, t, s, e);
          if (s == null || s < 0) s = 0;
          if (e == null || e > v.length) e = v.length;
          while (s < e) {
            v[t++] = v[s++];
          }
        };
        /**
         * Codes for errors generated within this library
         */
        var ZstdErrorCode = {
          InvalidData: 0,
          WindowSizeTooLarge: 1,
          InvalidBlockType: 2,
          FSEAccuracyTooHigh: 3,
          DistanceTooFarBack: 4,
          UnexpectedEOF: 5
        };
        // error codes
        var ec = ['invalid zstd data', 'window size too large (>2046MB)', 'invalid block type', 'FSE accuracy too high', 'match distance too far back', 'unexpected EOF'];
        var err = function err(ind, msg, nt) {
          var e = new Error(msg || ec[ind]);
          e.code = ind;
          if (Error.captureStackTrace) Error.captureStackTrace(e, err);
          if (!nt) throw e;
          return e;
        };
        var rb = function rb(d, b, n) {
          var i = 0,
            o = 0;
          for (; i < n; ++i) {
            o |= d[b++] << (i << 3);
          }
          return o;
        };
        var b4 = function b4(d, b) {
          return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
        };
        // read Zstandard frame header
        var rzfh = function rzfh(dat, w) {
          var n3 = dat[0] | dat[1] << 8 | dat[2] << 16;
          if (n3 == 0x2FB528 && dat[3] == 253) {
            // Zstandard
            var flg = dat[4];
            //    single segment       checksum             dict flag     frame content flag
            var ss = flg >> 5 & 1,
              cc = flg >> 2 & 1,
              df = flg & 3,
              fcf = flg >> 6;
            if (flg & 8) err(0);
            // byte
            var bt = 6 - ss;
            // dict bytes
            var db = df == 3 ? 4 : df;
            // dictionary id
            var di = rb(dat, bt, db);
            bt += db;
            // frame size bytes
            var fsb = fcf ? 1 << fcf : ss;
            // frame source size
            var fss = rb(dat, bt, fsb) + (fcf == 1 && 256);
            // window size
            var ws = fss;
            if (!ss) {
              // window descriptor
              var wb = 1 << 10 + (dat[5] >> 3);
              ws = wb + (wb >> 3) * (dat[5] & 7);
            }
            if (ws > 2145386496) err(1);
            var buf = new u8((w == 1 ? fss || ws : w ? 0 : ws) + 12);
            buf[0] = 1, buf[4] = 4, buf[8] = 8;
            return {
              b: bt + fsb,
              y: 0,
              l: 0,
              d: di,
              w: w && w != 1 ? w : buf.subarray(12),
              e: ws,
              o: new i32(buf.buffer, 0, 3),
              u: fss,
              c: cc,
              m: Math.min(131072, ws)
            };
          } else if ((n3 >> 4 | dat[3] << 20) == 0x184D2A5) {
            // skippable
            return b4(dat, 4) + 8;
          }
          err(0);
        };
        // most significant bit for nonzero
        var msb = function msb(val) {
          var bits = 0;
          for (; 1 << bits <= val; ++bits) {
            ;
          }
          return bits - 1;
        };
        // read finite state entropy
        var rfse = function rfse(dat, bt, mal) {
          // table pos
          var tpos = (bt << 3) + 4;
          // accuracy log
          var al = (dat[bt] & 15) + 5;
          if (al > mal) err(3);
          // size
          var sz = 1 << al;
          // probabilities symbols  repeat   index   high threshold
          var probs = sz,
            sym = -1,
            re = -1,
            i = -1,
            ht = sz;
          // optimization: single allocation is much faster
          var buf = new ab(512 + (sz << 2));
          var freq = new i16(buf, 0, 256);
          // same view as freq
          var dstate = new u16(buf, 0, 256);
          var nstate = new u16(buf, 512, sz);
          var bb1 = 512 + (sz << 1);
          var syms = new u8(buf, bb1, sz);
          var nbits = new u8(buf, bb1 + sz);
          while (sym < 255 && probs > 0) {
            var bits = msb(probs + 1);
            var cbt = tpos >> 3;
            // mask
            var msk = (1 << bits + 1) - 1;
            var val = (dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (tpos & 7) & msk;
            // mask (1 fewer bit)
            var msk1fb = (1 << bits) - 1;
            // max small value
            var msv = msk - probs - 1;
            // small value
            var sval = val & msk1fb;
            if (sval < msv) tpos += bits, val = sval;else {
              tpos += bits + 1;
              if (val > msk1fb) val -= msv;
            }
            freq[++sym] = --val;
            if (val == -1) {
              probs += val;
              syms[--ht] = sym;
            } else probs -= val;
            if (!val) {
              do {
                // repeat byte
                var rbt = tpos >> 3;
                re = (dat[rbt] | dat[rbt + 1] << 8) >> (tpos & 7) & 3;
                tpos += 2;
                sym += re;
              } while (re == 3);
            }
          }
          if (sym > 255 || probs) err(0);
          var sympos = 0;
          // sym step (coprime with sz - formula from zstd source)
          var sstep = (sz >> 1) + (sz >> 3) + 3;
          // sym mask
          var smask = sz - 1;
          for (var s = 0; s <= sym; ++s) {
            var sf = freq[s];
            if (sf < 1) {
              dstate[s] = -sf;
              continue;
            }
            // This is split into two loops in zstd to avoid branching, but as JS is higher-level that is unnecessary
            for (i = 0; i < sf; ++i) {
              syms[sympos] = s;
              do {
                sympos = sympos + sstep & smask;
              } while (sympos >= ht);
            }
          }
          // After spreading symbols, should be zero again
          if (sympos) err(0);
          for (i = 0; i < sz; ++i) {
            // next state
            var ns = dstate[syms[i]]++;
            // num bits
            var nb = nbits[i] = al - msb(ns);
            nstate[i] = (ns << nb) - sz;
          }
          return [tpos + 7 >> 3, {
            b: al,
            s: syms,
            n: nbits,
            t: nstate
          }];
        };
        // read huffman
        var rhu = function rhu(dat, bt) {
          //  index  weight count
          var i = 0,
            wc = -1;
          //    buffer             header byte
          var buf = new u8(292),
            hb = dat[bt];
          // huffman weights
          var hw = buf.subarray(0, 256);
          // rank count
          var rc = buf.subarray(256, 268);
          // rank index
          var ri = new u16(buf.buffer, 268);
          // NOTE: at this point bt is 1 less than expected
          if (hb < 128) {
            // end byte, fse decode table
            var _a = rfse(dat, bt + 1, 6),
              ebt = _a[0],
              fdt = _a[1];
            bt += hb;
            var epos = ebt << 3;
            // last byte
            var lb = dat[bt];
            if (!lb) err(0);
            //  state1   state2   state1 bits   state2 bits
            var st1 = 0,
              st2 = 0,
              btr1 = fdt.b,
              btr2 = btr1;
            // fse pos
            // pre-increment to account for original deficit of 1
            var fpos = (++bt << 3) - 8 + msb(lb);
            for (;;) {
              fpos -= btr1;
              if (fpos < epos) break;
              var cbt = fpos >> 3;
              st1 += (dat[cbt] | dat[cbt + 1] << 8) >> (fpos & 7) & (1 << btr1) - 1;
              hw[++wc] = fdt.s[st1];
              fpos -= btr2;
              if (fpos < epos) break;
              cbt = fpos >> 3;
              st2 += (dat[cbt] | dat[cbt + 1] << 8) >> (fpos & 7) & (1 << btr2) - 1;
              hw[++wc] = fdt.s[st2];
              btr1 = fdt.n[st1];
              st1 = fdt.t[st1];
              btr2 = fdt.n[st2];
              st2 = fdt.t[st2];
            }
            if (++wc > 255) err(0);
          } else {
            wc = hb - 127;
            for (; i < wc; i += 2) {
              var byte = dat[++bt];
              hw[i] = byte >> 4;
              hw[i + 1] = byte & 15;
            }
            ++bt;
          }
          // weight exponential sum
          var wes = 0;
          for (i = 0; i < wc; ++i) {
            var wt = hw[i];
            // bits must be at most 11, same as weight
            if (wt > 11) err(0);
            wes += wt && 1 << wt - 1;
          }
          // max bits
          var mb = msb(wes) + 1;
          // table size
          var ts = 1 << mb;
          // remaining sum
          var rem = ts - wes;
          // must be power of 2
          if (rem & rem - 1) err(0);
          hw[wc++] = msb(rem) + 1;
          for (i = 0; i < wc; ++i) {
            var wt = hw[i];
            ++rc[hw[i] = wt && mb + 1 - wt];
          }
          // huf buf
          var hbuf = new u8(ts << 1);
          //    symbols                      num bits
          var syms = hbuf.subarray(0, ts),
            nb = hbuf.subarray(ts);
          ri[mb] = 0;
          for (i = mb; i > 0; --i) {
            var pv = ri[i];
            fill(nb, i, pv, ri[i - 1] = pv + rc[i] * (1 << mb - i));
          }
          if (ri[0] != ts) err(0);
          for (i = 0; i < wc; ++i) {
            var bits = hw[i];
            if (bits) {
              var code = ri[bits];
              fill(syms, i, code, ri[bits] = code + (1 << mb - bits));
            }
          }
          return [bt, {
            n: nb,
            b: mb,
            s: syms
          }];
        };
        // Tables generated using this:
        // https://gist.github.com/101arrowz/a979452d4355992cbf8f257cbffc9edd
        // default literal length table
        var dllt = rfse( /*#__PURE__*/new u8([81, 16, 99, 140, 49, 198, 24, 99, 12, 33, 196, 24, 99, 102, 102, 134, 70, 146, 4]), 0, 6)[1];
        // default match length table
        var dmlt = rfse( /*#__PURE__*/new u8([33, 20, 196, 24, 99, 140, 33, 132, 16, 66, 8, 33, 132, 16, 66, 8, 33, 68, 68, 68, 68, 68, 68, 68, 68, 36, 9]), 0, 6)[1];
        // default offset code table
        var doct = rfse( /*#__PURE__*/new u8([32, 132, 16, 66, 102, 70, 68, 68, 68, 68, 36, 73, 2]), 0, 5)[1];
        // bits to baseline
        var b2bl = function b2bl(b, s) {
          var len = b.length,
            bl = new i32(len);
          for (var i = 0; i < len; ++i) {
            bl[i] = s;
            s += 1 << b[i];
          }
          return bl;
        };
        // literal length bits
        var llb = /*#__PURE__ */new u8( /*#__PURE__ */new i32([0, 0, 0, 0, 16843009, 50528770, 134678020, 202050057, 269422093]).buffer, 0, 36);
        // literal length baseline
        var llbl = /*#__PURE__ */b2bl(llb, 0);
        // match length bits
        var mlb = /*#__PURE__ */new u8( /*#__PURE__ */new i32([0, 0, 0, 0, 0, 0, 0, 0, 16843009, 50528770, 117769220, 185207048, 252579084, 16]).buffer, 0, 53);
        // match length baseline
        var mlbl = /*#__PURE__ */b2bl(mlb, 3);
        // decode huffman stream
        var dhu = function dhu(dat, out, hu) {
          var len = dat.length,
            ss = out.length,
            lb = dat[len - 1],
            msk = (1 << hu.b) - 1,
            eb = -hu.b;
          if (!lb) err(0);
          var st = 0,
            btr = hu.b,
            pos = (len << 3) - 8 + msb(lb) - btr,
            i = -1;
          for (; pos > eb && i < ss;) {
            var cbt = pos >> 3;
            var val = (dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (pos & 7);
            st = (st << btr | val) & msk;
            out[++i] = hu.s[st];
            pos -= btr = hu.n[st];
          }
          if (pos != eb || i + 1 != ss) err(0);
        };
        // decode huffman stream 4x
        // TODO: use workers to parallelize
        var dhu4 = function dhu4(dat, out, hu) {
          var bt = 6;
          var ss = out.length,
            sz1 = ss + 3 >> 2,
            sz2 = sz1 << 1,
            sz3 = sz1 + sz2;
          dhu(dat.subarray(bt, bt += dat[0] | dat[1] << 8), out.subarray(0, sz1), hu);
          dhu(dat.subarray(bt, bt += dat[2] | dat[3] << 8), out.subarray(sz1, sz2), hu);
          dhu(dat.subarray(bt, bt += dat[4] | dat[5] << 8), out.subarray(sz2, sz3), hu);
          dhu(dat.subarray(bt), out.subarray(sz3), hu);
        };
        // read Zstandard block
        var rzb = function rzb(dat, st, out) {
          var _a;
          var bt = st.b;
          //    byte 0        block type
          var b0 = dat[bt],
            btype = b0 >> 1 & 3;
          st.l = b0 & 1;
          var sz = b0 >> 3 | dat[bt + 1] << 5 | dat[bt + 2] << 13;
          // end byte for block
          var ebt = (bt += 3) + sz;
          if (btype == 1) {
            if (bt >= dat.length) return;
            st.b = bt + 1;
            if (out) {
              fill(out, dat[bt], st.y, st.y += sz);
              return out;
            }
            return fill(new u8(sz), dat[bt]);
          }
          if (ebt > dat.length) return;
          if (btype == 0) {
            st.b = ebt;
            if (out) {
              out.set(dat.subarray(bt, ebt), st.y);
              st.y += sz;
              return out;
            }
            return slc(dat, bt, ebt);
          }
          if (btype == 2) {
            //    byte 3        lit btype     size format
            var b3 = dat[bt],
              lbt = b3 & 3,
              sf = b3 >> 2 & 3;
            // lit src size  lit cmp sz 4 streams
            var lss = b3 >> 4,
              lcs = 0,
              s4 = 0;
            if (lbt < 2) {
              if (sf & 1) lss |= dat[++bt] << 4 | (sf & 2 && dat[++bt] << 12);else lss = b3 >> 3;
            } else {
              s4 = sf;
              if (sf < 2) lss |= (dat[++bt] & 63) << 4, lcs = dat[bt] >> 6 | dat[++bt] << 2;else if (sf == 2) lss |= dat[++bt] << 4 | (dat[++bt] & 3) << 12, lcs = dat[bt] >> 2 | dat[++bt] << 6;else lss |= dat[++bt] << 4 | (dat[++bt] & 63) << 12, lcs = dat[bt] >> 6 | dat[++bt] << 2 | dat[++bt] << 10;
            }
            ++bt;
            // add literals to end - can never overlap with backreferences because unused literals always appended
            var buf = out ? out.subarray(st.y, st.y + st.m) : new u8(st.m);
            // starting point for literals
            var spl = buf.length - lss;
            if (lbt == 0) buf.set(dat.subarray(bt, bt += lss), spl);else if (lbt == 1) fill(buf, dat[bt++], spl);else {
              // huffman table
              var hu = st.h;
              if (lbt == 2) {
                var hud = rhu(dat, bt);
                // subtract description length
                lcs += bt - (bt = hud[0]);
                st.h = hu = hud[1];
              } else if (!hu) err(0);
              (s4 ? dhu4 : dhu)(dat.subarray(bt, bt += lcs), buf.subarray(spl), hu);
            }
            // num sequences
            var ns = dat[bt++];
            if (ns) {
              if (ns == 255) ns = (dat[bt++] | dat[bt++] << 8) + 0x7F00;else if (ns > 127) ns = ns - 128 << 8 | dat[bt++];
              // symbol compression modes
              var scm = dat[bt++];
              if (scm & 3) err(0);
              var dts = [dmlt, doct, dllt];
              for (var i = 2; i > -1; --i) {
                var md = scm >> (i << 1) + 2 & 3;
                if (md == 1) {
                  // rle buf
                  var rbuf = new u8([0, 0, dat[bt++]]);
                  dts[i] = {
                    s: rbuf.subarray(2, 3),
                    n: rbuf.subarray(0, 1),
                    t: new u16(rbuf.buffer, 0, 1),
                    b: 0
                  };
                } else if (md == 2) {
                  // accuracy log 8 for offsets, 9 for others
                  _a = rfse(dat, bt, 9 - (i & 1)), bt = _a[0], dts[i] = _a[1];
                } else if (md == 3) {
                  if (!st.t) err(0);
                  dts[i] = st.t[i];
                }
              }
              var _b = st.t = dts,
                mlt = _b[0],
                oct = _b[1],
                llt = _b[2];
              var lb = dat[ebt - 1];
              if (!lb) err(0);
              var spos = (ebt << 3) - 8 + msb(lb) - llt.b,
                cbt = spos >> 3,
                oubt = 0;
              var lst = (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << llt.b) - 1;
              cbt = (spos -= oct.b) >> 3;
              var ost = (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << oct.b) - 1;
              cbt = (spos -= mlt.b) >> 3;
              var mst = (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << mlt.b) - 1;
              for (++ns; --ns;) {
                var llc = llt.s[lst];
                var lbtr = llt.n[lst];
                var mlc = mlt.s[mst];
                var mbtr = mlt.n[mst];
                var ofc = oct.s[ost];
                var obtr = oct.n[ost];
                cbt = (spos -= ofc) >> 3;
                var ofp = 1 << ofc;
                var off = ofp + ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16 | dat[cbt + 3] << 24) >>> (spos & 7) & ofp - 1);
                cbt = (spos -= mlb[mlc]) >> 3;
                var ml = mlbl[mlc] + ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (spos & 7) & (1 << mlb[mlc]) - 1);
                cbt = (spos -= llb[llc]) >> 3;
                var ll = llbl[llc] + ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (spos & 7) & (1 << llb[llc]) - 1);
                cbt = (spos -= lbtr) >> 3;
                lst = llt.t[lst] + ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << lbtr) - 1);
                cbt = (spos -= mbtr) >> 3;
                mst = mlt.t[mst] + ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << mbtr) - 1);
                cbt = (spos -= obtr) >> 3;
                ost = oct.t[ost] + ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << obtr) - 1);
                if (off > 3) {
                  st.o[2] = st.o[1];
                  st.o[1] = st.o[0];
                  st.o[0] = off -= 3;
                } else {
                  var idx = off - (ll != 0);
                  if (idx) {
                    off = idx == 3 ? st.o[0] - 1 : st.o[idx];
                    if (idx > 1) st.o[2] = st.o[1];
                    st.o[1] = st.o[0];
                    st.o[0] = off;
                  } else off = st.o[0];
                }
                for (var i = 0; i < ll; ++i) {
                  buf[oubt + i] = buf[spl + i];
                }
                oubt += ll, spl += ll;
                var stin = oubt - off;
                if (stin < 0) {
                  var len = -stin;
                  var bs = st.e + stin;
                  if (len > ml) len = ml;
                  for (var i = 0; i < len; ++i) {
                    buf[oubt + i] = st.w[bs + i];
                  }
                  oubt += len, ml -= len, stin = 0;
                }
                for (var i = 0; i < ml; ++i) {
                  buf[oubt + i] = buf[stin + i];
                }
                oubt += ml;
              }
              if (oubt != spl) {
                while (spl < buf.length) {
                  buf[oubt++] = buf[spl++];
                }
              } else oubt = buf.length;
              if (out) st.y += oubt;else buf = slc(buf, 0, oubt);
            } else {
              if (out) {
                st.y += lss;
                if (spl) {
                  for (var i = 0; i < lss; ++i) {
                    buf[i] = buf[spl + i];
                  }
                }
              } else if (spl) buf = slc(buf, spl);
            }
            st.b = ebt;
            return buf;
          }
          err(2);
        };
        // concat
        var cct = function cct(bufs, ol) {
          if (bufs.length == 1) return bufs[0];
          var buf = new u8(ol);
          for (var i = 0, b = 0; i < bufs.length; ++i) {
            var chk = bufs[i];
            buf.set(chk, b);
            b += chk.length;
          }
          return buf;
        };
        /**
         * Decompresses Zstandard data
         * @param dat The input data
         * @param buf The output buffer. If unspecified, the function will allocate
         *            exactly enough memory to fit the decompressed data. If your
         *            data has multiple frames and you know the output size, specifying
         *            it will yield better performance.
         * @returns The decompressed data
         */
        function decompress(dat, buf) {
          var bt = 0,
            bufs = [],
            nb = +!buf,
            ol = 0;
          for (; dat.length;) {
            var st = rzfh(dat, nb || buf);
            if (_typeof(st) == 'object') {
              if (nb) {
                buf = null;
                if (st.w.length == st.u) {
                  bufs.push(buf = st.w);
                  ol += st.u;
                }
              } else {
                bufs.push(buf);
                st.e = 0;
              }
              for (; !st.l;) {
                var blk = rzb(dat, st, buf);
                if (!blk) err(5);
                if (buf) st.e = st.y;else {
                  bufs.push(blk);
                  ol += blk.length;
                  cpw(st.w, 0, blk.length);
                  st.w.set(blk, st.w.length - blk.length);
                }
              }
              bt = st.b + st.c * 4;
            } else bt = st;
            dat = dat.subarray(bt);
          }
          return cct(bufs, ol);
        }
        /**
         * Decompressor for Zstandard streamed data
         */
        var Decompress = /*#__PURE__*/function () {
          /**
           * Creates a Zstandard decompressor
           * @param ondata The handler for stream data
           */
          function Decompress(ondata) {
            this.ondata = ondata;
            this.c = [];
            this.l = 0;
            this.z = 0;
          }
          /**
           * Pushes data to be decompressed
           * @param chunk The chunk of data to push
           * @param final Whether or not this is the last chunk in the stream
           */
          Decompress.prototype.push = function (chunk, final) {
            if (typeof this.s == 'number') {
              var sub = Math.min(chunk.length, this.s);
              chunk = chunk.subarray(sub);
              this.s -= sub;
            }
            var sl = chunk.length;
            var ncs = sl + this.l;
            if (!this.s) {
              if (final) {
                if (!ncs) return;
                // min for frame + one block
                if (ncs < 5) err(5);
              } else if (ncs < 18) {
                this.c.push(chunk);
                this.l = ncs;
                return;
              }
              if (this.l) {
                this.c.push(chunk);
                chunk = cct(this.c, ncs);
                this.c = [];
                this.l = 0;
              }
              if (typeof (this.s = rzfh(chunk)) == 'number') return this.push(chunk, final);
            }
            if (typeof this.s != 'number') {
              if (ncs < (this.z || 4)) {
                if (final) err(5);
                this.c.push(chunk);
                this.l = ncs;
                return;
              }
              if (this.l) {
                this.c.push(chunk);
                chunk = cct(this.c, ncs);
                this.c = [];
                this.l = 0;
              }
              if (!this.z && ncs < (this.z = chunk[this.s.b] & 2 ? 5 : 4 + (chunk[this.s.b] >> 3 | chunk[this.s.b + 1] << 5 | chunk[this.s.b + 2] << 13))) {
                if (final) err(5);
                this.c.push(chunk);
                this.l = ncs;
                return;
              } else this.z = 0;
              for (;;) {
                var blk = rzb(chunk, this.s);
                if (!blk) {
                  if (final) err(5);
                  var adc = chunk.subarray(this.s.b);
                  this.s.b = 0;
                  this.c.push(adc), this.l += adc.length;
                  return;
                } else {
                  this.ondata(blk, false);
                  cpw(this.s.w, 0, blk.length);
                  this.s.w.set(blk, this.s.w.length - blk.length);
                }
                if (this.s.l) {
                  var rest = chunk.subarray(this.s.b);
                  this.s = this.s.c * 4;
                  this.push(rest, final);
                  return;
                }
              }
            }
          };
          return Decompress;
        }();
        var fzstd = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          ZstdErrorCode: ZstdErrorCode,
          decompress: decompress,
          Decompress: Decompress
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        var getLiquidDSP = function getLiquidDSP(LiquidDSP) {
          var DSP = {};
          DSP.LiquidDSP = LiquidDSP;
          DSP.estimate_req_filter_len = LiquidDSP.cwrap('estimate_req_filter_len', 'number', ['number', 'number']);
          DSP.liquid_firdes_kaiser = LiquidDSP.cwrap('liquid_firdes_kaiser', 'number', ['number', 'number', 'number', 'number', 'number']);
          DSP.firfilt_rrrf_create = LiquidDSP.cwrap('firfilt_rrrf_create', 'number', ['number', 'number']);
          DSP.firfilt_rrrf_execute_block = LiquidDSP.cwrap('firfilt_rrrf_execute_block', 'number', ['number', 'number', 'number', 'number']);
          DSP.firfilt_rrrf_destroy = LiquidDSP.cwrap('firfilt_rrrf_destroy', 'number', ['number']);
          DSP.resamp_rrrf_create = LiquidDSP.cwrap('resamp_rrrf_create', 'number', ['number', 'number', 'number', 'number', 'number']);
          DSP.getFloat32Array = function (offset, length) {
            return new Float32Array(new Float32Array(LiquidDSP.HEAPU8.buffer, offset, length));
          };
          DSP.FirDesKaiser = function (ft, fc, As, mu) {
            var hLen = DSP.estimate_req_filter_len(ft, As);
            var h = LiquidDSP._malloc(4 * hLen);
            DSP.liquid_firdes_kaiser(hLen, fc, As, mu, h);
            var arr = DSP.getFloat32Array(h, hLen);
            LiquidDSP._free(h);
            return arr;
          };
          DSP.FirFilt = function (h) {
            var _this7 = this;
            this.h = LiquidDSP._malloc(h.length * 4);
            new Float32Array(LiquidDSP.HEAPU8.buffer, h, h.length).set(h);
            this.q = DSP.firfilt_rrrf_create(this.h, h.length);
            this.in = LiquidDSP._malloc(4 * 16384);
            this.inarr = new Float32Array(LiquidDSP.HEAPU8.buffer, this.in, 16384);
            this.execute = function (arr) {
              _this7.inarr.set(arr);
              DSP.firfilt_rrrf_execute_block(_this7.q, _this7.in, arr.length, _this7.in);
              arr = DSP.getFloat32Array(_this7.in, arr.length);
              return arr;
            };
            this.destroy = function () {
              LiquidDSP._free(_this7.h);
              LiquidDSP._free(_this7.in);
              DSP.firfilt_rrrf_destroy(_this7.q);
            };
          };
          DSP.Resamp = function (r, m, fc, As, N) {
            var _this8 = this;
            this.q = LiquidDSP._resamp_rrrf_create(r, m, fc, As, N);
            this.in = LiquidDSP._malloc(4 * 16384);
            this.out = LiquidDSP._malloc(4 * 16384);
            this.inarr = new Float32Array(LiquidDSP.HEAPU8.buffer, this.in, 16384);
            this.outarr = new Float32Array(LiquidDSP.HEAPU8.buffer, this.out, 16384);
            this.outlen = LiquidDSP._malloc(4);
            this.execute = function (arr) {
              _this8.inarr.set(arr);
              LiquidDSP._resamp_rrrf_execute_block(_this8.q, _this8.in, arr.length, _this8.out, _this8.outlen);
              arr = DSP.getFloat32Array(_this8.out, LiquidDSP.getValue(_this8.outlen, 'i32'));
              return arr;
            };
            this.destroy = function () {
              LiquidDSP._free(_this8.in);
              LiquidDSP._free(_this8.out);
              LiquidDSP._resamp_rrrf_destroy(_this8.q);
            };
          };
          DSP.MsResamp = function (r, As) {
            var _this9 = this;
            this.q = LiquidDSP._msresamp_rrrf_create(r, As);
            this.in = LiquidDSP._malloc(4 * 16384);
            this.out = LiquidDSP._malloc(4 * 16384);
            this.inarr = new Float32Array(LiquidDSP.HEAPU8.buffer, this.in, 16384);
            this.outarr = new Float32Array(LiquidDSP.HEAPU8.buffer, this.out, 16384);
            this.outlen = LiquidDSP._malloc(4);
            this.execute = function (arr) {
              _this9.inarr.set(arr);
              LiquidDSP._msresamp_rrrf_execute(_this9.q, _this9.in, arr.length, _this9.out, _this9.outlen);
              arr = DSP.getFloat32Array(_this9.out, LiquidDSP.getValue(_this9.outlen, 'i32'));
              return arr;
            };
            this.destroy = function () {
              LiquidDSP._free(_this9.in);
              LiquidDSP._free(_this9.out);
              LiquidDSP._msresamp_rrrf_destroy(_this9.q);
            };
          };
          DSP.AGC = function () {
            var _this10 = this;
            this.q = LiquidDSP._agc_rrrf_create();
            this.in = LiquidDSP._malloc(4 * 16384);
            this.inarr = new Float32Array(LiquidDSP.HEAPU8.buffer, this.in, 16384);
            this.execute = function (arr) {
              _this10.inarr.set(arr);
              LiquidDSP._agc_rrrf_execute_block(_this10.q, _this10.in, arr.length, _this10.in);
              arr = DSP.getFloat32Array(_this10.in, arr.length);
              return arr;
            };
            this.destroy = function () {
              LiquidDSP._free(_this10.in);
              LiquidDSP._agc_rrrf_destroy(_this10.q);
            };
          };
          DSP.WBFMStereo = function (fs) {
            var _this11 = this;
            this.wbfm = new LiquidDSP.WBFMStereo(fs);
            this.in = LiquidDSP._malloc(4 * 16384);
            this.outl = LiquidDSP._malloc(4 * 16384);
            this.outr = LiquidDSP._malloc(4 * 16384);
            this.inarr = new Float32Array(LiquidDSP.HEAPU8.buffer, this.in, 16384);
            this.outlarr = new Float32Array(LiquidDSP.HEAPU8.buffer, this.outl, 16384);
            this.outrarr = new Float32Array(LiquidDSP.HEAPU8.buffer, this.outr, 16384);
            this.execute = function (arr) {
              _this11.inarr.set(arr);
              _this11.wbfm.execute(_this11.in, arr.length, _this11.outl, _this11.outr);
              return [DSP.getFloat32Array(_this11.outl, arr.length), DSP.getFloat32Array(_this11.outr, arr.length)];
            };
            this.destroy = function () {
              _this11.wbfm.destroy();
            };
          };
          return DSP;
        };
        var jsDSPModule = function () {
          var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
          return function (jsDSPModule) {
            jsDSPModule = jsDSPModule || {};
            var Module = typeof jsDSPModule !== "undefined" ? jsDSPModule : {};
            var readyPromiseResolve, readyPromiseReject;
            Module["ready"] = new Promise(function (resolve, reject) {
              readyPromiseResolve = resolve;
              readyPromiseReject = reject;
            });
            var moduleOverrides = {};
            var key;
            for (key in Module) {
              if (Module.hasOwnProperty(key)) {
                moduleOverrides[key] = Module[key];
              }
            }
            var ENVIRONMENT_IS_WEB = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object";
            var ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
            (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && _typeof(process.versions) === "object" && typeof process.versions.node === "string";
            var scriptDirectory = "";
            function locateFile(path) {
              if (Module["locateFile"]) {
                return Module["locateFile"](path, scriptDirectory);
              }
              return scriptDirectory + path;
            }
            var readBinary;
            if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
              if (ENVIRONMENT_IS_WORKER) {
                scriptDirectory = self.location.href;
              } else if (typeof document !== "undefined" && document.currentScript) {
                scriptDirectory = document.currentScript.src;
              }
              if (_scriptDir) {
                scriptDirectory = _scriptDir;
              }
              if (scriptDirectory.indexOf("blob:") !== 0) {
                scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
              } else {
                scriptDirectory = "";
              }
              {
                if (ENVIRONMENT_IS_WORKER) {
                  readBinary = function readBinary(url) {
                    var xhr = new XMLHttpRequest();
                    xhr.open("GET", url, false);
                    xhr.responseType = "arraybuffer";
                    xhr.send(null);
                    return new Uint8Array(xhr.response);
                  };
                }
              }
            }
            var out = Module["print"] || console.log.bind(console);
            var err = Module["printErr"] || console.warn.bind(console);
            for (key in moduleOverrides) {
              if (moduleOverrides.hasOwnProperty(key)) {
                Module[key] = moduleOverrides[key];
              }
            }
            moduleOverrides = null;
            if (Module["arguments"]) Module["arguments"];
            if (Module["thisProgram"]) Module["thisProgram"];
            if (Module["quit"]) Module["quit"];
            var wasmBinary;
            if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
            Module["noExitRuntime"] || true;
            if ((typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) !== "object") {
              abort("no native wasm support detected");
            }
            function setValue(ptr, value, type, noSafe) {
              type = type || "i8";
              if (type.charAt(type.length - 1) === "*") type = "i32";
              switch (type) {
                case "i1":
                  HEAP8[ptr >> 0] = value;
                  break;
                case "i8":
                  HEAP8[ptr >> 0] = value;
                  break;
                case "i16":
                  HEAP16[ptr >> 1] = value;
                  break;
                case "i32":
                  HEAP32[ptr >> 2] = value;
                  break;
                case "i64":
                  tempI64 = [value >>> 0, (tempDouble = value, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
                  break;
                case "float":
                  HEAPF32[ptr >> 2] = value;
                  break;
                case "double":
                  HEAPF64[ptr >> 3] = value;
                  break;
                default:
                  abort("invalid type for setValue: " + type);
              }
            }
            function getValue(ptr, type, noSafe) {
              type = type || "i8";
              if (type.charAt(type.length - 1) === "*") type = "i32";
              switch (type) {
                case "i1":
                  return HEAP8[ptr >> 0];
                case "i8":
                  return HEAP8[ptr >> 0];
                case "i16":
                  return HEAP16[ptr >> 1];
                case "i32":
                  return HEAP32[ptr >> 2];
                case "i64":
                  return HEAP32[ptr >> 2];
                case "float":
                  return HEAPF32[ptr >> 2];
                case "double":
                  return Number(HEAPF64[ptr >> 3]);
                default:
                  abort("invalid type for getValue: " + type);
              }
              return null;
            }
            var wasmMemory;
            var ABORT = false;
            function assert(condition, text) {
              if (!condition) {
                abort("Assertion failed: " + text);
              }
            }
            function getCFunc(ident) {
              var func = Module["_" + ident];
              assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
              return func;
            }
            function ccall(ident, returnType, argTypes, args, opts) {
              var toC = {
                "string": function string(str) {
                  var ret = 0;
                  if (str !== null && str !== undefined && str !== 0) {
                    var len = (str.length << 2) + 1;
                    ret = stackAlloc(len);
                    stringToUTF8(str, ret, len);
                  }
                  return ret;
                },
                "array": function array(arr) {
                  var ret = stackAlloc(arr.length);
                  writeArrayToMemory(arr, ret);
                  return ret;
                }
              };
              function convertReturnValue(ret) {
                if (returnType === "string") return UTF8ToString(ret);
                if (returnType === "boolean") return Boolean(ret);
                return ret;
              }
              var func = getCFunc(ident);
              var cArgs = [];
              var stack = 0;
              if (args) {
                for (var i = 0; i < args.length; i++) {
                  var converter = toC[argTypes[i]];
                  if (converter) {
                    if (stack === 0) stack = stackSave();
                    cArgs[i] = converter(args[i]);
                  } else {
                    cArgs[i] = args[i];
                  }
                }
              }
              var ret = func.apply(null, cArgs);
              function onDone(ret) {
                if (stack !== 0) stackRestore(stack);
                return convertReturnValue(ret);
              }
              ret = onDone(ret);
              return ret;
            }
            function cwrap(ident, returnType, argTypes, opts) {
              argTypes = argTypes || [];
              var numericArgs = argTypes.every(function (type) {
                return type === "number";
              });
              var numericRet = returnType !== "string";
              if (numericRet && numericArgs && !opts) {
                return getCFunc(ident);
              }
              return function () {
                return ccall(ident, returnType, argTypes, arguments);
              };
            }
            var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;
            function UTF8ArrayToString(heap, idx, maxBytesToRead) {
              var endIdx = idx + maxBytesToRead;
              var endPtr = idx;
              while (heap[endPtr] && !(endPtr >= endIdx)) {
                ++endPtr;
              }
              if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
                return UTF8Decoder.decode(heap.subarray(idx, endPtr));
              } else {
                var str = "";
                while (idx < endPtr) {
                  var u0 = heap[idx++];
                  if (!(u0 & 128)) {
                    str += String.fromCharCode(u0);
                    continue;
                  }
                  var u1 = heap[idx++] & 63;
                  if ((u0 & 224) == 192) {
                    str += String.fromCharCode((u0 & 31) << 6 | u1);
                    continue;
                  }
                  var u2 = heap[idx++] & 63;
                  if ((u0 & 240) == 224) {
                    u0 = (u0 & 15) << 12 | u1 << 6 | u2;
                  } else {
                    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
                  }
                  if (u0 < 65536) {
                    str += String.fromCharCode(u0);
                  } else {
                    var ch = u0 - 65536;
                    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
                  }
                }
              }
              return str;
            }
            function UTF8ToString(ptr, maxBytesToRead) {
              return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
            }
            function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
              if (!(maxBytesToWrite > 0)) return 0;
              var startIdx = outIdx;
              var endIdx = outIdx + maxBytesToWrite - 1;
              for (var i = 0; i < str.length; ++i) {
                var u = str.charCodeAt(i);
                if (u >= 55296 && u <= 57343) {
                  var u1 = str.charCodeAt(++i);
                  u = 65536 + ((u & 1023) << 10) | u1 & 1023;
                }
                if (u <= 127) {
                  if (outIdx >= endIdx) break;
                  heap[outIdx++] = u;
                } else if (u <= 2047) {
                  if (outIdx + 1 >= endIdx) break;
                  heap[outIdx++] = 192 | u >> 6;
                  heap[outIdx++] = 128 | u & 63;
                } else if (u <= 65535) {
                  if (outIdx + 2 >= endIdx) break;
                  heap[outIdx++] = 224 | u >> 12;
                  heap[outIdx++] = 128 | u >> 6 & 63;
                  heap[outIdx++] = 128 | u & 63;
                } else {
                  if (outIdx + 3 >= endIdx) break;
                  heap[outIdx++] = 240 | u >> 18;
                  heap[outIdx++] = 128 | u >> 12 & 63;
                  heap[outIdx++] = 128 | u >> 6 & 63;
                  heap[outIdx++] = 128 | u & 63;
                }
              }
              heap[outIdx] = 0;
              return outIdx - startIdx;
            }
            function stringToUTF8(str, outPtr, maxBytesToWrite) {
              return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
            }
            function lengthBytesUTF8(str) {
              var len = 0;
              for (var i = 0; i < str.length; ++i) {
                var u = str.charCodeAt(i);
                if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
                if (u <= 127) ++len;else if (u <= 2047) len += 2;else if (u <= 65535) len += 3;else len += 4;
              }
              return len;
            }
            var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : undefined;
            function UTF16ToString(ptr, maxBytesToRead) {
              var endPtr = ptr;
              var idx = endPtr >> 1;
              var maxIdx = idx + maxBytesToRead / 2;
              while (!(idx >= maxIdx) && HEAPU16[idx]) {
                ++idx;
              }
              endPtr = idx << 1;
              if (endPtr - ptr > 32 && UTF16Decoder) {
                return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
              } else {
                var str = "";
                for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
                  var codeUnit = HEAP16[ptr + i * 2 >> 1];
                  if (codeUnit == 0) break;
                  str += String.fromCharCode(codeUnit);
                }
                return str;
              }
            }
            function stringToUTF16(str, outPtr, maxBytesToWrite) {
              if (maxBytesToWrite === undefined) {
                maxBytesToWrite = 2147483647;
              }
              if (maxBytesToWrite < 2) return 0;
              maxBytesToWrite -= 2;
              var startPtr = outPtr;
              var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
              for (var i = 0; i < numCharsToWrite; ++i) {
                var codeUnit = str.charCodeAt(i);
                HEAP16[outPtr >> 1] = codeUnit;
                outPtr += 2;
              }
              HEAP16[outPtr >> 1] = 0;
              return outPtr - startPtr;
            }
            function lengthBytesUTF16(str) {
              return str.length * 2;
            }
            function UTF32ToString(ptr, maxBytesToRead) {
              var i = 0;
              var str = "";
              while (!(i >= maxBytesToRead / 4)) {
                var utf32 = HEAP32[ptr + i * 4 >> 2];
                if (utf32 == 0) break;
                ++i;
                if (utf32 >= 65536) {
                  var ch = utf32 - 65536;
                  str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
                } else {
                  str += String.fromCharCode(utf32);
                }
              }
              return str;
            }
            function stringToUTF32(str, outPtr, maxBytesToWrite) {
              if (maxBytesToWrite === undefined) {
                maxBytesToWrite = 2147483647;
              }
              if (maxBytesToWrite < 4) return 0;
              var startPtr = outPtr;
              var endPtr = startPtr + maxBytesToWrite - 4;
              for (var i = 0; i < str.length; ++i) {
                var codeUnit = str.charCodeAt(i);
                if (codeUnit >= 55296 && codeUnit <= 57343) {
                  var trailSurrogate = str.charCodeAt(++i);
                  codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
                }
                HEAP32[outPtr >> 2] = codeUnit;
                outPtr += 4;
                if (outPtr + 4 > endPtr) break;
              }
              HEAP32[outPtr >> 2] = 0;
              return outPtr - startPtr;
            }
            function lengthBytesUTF32(str) {
              var len = 0;
              for (var i = 0; i < str.length; ++i) {
                var codeUnit = str.charCodeAt(i);
                if (codeUnit >= 55296 && codeUnit <= 57343) ++i;
                len += 4;
              }
              return len;
            }
            function writeArrayToMemory(array, buffer) {
              HEAP8.set(array, buffer);
            }
            var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
            function updateGlobalBufferAndViews(buf) {
              buffer = buf;
              Module["HEAP8"] = HEAP8 = new Int8Array(buf);
              Module["HEAP16"] = HEAP16 = new Int16Array(buf);
              Module["HEAP32"] = HEAP32 = new Int32Array(buf);
              Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
              Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
              Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
              Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
              Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
            }
            Module["INITIAL_MEMORY"] || 8388608;
            var wasmTable;
            var __ATPRERUN__ = [];
            var __ATINIT__ = [];
            var __ATPOSTRUN__ = [];
            function preRun() {
              if (Module["preRun"]) {
                if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]];
                while (Module["preRun"].length) {
                  addOnPreRun(Module["preRun"].shift());
                }
              }
              callRuntimeCallbacks(__ATPRERUN__);
            }
            function initRuntime() {
              callRuntimeCallbacks(__ATINIT__);
            }
            function postRun() {
              if (Module["postRun"]) {
                if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]];
                while (Module["postRun"].length) {
                  addOnPostRun(Module["postRun"].shift());
                }
              }
              callRuntimeCallbacks(__ATPOSTRUN__);
            }
            function addOnPreRun(cb) {
              __ATPRERUN__.unshift(cb);
            }
            function addOnInit(cb) {
              __ATINIT__.unshift(cb);
            }
            function addOnPostRun(cb) {
              __ATPOSTRUN__.unshift(cb);
            }
            var runDependencies = 0;
            var dependenciesFulfilled = null;
            function addRunDependency(id) {
              runDependencies++;
              if (Module["monitorRunDependencies"]) {
                Module["monitorRunDependencies"](runDependencies);
              }
            }
            function removeRunDependency(id) {
              runDependencies--;
              if (Module["monitorRunDependencies"]) {
                Module["monitorRunDependencies"](runDependencies);
              }
              if (runDependencies == 0) {
                if (dependenciesFulfilled) {
                  var callback = dependenciesFulfilled;
                  dependenciesFulfilled = null;
                  callback();
                }
              }
            }
            Module["preloadedImages"] = {};
            Module["preloadedAudios"] = {};
            function abort(what) {
              {
                if (Module["onAbort"]) {
                  Module["onAbort"](what);
                }
              }
              what = "Aborted(" + what + ")";
              err(what);
              ABORT = true;
              what += ". Build with -s ASSERTIONS=1 for more info.";
              var e = new WebAssembly.RuntimeError(what);
              readyPromiseReject(e);
              throw e;
            }
            var dataURIPrefix = "data:application/octet-stream;base64,";
            function isDataURI(filename) {
              return filename.startsWith(dataURIPrefix);
            }
            var wasmBinaryFile;
            wasmBinaryFile = "jsDSP.wasm";
            if (!isDataURI(wasmBinaryFile)) {
              wasmBinaryFile = locateFile(wasmBinaryFile);
            }
            function getBinary(file) {
              try {
                if (file == wasmBinaryFile && wasmBinary) {
                  return new Uint8Array(wasmBinary);
                }
                if (readBinary) {
                  return readBinary(file);
                } else {
                  throw "both async and sync fetching of the wasm failed";
                }
              } catch (err) {
                abort(err);
              }
            }
            function getBinaryPromise() {
              if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
                if (typeof fetch === "function") {
                  return fetch(wasmBinaryFile, {
                    credentials: "same-origin"
                  }).then(function (response) {
                    if (!response["ok"]) {
                      throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                    }
                    return response["arrayBuffer"]();
                  }).catch(function () {
                    return getBinary(wasmBinaryFile);
                  });
                }
              }
              return Promise.resolve().then(function () {
                return getBinary(wasmBinaryFile);
              });
            }
            function createWasm() {
              var info = {
                "a": asmLibraryArg
              };
              function receiveInstance(instance, module) {
                var exports = instance.exports;
                Module["asm"] = exports;
                wasmMemory = Module["asm"]["I"];
                updateGlobalBufferAndViews(wasmMemory.buffer);
                wasmTable = Module["asm"]["na"];
                addOnInit(Module["asm"]["J"]);
                removeRunDependency();
              }
              addRunDependency();
              function receiveInstantiationResult(result) {
                receiveInstance(result["instance"]);
              }
              function instantiateArrayBuffer(receiver) {
                return getBinaryPromise().then(function (binary) {
                  return WebAssembly.instantiate(binary, info);
                }).then(function (instance) {
                  return instance;
                }).then(receiver, function (reason) {
                  err("failed to asynchronously prepare wasm: " + reason);
                  abort(reason);
                });
              }
              function instantiateAsync() {
                if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && typeof fetch === "function") {
                  return fetch(wasmBinaryFile, {
                    credentials: "same-origin"
                  }).then(function (response) {
                    var result = WebAssembly.instantiateStreaming(response, info);
                    return result.then(receiveInstantiationResult, function (reason) {
                      err("wasm streaming compile failed: " + reason);
                      err("falling back to ArrayBuffer instantiation");
                      return instantiateArrayBuffer(receiveInstantiationResult);
                    });
                  });
                } else {
                  return instantiateArrayBuffer(receiveInstantiationResult);
                }
              }
              if (Module["instantiateWasm"]) {
                try {
                  var exports = Module["instantiateWasm"](info, receiveInstance);
                  return exports;
                } catch (e) {
                  err("Module.instantiateWasm callback failed with error: " + e);
                  return false;
                }
              }
              instantiateAsync().catch(readyPromiseReject);
              return {};
            }
            var tempDouble;
            var tempI64;
            function callRuntimeCallbacks(callbacks) {
              while (callbacks.length > 0) {
                var callback = callbacks.shift();
                if (typeof callback == "function") {
                  callback(Module);
                  continue;
                }
                var func = callback.func;
                if (typeof func === "number") {
                  if (callback.arg === undefined) {
                    getWasmTableEntry(func)();
                  } else {
                    getWasmTableEntry(func)(callback.arg);
                  }
                } else {
                  func(callback.arg === undefined ? null : callback.arg);
                }
              }
            }
            var wasmTableMirror = [];
            function getWasmTableEntry(funcPtr) {
              var func = wasmTableMirror[funcPtr];
              if (!func) {
                if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
                wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
              }
              return func;
            }
            function ___assert_fail(condition, filename, line, func) {
              abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
            }
            function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}
            function getShiftFromSize(size) {
              switch (size) {
                case 1:
                  return 0;
                case 2:
                  return 1;
                case 4:
                  return 2;
                case 8:
                  return 3;
                default:
                  throw new TypeError("Unknown type size: " + size);
              }
            }
            function embind_init_charCodes() {
              var codes = new Array(256);
              for (var i = 0; i < 256; ++i) {
                codes[i] = String.fromCharCode(i);
              }
              embind_charCodes = codes;
            }
            var embind_charCodes = undefined;
            function readLatin1String(ptr) {
              var ret = "";
              var c = ptr;
              while (HEAPU8[c]) {
                ret += embind_charCodes[HEAPU8[c++]];
              }
              return ret;
            }
            var awaitingDependencies = {};
            var registeredTypes = {};
            var typeDependencies = {};
            var char_0 = 48;
            var char_9 = 57;
            function makeLegalFunctionName(name) {
              if (undefined === name) {
                return "_unknown";
              }
              name = name.replace(/[^a-zA-Z0-9_]/g, "$");
              var f = name.charCodeAt(0);
              if (f >= char_0 && f <= char_9) {
                return "_" + name;
              } else {
                return name;
              }
            }
            function createNamedFunction(name, body) {
              name = makeLegalFunctionName(name);
              return new Function("body", "return function " + name + "() {\n" + '    "use strict";' + "    return body.apply(this, arguments);\n" + "};\n")(body);
            }
            function extendError(baseErrorType, errorName) {
              var errorClass = createNamedFunction(errorName, function (message) {
                this.name = errorName;
                this.message = message;
                var stack = new Error(message).stack;
                if (stack !== undefined) {
                  this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
                }
              });
              errorClass.prototype = Object.create(baseErrorType.prototype);
              errorClass.prototype.constructor = errorClass;
              errorClass.prototype.toString = function () {
                if (this.message === undefined) {
                  return this.name;
                } else {
                  return this.name + ": " + this.message;
                }
              };
              return errorClass;
            }
            var BindingError = undefined;
            function throwBindingError(message) {
              throw new BindingError(message);
            }
            var InternalError = undefined;
            function throwInternalError(message) {
              throw new InternalError(message);
            }
            function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
              myTypes.forEach(function (type) {
                typeDependencies[type] = dependentTypes;
              });
              function onComplete(typeConverters) {
                var myTypeConverters = getTypeConverters(typeConverters);
                if (myTypeConverters.length !== myTypes.length) {
                  throwInternalError("Mismatched type converter count");
                }
                for (var i = 0; i < myTypes.length; ++i) {
                  registerType(myTypes[i], myTypeConverters[i]);
                }
              }
              var typeConverters = new Array(dependentTypes.length);
              var unregisteredTypes = [];
              var registered = 0;
              dependentTypes.forEach(function (dt, i) {
                if (registeredTypes.hasOwnProperty(dt)) {
                  typeConverters[i] = registeredTypes[dt];
                } else {
                  unregisteredTypes.push(dt);
                  if (!awaitingDependencies.hasOwnProperty(dt)) {
                    awaitingDependencies[dt] = [];
                  }
                  awaitingDependencies[dt].push(function () {
                    typeConverters[i] = registeredTypes[dt];
                    ++registered;
                    if (registered === unregisteredTypes.length) {
                      onComplete(typeConverters);
                    }
                  });
                }
              });
              if (0 === unregisteredTypes.length) {
                onComplete(typeConverters);
              }
            }
            function registerType(rawType, registeredInstance, options) {
              options = options || {};
              if (!("argPackAdvance" in registeredInstance)) {
                throw new TypeError("registerType registeredInstance requires argPackAdvance");
              }
              var name = registeredInstance.name;
              if (!rawType) {
                throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
              }
              if (registeredTypes.hasOwnProperty(rawType)) {
                if (options.ignoreDuplicateRegistrations) {
                  return;
                } else {
                  throwBindingError("Cannot register type '" + name + "' twice");
                }
              }
              registeredTypes[rawType] = registeredInstance;
              delete typeDependencies[rawType];
              if (awaitingDependencies.hasOwnProperty(rawType)) {
                var callbacks = awaitingDependencies[rawType];
                delete awaitingDependencies[rawType];
                callbacks.forEach(function (cb) {
                  cb();
                });
              }
            }
            function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
              var shift = getShiftFromSize(size);
              name = readLatin1String(name);
              registerType(rawType, {
                name: name,
                "fromWireType": function fromWireType(wt) {
                  return !!wt;
                },
                "toWireType": function toWireType(destructors, o) {
                  return o ? trueValue : falseValue;
                },
                "argPackAdvance": 8,
                "readValueFromPointer": function readValueFromPointer(pointer) {
                  var heap;
                  if (size === 1) {
                    heap = HEAP8;
                  } else if (size === 2) {
                    heap = HEAP16;
                  } else if (size === 4) {
                    heap = HEAP32;
                  } else {
                    throw new TypeError("Unknown boolean type size: " + name);
                  }
                  return this["fromWireType"](heap[pointer >> shift]);
                },
                destructorFunction: null
              });
            }
            function ClassHandle_isAliasOf(other) {
              if (!(this instanceof ClassHandle)) {
                return false;
              }
              if (!(other instanceof ClassHandle)) {
                return false;
              }
              var leftClass = this.$$.ptrType.registeredClass;
              var left = this.$$.ptr;
              var rightClass = other.$$.ptrType.registeredClass;
              var right = other.$$.ptr;
              while (leftClass.baseClass) {
                left = leftClass.upcast(left);
                leftClass = leftClass.baseClass;
              }
              while (rightClass.baseClass) {
                right = rightClass.upcast(right);
                rightClass = rightClass.baseClass;
              }
              return leftClass === rightClass && left === right;
            }
            function shallowCopyInternalPointer(o) {
              return {
                count: o.count,
                deleteScheduled: o.deleteScheduled,
                preservePointerOnDelete: o.preservePointerOnDelete,
                ptr: o.ptr,
                ptrType: o.ptrType,
                smartPtr: o.smartPtr,
                smartPtrType: o.smartPtrType
              };
            }
            function throwInstanceAlreadyDeleted(obj) {
              function getInstanceTypeName(handle) {
                return handle.$$.ptrType.registeredClass.name;
              }
              throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
            }
            var finalizationGroup = false;
            function detachFinalizer(handle) {}
            function runDestructor($$) {
              if ($$.smartPtr) {
                $$.smartPtrType.rawDestructor($$.smartPtr);
              } else {
                $$.ptrType.registeredClass.rawDestructor($$.ptr);
              }
            }
            function releaseClassHandle($$) {
              $$.count.value -= 1;
              var toDelete = 0 === $$.count.value;
              if (toDelete) {
                runDestructor($$);
              }
            }
            function attachFinalizer(handle) {
              if ("undefined" === typeof FinalizationGroup) {
                attachFinalizer = function attachFinalizer(handle) {
                  return handle;
                };
                return handle;
              }
              finalizationGroup = new FinalizationGroup(function (iter) {
                for (var result = iter.next(); !result.done; result = iter.next()) {
                  var $$ = result.value;
                  if (!$$.ptr) {
                    console.warn("object already deleted: " + $$.ptr);
                  } else {
                    releaseClassHandle($$);
                  }
                }
              });
              attachFinalizer = function attachFinalizer(handle) {
                finalizationGroup.register(handle, handle.$$, handle.$$);
                return handle;
              };
              detachFinalizer = function detachFinalizer(handle) {
                finalizationGroup.unregister(handle.$$);
              };
              return attachFinalizer(handle);
            }
            function ClassHandle_clone() {
              if (!this.$$.ptr) {
                throwInstanceAlreadyDeleted(this);
              }
              if (this.$$.preservePointerOnDelete) {
                this.$$.count.value += 1;
                return this;
              } else {
                var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
                  $$: {
                    value: shallowCopyInternalPointer(this.$$)
                  }
                }));
                clone.$$.count.value += 1;
                clone.$$.deleteScheduled = false;
                return clone;
              }
            }
            function ClassHandle_delete() {
              if (!this.$$.ptr) {
                throwInstanceAlreadyDeleted(this);
              }
              if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                throwBindingError("Object already scheduled for deletion");
              }
              detachFinalizer(this);
              releaseClassHandle(this.$$);
              if (!this.$$.preservePointerOnDelete) {
                this.$$.smartPtr = undefined;
                this.$$.ptr = undefined;
              }
            }
            function ClassHandle_isDeleted() {
              return !this.$$.ptr;
            }
            var delayFunction = undefined;
            var deletionQueue = [];
            function flushPendingDeletes() {
              while (deletionQueue.length) {
                var obj = deletionQueue.pop();
                obj.$$.deleteScheduled = false;
                obj["delete"]();
              }
            }
            function ClassHandle_deleteLater() {
              if (!this.$$.ptr) {
                throwInstanceAlreadyDeleted(this);
              }
              if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                throwBindingError("Object already scheduled for deletion");
              }
              deletionQueue.push(this);
              if (deletionQueue.length === 1 && delayFunction) {
                delayFunction(flushPendingDeletes);
              }
              this.$$.deleteScheduled = true;
              return this;
            }
            function init_ClassHandle() {
              ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
              ClassHandle.prototype["clone"] = ClassHandle_clone;
              ClassHandle.prototype["delete"] = ClassHandle_delete;
              ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
              ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
            }
            function ClassHandle() {}
            var registeredPointers = {};
            function ensureOverloadTable(proto, methodName, humanName) {
              if (undefined === proto[methodName].overloadTable) {
                var prevFunc = proto[methodName];
                proto[methodName] = function () {
                  if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                    throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
                  }
                  return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
                };
                proto[methodName].overloadTable = [];
                proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
              }
            }
            function exposePublicSymbol(name, value, numArguments) {
              if (Module.hasOwnProperty(name)) {
                if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {
                  throwBindingError("Cannot register public name '" + name + "' twice");
                }
                ensureOverloadTable(Module, name, name);
                if (Module.hasOwnProperty(numArguments)) {
                  throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
                }
                Module[name].overloadTable[numArguments] = value;
              } else {
                Module[name] = value;
                if (undefined !== numArguments) {
                  Module[name].numArguments = numArguments;
                }
              }
            }
            function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
              this.name = name;
              this.constructor = constructor;
              this.instancePrototype = instancePrototype;
              this.rawDestructor = rawDestructor;
              this.baseClass = baseClass;
              this.getActualType = getActualType;
              this.upcast = upcast;
              this.downcast = downcast;
              this.pureVirtualFunctions = [];
            }
            function upcastPointer(ptr, ptrClass, desiredClass) {
              while (ptrClass !== desiredClass) {
                if (!ptrClass.upcast) {
                  throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
                }
                ptr = ptrClass.upcast(ptr);
                ptrClass = ptrClass.baseClass;
              }
              return ptr;
            }
            function constNoSmartPtrRawPointerToWireType(destructors, handle) {
              if (handle === null) {
                if (this.isReference) {
                  throwBindingError("null is not a valid " + this.name);
                }
                return 0;
              }
              if (!handle.$$) {
                throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
              }
              if (!handle.$$.ptr) {
                throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
              }
              var handleClass = handle.$$.ptrType.registeredClass;
              var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
              return ptr;
            }
            function genericPointerToWireType(destructors, handle) {
              var ptr;
              if (handle === null) {
                if (this.isReference) {
                  throwBindingError("null is not a valid " + this.name);
                }
                if (this.isSmartPointer) {
                  ptr = this.rawConstructor();
                  if (destructors !== null) {
                    destructors.push(this.rawDestructor, ptr);
                  }
                  return ptr;
                } else {
                  return 0;
                }
              }
              if (!handle.$$) {
                throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
              }
              if (!handle.$$.ptr) {
                throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
              }
              if (!this.isConst && handle.$$.ptrType.isConst) {
                throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
              }
              var handleClass = handle.$$.ptrType.registeredClass;
              ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
              if (this.isSmartPointer) {
                if (undefined === handle.$$.smartPtr) {
                  throwBindingError("Passing raw pointer to smart pointer is illegal");
                }
                switch (this.sharingPolicy) {
                  case 0:
                    if (handle.$$.smartPtrType === this) {
                      ptr = handle.$$.smartPtr;
                    } else {
                      throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
                    }
                    break;
                  case 1:
                    ptr = handle.$$.smartPtr;
                    break;
                  case 2:
                    if (handle.$$.smartPtrType === this) {
                      ptr = handle.$$.smartPtr;
                    } else {
                      var clonedHandle = handle["clone"]();
                      ptr = this.rawShare(ptr, Emval.toHandle(function () {
                        clonedHandle["delete"]();
                      }));
                      if (destructors !== null) {
                        destructors.push(this.rawDestructor, ptr);
                      }
                    }
                    break;
                  default:
                    throwBindingError("Unsupporting sharing policy");
                }
              }
              return ptr;
            }
            function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
              if (handle === null) {
                if (this.isReference) {
                  throwBindingError("null is not a valid " + this.name);
                }
                return 0;
              }
              if (!handle.$$) {
                throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
              }
              if (!handle.$$.ptr) {
                throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
              }
              if (handle.$$.ptrType.isConst) {
                throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
              }
              var handleClass = handle.$$.ptrType.registeredClass;
              var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
              return ptr;
            }
            function simpleReadValueFromPointer(pointer) {
              return this["fromWireType"](HEAPU32[pointer >> 2]);
            }
            function RegisteredPointer_getPointee(ptr) {
              if (this.rawGetPointee) {
                ptr = this.rawGetPointee(ptr);
              }
              return ptr;
            }
            function RegisteredPointer_destructor(ptr) {
              if (this.rawDestructor) {
                this.rawDestructor(ptr);
              }
            }
            function RegisteredPointer_deleteObject(handle) {
              if (handle !== null) {
                handle["delete"]();
              }
            }
            function downcastPointer(ptr, ptrClass, desiredClass) {
              if (ptrClass === desiredClass) {
                return ptr;
              }
              if (undefined === desiredClass.baseClass) {
                return null;
              }
              var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
              if (rv === null) {
                return null;
              }
              return desiredClass.downcast(rv);
            }
            function getInheritedInstanceCount() {
              return Object.keys(registeredInstances).length;
            }
            function getLiveInheritedInstances() {
              var rv = [];
              for (var k in registeredInstances) {
                if (registeredInstances.hasOwnProperty(k)) {
                  rv.push(registeredInstances[k]);
                }
              }
              return rv;
            }
            function setDelayFunction(fn) {
              delayFunction = fn;
              if (deletionQueue.length && delayFunction) {
                delayFunction(flushPendingDeletes);
              }
            }
            function init_embind() {
              Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
              Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
              Module["flushPendingDeletes"] = flushPendingDeletes;
              Module["setDelayFunction"] = setDelayFunction;
            }
            var registeredInstances = {};
            function getBasestPointer(class_, ptr) {
              if (ptr === undefined) {
                throwBindingError("ptr should not be undefined");
              }
              while (class_.baseClass) {
                ptr = class_.upcast(ptr);
                class_ = class_.baseClass;
              }
              return ptr;
            }
            function getInheritedInstance(class_, ptr) {
              ptr = getBasestPointer(class_, ptr);
              return registeredInstances[ptr];
            }
            function makeClassHandle(prototype, record) {
              if (!record.ptrType || !record.ptr) {
                throwInternalError("makeClassHandle requires ptr and ptrType");
              }
              var hasSmartPtrType = !!record.smartPtrType;
              var hasSmartPtr = !!record.smartPtr;
              if (hasSmartPtrType !== hasSmartPtr) {
                throwInternalError("Both smartPtrType and smartPtr must be specified");
              }
              record.count = {
                value: 1
              };
              return attachFinalizer(Object.create(prototype, {
                $$: {
                  value: record
                }
              }));
            }
            function RegisteredPointer_fromWireType(ptr) {
              var rawPointer = this.getPointee(ptr);
              if (!rawPointer) {
                this.destructor(ptr);
                return null;
              }
              var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
              if (undefined !== registeredInstance) {
                if (0 === registeredInstance.$$.count.value) {
                  registeredInstance.$$.ptr = rawPointer;
                  registeredInstance.$$.smartPtr = ptr;
                  return registeredInstance["clone"]();
                } else {
                  var rv = registeredInstance["clone"]();
                  this.destructor(ptr);
                  return rv;
                }
              }
              function makeDefaultHandle() {
                if (this.isSmartPointer) {
                  return makeClassHandle(this.registeredClass.instancePrototype, {
                    ptrType: this.pointeeType,
                    ptr: rawPointer,
                    smartPtrType: this,
                    smartPtr: ptr
                  });
                } else {
                  return makeClassHandle(this.registeredClass.instancePrototype, {
                    ptrType: this,
                    ptr: ptr
                  });
                }
              }
              var actualType = this.registeredClass.getActualType(rawPointer);
              var registeredPointerRecord = registeredPointers[actualType];
              if (!registeredPointerRecord) {
                return makeDefaultHandle.call(this);
              }
              var toType;
              if (this.isConst) {
                toType = registeredPointerRecord.constPointerType;
              } else {
                toType = registeredPointerRecord.pointerType;
              }
              var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
              if (dp === null) {
                return makeDefaultHandle.call(this);
              }
              if (this.isSmartPointer) {
                return makeClassHandle(toType.registeredClass.instancePrototype, {
                  ptrType: toType,
                  ptr: dp,
                  smartPtrType: this,
                  smartPtr: ptr
                });
              } else {
                return makeClassHandle(toType.registeredClass.instancePrototype, {
                  ptrType: toType,
                  ptr: dp
                });
              }
            }
            function init_RegisteredPointer() {
              RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
              RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
              RegisteredPointer.prototype["argPackAdvance"] = 8;
              RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
              RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
              RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
            }
            function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
              this.name = name;
              this.registeredClass = registeredClass;
              this.isReference = isReference;
              this.isConst = isConst;
              this.isSmartPointer = isSmartPointer;
              this.pointeeType = pointeeType;
              this.sharingPolicy = sharingPolicy;
              this.rawGetPointee = rawGetPointee;
              this.rawConstructor = rawConstructor;
              this.rawShare = rawShare;
              this.rawDestructor = rawDestructor;
              if (!isSmartPointer && registeredClass.baseClass === undefined) {
                if (isConst) {
                  this["toWireType"] = constNoSmartPtrRawPointerToWireType;
                  this.destructorFunction = null;
                } else {
                  this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
                  this.destructorFunction = null;
                }
              } else {
                this["toWireType"] = genericPointerToWireType;
              }
            }
            function replacePublicSymbol(name, value, numArguments) {
              if (!Module.hasOwnProperty(name)) {
                throwInternalError("Replacing nonexistant public symbol");
              }
              if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
                Module[name].overloadTable[numArguments] = value;
              } else {
                Module[name] = value;
                Module[name].argCount = numArguments;
              }
            }
            function dynCallLegacy(sig, ptr, args) {
              var f = Module["dynCall_" + sig];
              return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
            }
            function dynCall(sig, ptr, args) {
              if (sig.includes("j")) {
                return dynCallLegacy(sig, ptr, args);
              }
              return getWasmTableEntry(ptr).apply(null, args);
            }
            function getDynCaller(sig, ptr) {
              var argCache = [];
              return function () {
                argCache.length = arguments.length;
                for (var i = 0; i < arguments.length; i++) {
                  argCache[i] = arguments[i];
                }
                return dynCall(sig, ptr, argCache);
              };
            }
            function embind__requireFunction(signature, rawFunction) {
              signature = readLatin1String(signature);
              function makeDynCaller() {
                if (signature.includes("j")) {
                  return getDynCaller(signature, rawFunction);
                }
                return getWasmTableEntry(rawFunction);
              }
              var fp = makeDynCaller();
              if (typeof fp !== "function") {
                throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
              }
              return fp;
            }
            var UnboundTypeError = undefined;
            function getTypeName(type) {
              var ptr = ___getTypeName(type);
              var rv = readLatin1String(ptr);
              _free(ptr);
              return rv;
            }
            function throwUnboundTypeError(message, types) {
              var unboundTypes = [];
              var seen = {};
              function visit(type) {
                if (seen[type]) {
                  return;
                }
                if (registeredTypes[type]) {
                  return;
                }
                if (typeDependencies[type]) {
                  typeDependencies[type].forEach(visit);
                  return;
                }
                unboundTypes.push(type);
                seen[type] = true;
              }
              types.forEach(visit);
              throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
            }
            function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {
              name = readLatin1String(name);
              getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
              if (upcast) {
                upcast = embind__requireFunction(upcastSignature, upcast);
              }
              if (downcast) {
                downcast = embind__requireFunction(downcastSignature, downcast);
              }
              rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
              var legalFunctionName = makeLegalFunctionName(name);
              exposePublicSymbol(legalFunctionName, function () {
                throwUnboundTypeError("Cannot construct " + name + " due to unbound types", [baseClassRawType]);
              });
              whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function (base) {
                base = base[0];
                var baseClass;
                var basePrototype;
                if (baseClassRawType) {
                  baseClass = base.registeredClass;
                  basePrototype = baseClass.instancePrototype;
                } else {
                  basePrototype = ClassHandle.prototype;
                }
                var constructor = createNamedFunction(legalFunctionName, function () {
                  if (Object.getPrototypeOf(this) !== instancePrototype) {
                    throw new BindingError("Use 'new' to construct " + name);
                  }
                  if (undefined === registeredClass.constructor_body) {
                    throw new BindingError(name + " has no accessible constructor");
                  }
                  var body = registeredClass.constructor_body[arguments.length];
                  if (undefined === body) {
                    throw new BindingError("Tried to invoke ctor of " + name + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
                  }
                  return body.apply(this, arguments);
                });
                var instancePrototype = Object.create(basePrototype, {
                  constructor: {
                    value: constructor
                  }
                });
                constructor.prototype = instancePrototype;
                var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
                var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);
                var pointerConverter = new RegisteredPointer(name + "*", registeredClass, false, false, false);
                var constPointerConverter = new RegisteredPointer(name + " const*", registeredClass, false, true, false);
                registeredPointers[rawType] = {
                  pointerType: pointerConverter,
                  constPointerType: constPointerConverter
                };
                replacePublicSymbol(legalFunctionName, constructor);
                return [referenceConverter, pointerConverter, constPointerConverter];
              });
            }
            function heap32VectorToArray(count, firstElement) {
              var array = [];
              for (var i = 0; i < count; i++) {
                array.push(HEAP32[(firstElement >> 2) + i]);
              }
              return array;
            }
            function runDestructors(destructors) {
              while (destructors.length) {
                var ptr = destructors.pop();
                var del = destructors.pop();
                del(ptr);
              }
            }
            function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
              assert(argCount > 0);
              var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
              invoker = embind__requireFunction(invokerSignature, invoker);
              whenDependentTypesAreResolved([], [rawClassType], function (classType) {
                classType = classType[0];
                var humanName = "constructor " + classType.name;
                if (undefined === classType.registeredClass.constructor_body) {
                  classType.registeredClass.constructor_body = [];
                }
                if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
                  throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
                }
                classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
                  throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
                };
                whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {
                  argTypes.splice(1, 0, null);
                  classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
                  return [];
                });
                return [];
              });
            }
            function new_(constructor, argumentList) {
              if (!(constructor instanceof Function)) {
                throw new TypeError("new_ called with constructor type " + _typeof(constructor) + " which is not a function");
              }
              var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function () {});
              dummy.prototype = constructor.prototype;
              var obj = new dummy();
              var r = constructor.apply(obj, argumentList);
              return r instanceof Object ? r : obj;
            }
            function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
              var argCount = argTypes.length;
              if (argCount < 2) {
                throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
              }
              var isClassMethodFunc = argTypes[1] !== null && classType !== null;
              var needsDestructorStack = false;
              for (var i = 1; i < argTypes.length; ++i) {
                if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {
                  needsDestructorStack = true;
                  break;
                }
              }
              var returns = argTypes[0].name !== "void";
              var argsList = "";
              var argsListWired = "";
              for (var i = 0; i < argCount - 2; ++i) {
                argsList += (i !== 0 ? ", " : "") + "arg" + i;
                argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
              }
              var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\n" + "if (arguments.length !== " + (argCount - 2) + ") {\n" + "throwBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n" + "}\n";
              if (needsDestructorStack) {
                invokerFnBody += "var destructors = [];\n";
              }
              var dtorStack = needsDestructorStack ? "destructors" : "null";
              var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
              var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
              if (isClassMethodFunc) {
                invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
              }
              for (var i = 0; i < argCount - 2; ++i) {
                invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
                args1.push("argType" + i);
                args2.push(argTypes[i + 2]);
              }
              if (isClassMethodFunc) {
                argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
              }
              invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
              if (needsDestructorStack) {
                invokerFnBody += "runDestructors(destructors);\n";
              } else {
                for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
                  var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
                  if (argTypes[i].destructorFunction !== null) {
                    invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
                    args1.push(paramName + "_dtor");
                    args2.push(argTypes[i].destructorFunction);
                  }
                }
              }
              if (returns) {
                invokerFnBody += "var ret = retType.fromWireType(rv);\n" + "return ret;\n";
              }
              invokerFnBody += "}\n";
              args1.push(invokerFnBody);
              var invokerFunction = new_(Function, args1).apply(null, args2);
              return invokerFunction;
            }
            function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
              var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
              methodName = readLatin1String(methodName);
              rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
              whenDependentTypesAreResolved([], [rawClassType], function (classType) {
                classType = classType[0];
                var humanName = classType.name + "." + methodName;
                if (methodName.startsWith("@@")) {
                  methodName = Symbol[methodName.substring(2)];
                }
                if (isPureVirtual) {
                  classType.registeredClass.pureVirtualFunctions.push(methodName);
                }
                function unboundTypesHandler() {
                  throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
                }
                var proto = classType.registeredClass.instancePrototype;
                var method = proto[methodName];
                if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
                  unboundTypesHandler.argCount = argCount - 2;
                  unboundTypesHandler.className = classType.name;
                  proto[methodName] = unboundTypesHandler;
                } else {
                  ensureOverloadTable(proto, methodName, humanName);
                  proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
                }
                whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {
                  var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
                  if (undefined === proto[methodName].overloadTable) {
                    memberFunction.argCount = argCount - 2;
                    proto[methodName] = memberFunction;
                  } else {
                    proto[methodName].overloadTable[argCount - 2] = memberFunction;
                  }
                  return [];
                });
                return [];
              });
            }
            function validateThis(this_, classType, humanName) {
              if (!(this_ instanceof Object)) {
                throwBindingError(humanName + ' with invalid "this": ' + this_);
              }
              if (!(this_ instanceof classType.registeredClass.constructor)) {
                throwBindingError(humanName + ' incompatible with "this" of type ' + this_.constructor.name);
              }
              if (!this_.$$.ptr) {
                throwBindingError("cannot call emscripten binding method " + humanName + " on deleted object");
              }
              return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);
            }
            function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
              fieldName = readLatin1String(fieldName);
              getter = embind__requireFunction(getterSignature, getter);
              whenDependentTypesAreResolved([], [classType], function (classType) {
                classType = classType[0];
                var humanName = classType.name + "." + fieldName;
                var desc = {
                  get: function get() {
                    throwUnboundTypeError("Cannot access " + humanName + " due to unbound types", [getterReturnType, setterArgumentType]);
                  },
                  enumerable: true,
                  configurable: true
                };
                if (setter) {
                  desc.set = function () {
                    throwUnboundTypeError("Cannot access " + humanName + " due to unbound types", [getterReturnType, setterArgumentType]);
                  };
                } else {
                  desc.set = function (v) {
                    throwBindingError(humanName + " is a read-only property");
                  };
                }
                Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
                whenDependentTypesAreResolved([], setter ? [getterReturnType, setterArgumentType] : [getterReturnType], function (types) {
                  var getterReturnType = types[0];
                  var desc = {
                    get: function get() {
                      var ptr = validateThis(this, classType, humanName + " getter");
                      return getterReturnType["fromWireType"](getter(getterContext, ptr));
                    },
                    enumerable: true
                  };
                  if (setter) {
                    setter = embind__requireFunction(setterSignature, setter);
                    var setterArgumentType = types[1];
                    desc.set = function (v) {
                      var ptr = validateThis(this, classType, humanName + " setter");
                      var destructors = [];
                      setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, v));
                      runDestructors(destructors);
                    };
                  }
                  Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
                  return [];
                });
                return [];
              });
            }
            var emval_free_list = [];
            var emval_handle_array = [{}, {
              value: undefined
            }, {
              value: null
            }, {
              value: true
            }, {
              value: false
            }];
            function __emval_decref(handle) {
              if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
                emval_handle_array[handle] = undefined;
                emval_free_list.push(handle);
              }
            }
            function count_emval_handles() {
              var count = 0;
              for (var i = 5; i < emval_handle_array.length; ++i) {
                if (emval_handle_array[i] !== undefined) {
                  ++count;
                }
              }
              return count;
            }
            function get_first_emval() {
              for (var i = 5; i < emval_handle_array.length; ++i) {
                if (emval_handle_array[i] !== undefined) {
                  return emval_handle_array[i];
                }
              }
              return null;
            }
            function init_emval() {
              Module["count_emval_handles"] = count_emval_handles;
              Module["get_first_emval"] = get_first_emval;
            }
            var Emval = {
              toValue: function toValue(handle) {
                if (!handle) {
                  throwBindingError("Cannot use deleted val. handle = " + handle);
                }
                return emval_handle_array[handle].value;
              },
              toHandle: function toHandle(value) {
                switch (value) {
                  case undefined:
                    {
                      return 1;
                    }
                  case null:
                    {
                      return 2;
                    }
                  case true:
                    {
                      return 3;
                    }
                  case false:
                    {
                      return 4;
                    }
                  default:
                    {
                      var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
                      emval_handle_array[handle] = {
                        refcount: 1,
                        value: value
                      };
                      return handle;
                    }
                }
              }
            };
            function __embind_register_emval(rawType, name) {
              name = readLatin1String(name);
              registerType(rawType, {
                name: name,
                "fromWireType": function fromWireType(handle) {
                  var rv = Emval.toValue(handle);
                  __emval_decref(handle);
                  return rv;
                },
                "toWireType": function toWireType(destructors, value) {
                  return Emval.toHandle(value);
                },
                "argPackAdvance": 8,
                "readValueFromPointer": simpleReadValueFromPointer,
                destructorFunction: null
              });
            }
            function _embind_repr(v) {
              if (v === null) {
                return "null";
              }
              var t = _typeof(v);
              if (t === "object" || t === "array" || t === "function") {
                return v.toString();
              } else {
                return "" + v;
              }
            }
            function floatReadValueFromPointer(name, shift) {
              switch (shift) {
                case 2:
                  return function (pointer) {
                    return this["fromWireType"](HEAPF32[pointer >> 2]);
                  };
                case 3:
                  return function (pointer) {
                    return this["fromWireType"](HEAPF64[pointer >> 3]);
                  };
                default:
                  throw new TypeError("Unknown float type: " + name);
              }
            }
            function __embind_register_float(rawType, name, size) {
              var shift = getShiftFromSize(size);
              name = readLatin1String(name);
              registerType(rawType, {
                name: name,
                "fromWireType": function fromWireType(value) {
                  return value;
                },
                "toWireType": function toWireType(destructors, value) {
                  return value;
                },
                "argPackAdvance": 8,
                "readValueFromPointer": floatReadValueFromPointer(name, shift),
                destructorFunction: null
              });
            }
            function integerReadValueFromPointer(name, shift, signed) {
              switch (shift) {
                case 0:
                  return signed ? function readS8FromPointer(pointer) {
                    return HEAP8[pointer];
                  } : function readU8FromPointer(pointer) {
                    return HEAPU8[pointer];
                  };
                case 1:
                  return signed ? function readS16FromPointer(pointer) {
                    return HEAP16[pointer >> 1];
                  } : function readU16FromPointer(pointer) {
                    return HEAPU16[pointer >> 1];
                  };
                case 2:
                  return signed ? function readS32FromPointer(pointer) {
                    return HEAP32[pointer >> 2];
                  } : function readU32FromPointer(pointer) {
                    return HEAPU32[pointer >> 2];
                  };
                default:
                  throw new TypeError("Unknown integer type: " + name);
              }
            }
            function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
              name = readLatin1String(name);
              if (maxRange === -1) {
                maxRange = 4294967295;
              }
              var shift = getShiftFromSize(size);
              var fromWireType = function fromWireType(value) {
                return value;
              };
              if (minRange === 0) {
                var bitshift = 32 - 8 * size;
                fromWireType = function fromWireType(value) {
                  return value << bitshift >>> bitshift;
                };
              }
              var isUnsignedType = name.includes("unsigned");
              registerType(primitiveType, {
                name: name,
                "fromWireType": fromWireType,
                "toWireType": function toWireType(destructors, value) {
                  if (typeof value !== "number" && typeof value !== "boolean") {
                    throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
                  }
                  if (value < minRange || value > maxRange) {
                    throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
                  }
                  return isUnsignedType ? value >>> 0 : value | 0;
                },
                "argPackAdvance": 8,
                "readValueFromPointer": integerReadValueFromPointer(name, shift, minRange !== 0),
                destructorFunction: null
              });
            }
            function __embind_register_memory_view(rawType, dataTypeIndex, name) {
              var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
              var TA = typeMapping[dataTypeIndex];
              function decodeMemoryView(handle) {
                handle = handle >> 2;
                var heap = HEAPU32;
                var size = heap[handle];
                var data = heap[handle + 1];
                return new TA(buffer, data, size);
              }
              name = readLatin1String(name);
              registerType(rawType, {
                name: name,
                "fromWireType": decodeMemoryView,
                "argPackAdvance": 8,
                "readValueFromPointer": decodeMemoryView
              }, {
                ignoreDuplicateRegistrations: true
              });
            }
            function __embind_register_std_string(rawType, name) {
              name = readLatin1String(name);
              var stdStringIsUTF8 = name === "std::string";
              registerType(rawType, {
                name: name,
                "fromWireType": function fromWireType(value) {
                  var length = HEAPU32[value >> 2];
                  var str;
                  if (stdStringIsUTF8) {
                    var decodeStartPtr = value + 4;
                    for (var i = 0; i <= length; ++i) {
                      var currentBytePtr = value + 4 + i;
                      if (i == length || HEAPU8[currentBytePtr] == 0) {
                        var maxRead = currentBytePtr - decodeStartPtr;
                        var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                        if (str === undefined) {
                          str = stringSegment;
                        } else {
                          str += String.fromCharCode(0);
                          str += stringSegment;
                        }
                        decodeStartPtr = currentBytePtr + 1;
                      }
                    }
                  } else {
                    var a = new Array(length);
                    for (var i = 0; i < length; ++i) {
                      a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
                    }
                    str = a.join("");
                  }
                  _free(value);
                  return str;
                },
                "toWireType": function toWireType(destructors, value) {
                  if (value instanceof ArrayBuffer) {
                    value = new Uint8Array(value);
                  }
                  var getLength;
                  var valueIsOfTypeString = typeof value === "string";
                  if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                    throwBindingError("Cannot pass non-string to std::string");
                  }
                  if (stdStringIsUTF8 && valueIsOfTypeString) {
                    getLength = function getLength() {
                      return lengthBytesUTF8(value);
                    };
                  } else {
                    getLength = function getLength() {
                      return value.length;
                    };
                  }
                  var length = getLength();
                  var ptr = _malloc(4 + length + 1);
                  HEAPU32[ptr >> 2] = length;
                  if (stdStringIsUTF8 && valueIsOfTypeString) {
                    stringToUTF8(value, ptr + 4, length + 1);
                  } else {
                    if (valueIsOfTypeString) {
                      for (var i = 0; i < length; ++i) {
                        var charCode = value.charCodeAt(i);
                        if (charCode > 255) {
                          _free(ptr);
                          throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                        }
                        HEAPU8[ptr + 4 + i] = charCode;
                      }
                    } else {
                      for (var i = 0; i < length; ++i) {
                        HEAPU8[ptr + 4 + i] = value[i];
                      }
                    }
                  }
                  if (destructors !== null) {
                    destructors.push(_free, ptr);
                  }
                  return ptr;
                },
                "argPackAdvance": 8,
                "readValueFromPointer": simpleReadValueFromPointer,
                destructorFunction: function destructorFunction(ptr) {
                  _free(ptr);
                }
              });
            }
            function __embind_register_std_wstring(rawType, charSize, name) {
              name = readLatin1String(name);
              var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
              if (charSize === 2) {
                decodeString = UTF16ToString;
                encodeString = stringToUTF16;
                lengthBytesUTF = lengthBytesUTF16;
                getHeap = function getHeap() {
                  return HEAPU16;
                };
                shift = 1;
              } else if (charSize === 4) {
                decodeString = UTF32ToString;
                encodeString = stringToUTF32;
                lengthBytesUTF = lengthBytesUTF32;
                getHeap = function getHeap() {
                  return HEAPU32;
                };
                shift = 2;
              }
              registerType(rawType, {
                name: name,
                "fromWireType": function fromWireType(value) {
                  var length = HEAPU32[value >> 2];
                  var HEAP = getHeap();
                  var str;
                  var decodeStartPtr = value + 4;
                  for (var i = 0; i <= length; ++i) {
                    var currentBytePtr = value + 4 + i * charSize;
                    if (i == length || HEAP[currentBytePtr >> shift] == 0) {
                      var maxReadBytes = currentBytePtr - decodeStartPtr;
                      var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                      if (str === undefined) {
                        str = stringSegment;
                      } else {
                        str += String.fromCharCode(0);
                        str += stringSegment;
                      }
                      decodeStartPtr = currentBytePtr + charSize;
                    }
                  }
                  _free(value);
                  return str;
                },
                "toWireType": function toWireType(destructors, value) {
                  if (!(typeof value === "string")) {
                    throwBindingError("Cannot pass non-string to C++ string type " + name);
                  }
                  var length = lengthBytesUTF(value);
                  var ptr = _malloc(4 + length + charSize);
                  HEAPU32[ptr >> 2] = length >> shift;
                  encodeString(value, ptr + 4, length + charSize);
                  if (destructors !== null) {
                    destructors.push(_free, ptr);
                  }
                  return ptr;
                },
                "argPackAdvance": 8,
                "readValueFromPointer": simpleReadValueFromPointer,
                destructorFunction: function destructorFunction(ptr) {
                  _free(ptr);
                }
              });
            }
            function __embind_register_void(rawType, name) {
              name = readLatin1String(name);
              registerType(rawType, {
                isVoid: true,
                name: name,
                "argPackAdvance": 0,
                "fromWireType": function fromWireType() {
                  return undefined;
                },
                "toWireType": function toWireType(destructors, o) {
                  return undefined;
                }
              });
            }
            function requireRegisteredType(rawType, humanName) {
              var impl = registeredTypes[rawType];
              if (undefined === impl) {
                throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
              }
              return impl;
            }
            function __emval_as(handle, returnType, destructorsRef) {
              handle = Emval.toValue(handle);
              returnType = requireRegisteredType(returnType, "emval::as");
              var destructors = [];
              var rd = Emval.toHandle(destructors);
              HEAP32[destructorsRef >> 2] = rd;
              return returnType["toWireType"](destructors, handle);
            }
            var emval_symbols = {};
            function getStringOrSymbol(address) {
              var symbol = emval_symbols[address];
              if (symbol === undefined) {
                return readLatin1String(address);
              } else {
                return symbol;
              }
            }
            var emval_methodCallers = [];
            function __emval_call_void_method(caller, handle, methodName, args) {
              caller = emval_methodCallers[caller];
              handle = Emval.toValue(handle);
              methodName = getStringOrSymbol(methodName);
              caller(handle, methodName, null, args);
            }
            function __emval_addMethodCaller(caller) {
              var id = emval_methodCallers.length;
              emval_methodCallers.push(caller);
              return id;
            }
            function __emval_lookupTypes(argCount, argTypes) {
              var a = new Array(argCount);
              for (var i = 0; i < argCount; ++i) {
                a[i] = requireRegisteredType(HEAP32[(argTypes >> 2) + i], "parameter " + i);
              }
              return a;
            }
            var emval_registeredMethods = [];
            function __emval_get_method_caller(argCount, argTypes) {
              var types = __emval_lookupTypes(argCount, argTypes);
              var retType = types[0];
              var signatureName = retType.name + "_$" + types.slice(1).map(function (t) {
                return t.name;
              }).join("_") + "$";
              var returnId = emval_registeredMethods[signatureName];
              if (returnId !== undefined) {
                return returnId;
              }
              var params = ["retType"];
              var args = [retType];
              var argsList = "";
              for (var i = 0; i < argCount - 1; ++i) {
                argsList += (i !== 0 ? ", " : "") + "arg" + i;
                params.push("argType" + i);
                args.push(types[1 + i]);
              }
              var functionName = makeLegalFunctionName("methodCaller_" + signatureName);
              var functionBody = "return function " + functionName + "(handle, name, destructors, args) {\n";
              var offset = 0;
              for (var i = 0; i < argCount - 1; ++i) {
                functionBody += "    var arg" + i + " = argType" + i + ".readValueFromPointer(args" + (offset ? "+" + offset : "") + ");\n";
                offset += types[i + 1]["argPackAdvance"];
              }
              functionBody += "    var rv = handle[name](" + argsList + ");\n";
              for (var i = 0; i < argCount - 1; ++i) {
                if (types[i + 1]["deleteObject"]) {
                  functionBody += "    argType" + i + ".deleteObject(arg" + i + ");\n";
                }
              }
              if (!retType.isVoid) {
                functionBody += "    return retType.toWireType(destructors, rv);\n";
              }
              functionBody += "};\n";
              params.push(functionBody);
              var invokerFunction = new_(Function, params).apply(null, args);
              returnId = __emval_addMethodCaller(invokerFunction);
              emval_registeredMethods[signatureName] = returnId;
              return returnId;
            }
            function __emval_get_property(handle, key) {
              handle = Emval.toValue(handle);
              key = Emval.toValue(key);
              return Emval.toHandle(handle[key]);
            }
            function __emval_incref(handle) {
              if (handle > 4) {
                emval_handle_array[handle].refcount += 1;
              }
            }
            function __emval_new_array() {
              return Emval.toHandle([]);
            }
            function __emval_new_cstring(v) {
              return Emval.toHandle(getStringOrSymbol(v));
            }
            function __emval_new_object() {
              return Emval.toHandle({});
            }
            function __emval_run_destructors(handle) {
              var destructors = Emval.toValue(handle);
              runDestructors(destructors);
              __emval_decref(handle);
            }
            function __emval_set_property(handle, key, value) {
              handle = Emval.toValue(handle);
              key = Emval.toValue(key);
              value = Emval.toValue(value);
              handle[key] = value;
            }
            function __emval_take_value(type, argv) {
              type = requireRegisteredType(type, "_emval_take_value");
              var v = type["readValueFromPointer"](argv);
              return Emval.toHandle(v);
            }
            function _abort() {
              abort("");
            }
            function _emscripten_get_heap_max() {
              return HEAPU8.length;
            }
            function _emscripten_memcpy_big(dest, src, num) {
              HEAPU8.copyWithin(dest, src, src + num);
            }
            function abortOnCannotGrowMemory(requestedSize) {
              abort("OOM");
            }
            function _emscripten_resize_heap(requestedSize) {
              HEAPU8.length;
              abortOnCannotGrowMemory();
            }
            var SYSCALLS = {
              mappings: {},
              buffers: [null, [], []],
              printChar: function printChar(stream, curr) {
                var buffer = SYSCALLS.buffers[stream];
                if (curr === 0 || curr === 10) {
                  (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
                  buffer.length = 0;
                } else {
                  buffer.push(curr);
                }
              },
              varargs: undefined,
              get: function get() {
                SYSCALLS.varargs += 4;
                var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
                return ret;
              },
              getStr: function getStr(ptr) {
                var ret = UTF8ToString(ptr);
                return ret;
              },
              get64: function get64(low, high) {
                return low;
              }
            };
            function _fd_close(fd) {
              return 0;
            }
            function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {}
            function _fd_write(fd, iov, iovcnt, pnum) {
              var num = 0;
              for (var i = 0; i < iovcnt; i++) {
                var ptr = HEAP32[iov >> 2];
                var len = HEAP32[iov + 4 >> 2];
                iov += 8;
                for (var j = 0; j < len; j++) {
                  SYSCALLS.printChar(fd, HEAPU8[ptr + j]);
                }
                num += len;
              }
              HEAP32[pnum >> 2] = num;
              return 0;
            }
            function _setTempRet0(val) {}
            embind_init_charCodes();
            BindingError = Module["BindingError"] = extendError(Error, "BindingError");
            InternalError = Module["InternalError"] = extendError(Error, "InternalError");
            init_ClassHandle();
            init_RegisteredPointer();
            init_embind();
            UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
            init_emval();
            var asmLibraryArg = {
              "k": ___assert_fail,
              "y": __embind_register_bigint,
              "E": __embind_register_bool,
              "t": __embind_register_class,
              "r": __embind_register_class_constructor,
              "l": __embind_register_class_function,
              "G": __embind_register_class_property,
              "D": __embind_register_emval,
              "p": __embind_register_float,
              "c": __embind_register_integer,
              "b": __embind_register_memory_view,
              "q": __embind_register_std_string,
              "n": __embind_register_std_wstring,
              "F": __embind_register_void,
              "v": __emval_as,
              "g": __emval_call_void_method,
              "a": __emval_decref,
              "f": __emval_get_method_caller,
              "w": __emval_get_property,
              "h": __emval_incref,
              "s": __emval_new_array,
              "d": __emval_new_cstring,
              "H": __emval_new_object,
              "u": __emval_run_destructors,
              "i": __emval_set_property,
              "e": __emval_take_value,
              "j": _abort,
              "C": _emscripten_get_heap_max,
              "z": _emscripten_memcpy_big,
              "m": _emscripten_resize_heap,
              "A": _fd_close,
              "x": _fd_seek,
              "B": _fd_write,
              "o": _setTempRet0
            };
            createWasm();
            Module["___wasm_call_ctors"] = function () {
              return (Module["___wasm_call_ctors"] = Module["asm"]["J"]).apply(null, arguments);
            };
            Module["_wdsp_anr_create"] = function () {
              return (Module["_wdsp_anr_create"] = Module["asm"]["K"]).apply(null, arguments);
            };
            Module["_wdsp_anr_filter"] = function () {
              return (Module["_wdsp_anr_filter"] = Module["asm"]["L"]).apply(null, arguments);
            };
            Module["_wdsp_anr_destroy"] = function () {
              return (Module["_wdsp_anr_destroy"] = Module["asm"]["M"]).apply(null, arguments);
            };
            var _free = Module["_free"] = function () {
              return (_free = Module["_free"] = Module["asm"]["N"]).apply(null, arguments);
            };
            Module["_wild_nb_init"] = function () {
              return (Module["_wild_nb_init"] = Module["asm"]["O"]).apply(null, arguments);
            };
            Module["_wild_nb_blank"] = function () {
              return (Module["_wild_nb_blank"] = Module["asm"]["P"]).apply(null, arguments);
            };
            Module["_wild_nb_destroy"] = function () {
              return (Module["_wild_nb_destroy"] = Module["asm"]["Q"]).apply(null, arguments);
            };
            Module["_nr_spectral_init"] = function () {
              return (Module["_nr_spectral_init"] = Module["asm"]["R"]).apply(null, arguments);
            };
            var _malloc = Module["_malloc"] = function () {
              return (_malloc = Module["_malloc"] = Module["asm"]["S"]).apply(null, arguments);
            };
            Module["_nr_spectral_process"] = function () {
              return (Module["_nr_spectral_process"] = Module["asm"]["T"]).apply(null, arguments);
            };
            Module["_agc_rrrf_create"] = function () {
              return (Module["_agc_rrrf_create"] = Module["asm"]["U"]).apply(null, arguments);
            };
            Module["_agc_rrrf_destroy"] = function () {
              return (Module["_agc_rrrf_destroy"] = Module["asm"]["V"]).apply(null, arguments);
            };
            Module["_agc_rrrf_execute_block"] = function () {
              return (Module["_agc_rrrf_execute_block"] = Module["asm"]["W"]).apply(null, arguments);
            };
            Module["_firfilt_rrrf_create"] = function () {
              return (Module["_firfilt_rrrf_create"] = Module["asm"]["X"]).apply(null, arguments);
            };
            Module["_firfilt_rrrf_destroy"] = function () {
              return (Module["_firfilt_rrrf_destroy"] = Module["asm"]["Y"]).apply(null, arguments);
            };
            Module["_firfilt_rrrf_execute_block"] = function () {
              return (Module["_firfilt_rrrf_execute_block"] = Module["asm"]["Z"]).apply(null, arguments);
            };
            Module["_msresamp_rrrf_create"] = function () {
              return (Module["_msresamp_rrrf_create"] = Module["asm"]["_"]).apply(null, arguments);
            };
            Module["_resamp_rrrf_create"] = function () {
              return (Module["_resamp_rrrf_create"] = Module["asm"]["$"]).apply(null, arguments);
            };
            Module["_msresamp_rrrf_destroy"] = function () {
              return (Module["_msresamp_rrrf_destroy"] = Module["asm"]["aa"]).apply(null, arguments);
            };
            Module["_resamp_rrrf_destroy"] = function () {
              return (Module["_resamp_rrrf_destroy"] = Module["asm"]["ba"]).apply(null, arguments);
            };
            Module["_msresamp_rrrf_execute"] = function () {
              return (Module["_msresamp_rrrf_execute"] = Module["asm"]["ca"]).apply(null, arguments);
            };
            Module["_resamp_rrrf_execute_block"] = function () {
              return (Module["_resamp_rrrf_execute_block"] = Module["asm"]["da"]).apply(null, arguments);
            };
            Module["_estimate_req_filter_len"] = function () {
              return (Module["_estimate_req_filter_len"] = Module["asm"]["ea"]).apply(null, arguments);
            };
            Module["_liquid_firdes_kaiser"] = function () {
              return (Module["_liquid_firdes_kaiser"] = Module["asm"]["fa"]).apply(null, arguments);
            };
            Module["_fx_flac_size"] = function () {
              return (Module["_fx_flac_size"] = Module["asm"]["ga"]).apply(null, arguments);
            };
            Module["_fx_flac_init"] = function () {
              return (Module["_fx_flac_init"] = Module["asm"]["ha"]).apply(null, arguments);
            };
            Module["_fx_flac_reset"] = function () {
              return (Module["_fx_flac_reset"] = Module["asm"]["ia"]).apply(null, arguments);
            };
            Module["_fx_flac_get_state"] = function () {
              return (Module["_fx_flac_get_state"] = Module["asm"]["ja"]).apply(null, arguments);
            };
            Module["_fx_flac_get_streaminfo"] = function () {
              return (Module["_fx_flac_get_streaminfo"] = Module["asm"]["ka"]).apply(null, arguments);
            };
            Module["_fx_flac_alloc_default"] = function () {
              return (Module["_fx_flac_alloc_default"] = Module["asm"]["la"]).apply(null, arguments);
            };
            Module["_fx_flac_process"] = function () {
              return (Module["_fx_flac_process"] = Module["asm"]["ma"]).apply(null, arguments);
            };
            Module["_opus_decoder_create"] = function () {
              return (Module["_opus_decoder_create"] = Module["asm"]["oa"]).apply(null, arguments);
            };
            Module["_opus_decode"] = function () {
              return (Module["_opus_decode"] = Module["asm"]["pa"]).apply(null, arguments);
            };
            Module["_opus_decoder_destroy"] = function () {
              return (Module["_opus_decoder_destroy"] = Module["asm"]["qa"]).apply(null, arguments);
            };
            var ___getTypeName = Module["___getTypeName"] = function () {
              return (___getTypeName = Module["___getTypeName"] = Module["asm"]["ra"]).apply(null, arguments);
            };
            Module["___embind_register_native_and_builtin_types"] = function () {
              return (Module["___embind_register_native_and_builtin_types"] = Module["asm"]["sa"]).apply(null, arguments);
            };
            Module["_memcpy"] = function () {
              return (Module["_memcpy"] = Module["asm"]["ta"]).apply(null, arguments);
            };
            var stackSave = Module["stackSave"] = function () {
              return (stackSave = Module["stackSave"] = Module["asm"]["ua"]).apply(null, arguments);
            };
            var stackRestore = Module["stackRestore"] = function () {
              return (stackRestore = Module["stackRestore"] = Module["asm"]["va"]).apply(null, arguments);
            };
            var stackAlloc = Module["stackAlloc"] = function () {
              return (stackAlloc = Module["stackAlloc"] = Module["asm"]["wa"]).apply(null, arguments);
            };
            Module["dynCall_jiji"] = function () {
              return (Module["dynCall_jiji"] = Module["asm"]["xa"]).apply(null, arguments);
            };
            Module["ccall"] = ccall;
            Module["cwrap"] = cwrap;
            Module["setValue"] = setValue;
            Module["getValue"] = getValue;
            var calledRun;
            dependenciesFulfilled = function runCaller() {
              if (!calledRun) run();
              if (!calledRun) dependenciesFulfilled = runCaller;
            };
            function run(args) {
              if (runDependencies > 0) {
                return;
              }
              preRun();
              if (runDependencies > 0) {
                return;
              }
              function doRun() {
                if (calledRun) return;
                calledRun = true;
                Module["calledRun"] = true;
                if (ABORT) return;
                initRuntime();
                readyPromiseResolve(Module);
                if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
                postRun();
              }
              if (Module["setStatus"]) {
                Module["setStatus"]("Running...");
                setTimeout(function () {
                  setTimeout(function () {
                    Module["setStatus"]("");
                  }, 1);
                  doRun();
                }, 1);
              } else {
                doRun();
              }
            }
            Module["run"] = run;
            if (Module["preInit"]) {
              if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]];
              while (Module["preInit"].length > 0) {
                Module["preInit"].pop()();
              }
            }
            run();
            return jsDSPModule.ready;
          };
        }();
        var FoxenFlacDecoder = /*#__PURE__*/function () {
          function FoxenFlacDecoder(jsDSP) {
            _classCallCheck(this, FoxenFlacDecoder);
            this.flac = jsDSP._fx_flac_alloc_default();
            this.jsDSP = jsDSP;
            this.inbuf = jsDSP._malloc(16384);
            this.inptr = 0;
            this.inarr = new Uint8Array(jsDSP.HEAPU8.buffer, this.inbuf, 16384);
            this.outbuf = jsDSP._malloc(16384 * 4);
            this.outarr = new Int32Array(jsDSP.HEAPU8.buffer, this.outbuf, 16384);
            this.inlen = jsDSP._malloc(4);
            this.outlen = jsDSP._malloc(4);
          }
          _createClass(FoxenFlacDecoder, [{
            key: "decode",
            value: function decode(buf) {
              this.inarr.set(buf, this.inptr);
              var buflen = buf.length; // + this.inptr
              this.jsDSP.setValue(this.inlen, buflen, 'i32');
              this.jsDSP.setValue(this.outlen, 16384, 'i32');
              this.jsDSP._fx_flac_process(this.flac, this.inbuf, this.inlen, this.outbuf, this.outlen);
              var outlen = this.jsDSP.getValue(this.outlen, 'i32');
              var inlen = this.jsDSP.getValue(this.inlen, 'i32');
              // this.jsDSP._memcpy(this.inbuf, this.inbuf + inlen, buflen - inlen)
              this.inptr = buflen - inlen;

              // console.log(ret, inlen, buflen, outlen)
              var retarr = new Int16Array(outlen);
              for (var _i2 = 0; _i2 < outlen; _i2++) {
                retarr[_i2] = this.outarr[_i2] >>> 16;
              }
              return retarr;
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.jsDSP._free(this.flac);
            }
          }]);
          return FoxenFlacDecoder;
        }();
        var jsDSPWasm = "/assets/jsDSP-2684bc7b.wasm";
        var jsDSPMem = "/assets/jsDSPnoWasm.js-e7d1f77b.mem";

        // https://stackoverflow.com/questions/47879864/how-can-i-check-if-a-browser-supports-webassembly
        var hasWasm = function () {
          try {
            if ((typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) === 'object' && typeof WebAssembly.instantiate === 'function') {
              var _module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
              if (_module instanceof WebAssembly.Module) {
                return new WebAssembly.Instance(_module) instanceof WebAssembly.Instance;
              }
            }
          } catch (e) {}
          return false;
        }();
        if (!window.crypto) {
          window.crypto = window.msCrypto;
        }
        var jsDSP;
        var LiquidDSP;
        var ZSTDSimpleDecode;
        function createFlacDecoder() {
          return new FoxenFlacDecoder(jsDSP);
        }
        function createOpusDecoder(samplerate) {
          var decoder = new OpusWasmDecoder(samplerate);
          return decoder;
        }
        var OpusWasmDecoder = /*#__PURE__*/function () {
          function OpusWasmDecoder(samplerate) {
            _classCallCheck(this, OpusWasmDecoder);
            this.err = jsDSP._malloc(4);
            this.opusout = jsDSP._malloc(2048);
            this.opusin = jsDSP._malloc(2048);
            this.opusinarr = new Uint8Array(jsDSP.HEAPU8.buffer, this.opusin, 2048);
            this.opusoutarr = new Uint16Array(jsDSP.HEAPU8.buffer, this.opusout, 2048 / 2);
            this.decoder = jsDSP._opus_decoder_create(samplerate, 1, this.err);
            this.first = true;
          }
          _createClass(OpusWasmDecoder, [{
            key: "decode",
            value: function decode(array) {
              this.opusinarr.set(array);
              var decoded = jsDSP._opus_decode(this.decoder, this.opusin, array.length, this.opusout, 16384, 0);
              return new Int16Array(this.opusoutarr.slice(0, decoded));
            }
          }, {
            key: "destroy",
            value: function destroy() {
              jsDSP._free(this.err);
              jsDSP._free(this.opusin);
              jsDSP._free(this.opusout);
              jsDSP._opus_decoder_destroy(this.decoder);
            }
          }]);
          return OpusWasmDecoder;
        }();
        var zstdPromise = function zstdInit() {
          if (hasWasm) {
            var decoder = new Q();
            return decoder.init().then(function () {
              ZSTDSimpleDecode = function ZSTDSimpleDecode(ZSTDEncoded) {
                return decoder.decode(ZSTDEncoded);
              };
            });
          } else {
            ZSTDSimpleDecode = function ZSTDSimpleDecode(ZSTDEncoded) {
              return decompress(ZSTDEncoded);
            };
            return Promise.resolve(fzstd);
          }
        }();
        var jsDSPOptions = {
          locateFile: function locateFile(path, prefix) {
            // if it's a mem init file, use a custom dir
            if (path.endsWith('.mem')) return jsDSPMem;
            if (path.endsWith('.wasm')) return jsDSPWasm;
            // otherwise, use the default, the prefix (JS file's dir) + the path
            return prefix + path;
          }
        };
        var jsDSPPromise = function initjsDSP() {
          if (hasWasm) {
            return jsDSPModule(jsDSPOptions).then(function (jsDSPModule) {
              jsDSP = jsDSPModule;
              LiquidDSP = getLiquidDSP(jsDSPModule);
              return LiquidDSP;
            });
          } else {
            window.Atomics = window.Atomics || {
              add: function add(typedArray, index, value) {
                var val = typedArray[index];
                typedArray[index] += value;
                return val;
              },
              and: function and(typedArray, index, value) {
                var val = typedArray[index];
                typedArray[index] &= value;
                return val;
              },
              exchange: function exchange(typedArray, index, value) {
                var val = typedArray[index];
                typedArray[index] = value;
                return val;
              },
              load: function load(typedArray, index) {
                return typedArray[index];
              },
              or: function or(typedArray, index, value) {
                var val = typedArray[index];
                typedArray[index] |= value;
                return val;
              },
              store: function store(typedArray, index, value) {
                typedArray[index] = value;
                return value;
              },
              sub: function sub(typedArray, index, value) {
                var val = typedArray[index];
                typedArray[index] -= value;
                return val;
              },
              xor: function xor(typedArray, index, value) {
                var val = typedArray[index];
                typedArray[index] ^= value;
                return val;
              }
            };
            return __vitePreload(function () {
              return module.import('./jsDSPnoWasm-legacy-f0bf7800.js');
            }, false ? "__VITE_PRELOAD__" : void 0).then(function (jsDSP) {
              return jsDSP.default(jsDSPOptions);
            }).then(function (jsDSPModule) {
              jsDSP = jsDSPModule;
              LiquidDSP = getLiquidDSP(jsDSPModule);
              return LiquidDSP;
            });
          }
        }();
        function liquidDSPMsResampCreateJS(_x2, _x3, _x4) {
          return _liquidDSPMsResampCreateJS.apply(this, arguments);
        }
        function _liquidDSPMsResampCreateJS() {
          _liquidDSPMsResampCreateJS = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(fromSamplerate, toSampleRate, channels) {
            var resampler;
            return _regeneratorRuntime().wrap(function _callee16$(_context16) {
              while (1) {
                switch (_context16.prev = _context16.next) {
                  case 0:
                    resampler = new LiquidDSP.MsResamp(toSampleRate / fromSamplerate, 60);
                    resampler.resample = resampler.execute;
                    return _context16.abrupt("return", resampler);
                  case 3:
                  case "end":
                    return _context16.stop();
                }
              }
            }, _callee16);
          }));
          return _liquidDSPMsResampCreateJS.apply(this, arguments);
        }
        var createResampler = liquidDSPMsResampCreateJS;
        var ZstdWaterfallDecoder = /*#__PURE__*/function () {
          function ZstdWaterfallDecoder() {
            _classCallCheck(this, ZstdWaterfallDecoder);
          }
          _createClass(ZstdWaterfallDecoder, [{
            key: "decode",
            value: function decode(array) {
              var compressedArray = new Uint8Array(array).subarray(8);
              var header = new Uint32Array(array.slice(0, 8));
              array = new Int8Array(ZSTDSimpleDecode(compressedArray));
              return [[array, header[0], header[1]]];
            }
          }]);
          return ZstdWaterfallDecoder;
        }();
        var AV1WaterfallDecoder = /*#__PURE__*/function () {
          function AV1WaterfallDecoder() {
            _classCallCheck(this, AV1WaterfallDecoder);
            this.dav1d = new jsDSP.Dav1dDecoder();
          }
          _createClass(AV1WaterfallDecoder, [{
            key: "decode",
            value: function decode(array) {
              var decoded = this.dav1d.dav1d_decode(new Uint8Array(array));
              this.dav1d.dav1d_picture_free();
              if (typeof decoded === 'string') {
                console.log(decoded);
                return [];
              }
              var waterfallArr = [];
              var metadata = new Uint32Array(ZSTDSimpleDecode(decoded.itut_t35).slice(0).buffer);
              for (var _i3 = 0; _i3 < decoded.height; _i3++) {
                var arr = new Int8Array(metadata[_i3 * 4 + 2]);
                var stride = decoded.stride[0];
                for (var _j = 0; _j < arr.length; _j++) {
                  arr[_j] = decoded.plane[0][stride * _i3 + _j] ^ 0x80;
                }
                waterfallArr.push([arr, metadata[_i3 * 4 + 0], metadata[_i3 * 4 + 1]]);
              }
              return waterfallArr;
            }
          }]);
          return AV1WaterfallDecoder;
        }();
        function initWrappers() {
          return _initWrappers.apply(this, arguments);
        }
        function _initWrappers() {
          _initWrappers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
            return _regeneratorRuntime().wrap(function _callee17$(_context17) {
              while (1) {
                switch (_context17.prev = _context17.next) {
                  case 0:
                    return _context17.abrupt("return", Promise.all([zstdPromise, jsDSPPromise]));
                  case 1:
                  case "end":
                    return _context17.stop();
                }
              }
            }, _callee17);
          }));
          return _initWrappers.apply(this, arguments);
        }
        function getNoiseProcessors(jsDSP) {
          var wdsp_anr_create = jsDSP.cwrap('wdsp_anr_create', 'number', ['number', 'number', 'number', 'number', 'number']);
          var wdsp_anr_destroy = jsDSP.cwrap('wdsp_anr_destroy', 'void', ['number']);
          var WdspANR = /*#__PURE__*/function () {
            function WdspANR(nr_type, taps, dly, gain, leakage) {
              _classCallCheck(this, WdspANR);
              this.nr_type = nr_type;
              this.wdsp_anr = wdsp_anr_create(nr_type, taps, dly, gain, leakage);
              this.fptr = jsDSP._malloc(16384 * 4);
              this.farr = new Float32Array(jsDSP.HEAPU8.buffer, this.fptr, 16384);
            }
            _createClass(WdspANR, [{
              key: "filter",
              value: function filter(arr) {
                this.farr.set(arr);
                jsDSP._wdsp_anr_filter(this.wdsp_anr, this.nr_type, arr.length, this.fptr, this.fptr);
                arr.set(this.farr.subarray(0, arr.length));
                return arr;
              }
            }, {
              key: "destroy",
              value: function destroy() {
                jsDSP._free(this.fptr);
                wdsp_anr_destroy(this.wdsp_anr);
              }
            }]);
            return WdspANR;
          }();
          var wild_nb_init = jsDSP.cwrap('wild_nb_init', 'number', ['number', 'number', 'number']);
          var wild_nb_destroy = jsDSP.cwrap('wild_nb_destroy', 'void', ['number']);
          var WildNB = /*#__PURE__*/function () {
            function WildNB(thresh, taps, samples) {
              _classCallCheck(this, WildNB);
              this.wild_nb = wild_nb_init(thresh, taps, samples);
              this.fptr = jsDSP._malloc(16384 * 4);
              this.farr = new Float32Array(jsDSP.HEAPU8.buffer, this.fptr, 16384);
            }
            _createClass(WildNB, [{
              key: "filter",
              value: function filter(arr) {
                this.farr.set(arr);
                jsDSP._wild_nb_blank(this.wild_nb, arr.length, this.fptr);
                arr.set(this.farr.subarray(0, arr.length));
                return arr;
              }
            }, {
              key: "destroy",
              value: function destroy() {
                jsDSP._free(this.fptr);
                wild_nb_destroy(this.wild_nb);
              }
            }]);
            return WildNB;
          }();
          var nr_spectral_init = jsDSP.cwrap('nr_spectral_init', 'number', ['number', 'number', 'number', 'number']);
          var nr_spectral_destroy = jsDSP.cwrap('wild_nb_destroy', 'void', ['number']);
          var SpectralNR = /*#__PURE__*/function () {
            function SpectralNR(snd_rate, gain, alpha, asnr) {
              _classCallCheck(this, SpectralNR);
              this.spectral_nr = nr_spectral_init(snd_rate, gain, alpha, asnr);
              this.fptr = jsDSP._malloc(16384 * 4);
              this.farr = new Float32Array(jsDSP.HEAPU8.buffer, this.fptr, 16384);
            }
            _createClass(SpectralNR, [{
              key: "filter",
              value: function filter(arr) {
                this.farr.set(arr);
                jsDSP._nr_spectral_process(this.spectral_nr, arr.length, this.fptr, this.fptr);
                arr.set(this.farr.subarray(0, arr.length));
                return arr;
              }
            }, {
              key: "destroy",
              value: function destroy() {
                jsDSP._free(this.fptr);
                nr_spectral_destroy(this.spectral_nr);
              }
            }]);
            return SpectralNR;
          }();
          var noise = {};
          noise.WdspANR = WdspANR;
          noise.WildNB = WildNB;
          noise.SpectralNR = SpectralNR;
          return noise;
        }
        var AudioProcessor = /*#__PURE__*/function () {
          function AudioProcessor() {
            _classCallCheck(this, AudioProcessor);
            this.NoiseProcessors = getNoiseProcessors(jsDSP);
            this.nrobj = new this.NoiseProcessors.WdspANR(1, 64, 32, 1.024e-4, 1.28e-1);
            this.anobj = new this.NoiseProcessors.WdspANR(0, 64, 32, 1.024e-4, 1.28e-1);
            this.nbobj = new this.NoiseProcessors.WildNB(0.95, 10, 7);
            // this.nrobj = new this.NoiseProcessors.SpectralNR(12000, 1, 0.95, 1000)

            this.nr = false;
            this.an = false;
            this.nb = false;
          }
          _createClass(AudioProcessor, [{
            key: "process",
            value: function process(arr) {
              if (this.nr) arr = this.nrobj.filter(arr);
              if (this.nb) arr = this.nbobj.filter(arr);
              if (this.an) arr = this.anobj.filter(arr);
              return arr;
            }
          }, {
            key: "setNR",
            value: function setNR(nr) {
              this.nr = nr;
            }
          }, {
            key: "setNB",
            value: function setNB(nb) {
              this.nb = nb;
            }
          }, {
            key: "setAN",
            value: function setAN(an) {
              this.an = an;
            }
          }]);
          return AudioProcessor;
        }();
        var LiveMovingAverage = {
          push: function push(val) {
            if ('number' !== typeof val) throw new Error('val must be a number.');
            this.sum -= this.data[this.dataI];
            this.sum += val;
            this.data[this.dataI] = val;
            this.dataI = (this.dataI + 1) % this.size;
            return this;
          },
          get: function get() {
            return this.sum / this.size;
          }
        };
        var createWindow$1 = function createWindow$1(size) {
          var fill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          if ('number' !== typeof size) throw new Error('size must be a number.');
          if ('number' !== typeof fill) throw new Error('fill must be a number.');
          var w = Object.create(LiveMovingAverage);
          w.sum = size * fill;
          w.size = size;
          w.data = new Array(size);
          w.data.fill(fill);
          w.dataI = 0;
          return w;
        };
        var liveMovingAverage = createWindow$1;
        var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {
          return {
            endTime: endTime,
            insertTime: insertTime,
            type: 'exponentialRampToValue',
            value: value
          };
        };
        var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {
          return {
            endTime: endTime,
            insertTime: insertTime,
            type: 'linearRampToValue',
            value: value
          };
        };
        var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {
          return {
            startTime: startTime,
            type: 'setValue',
            value: value
          };
        };
        var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {
          return {
            duration: duration,
            startTime: startTime,
            type: 'setValueCurve',
            values: values
          };
        };
        var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref12) {
          var startTime = _ref12.startTime,
            target = _ref12.target,
            timeConstant = _ref12.timeConstant;
          return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);
        };
        var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {
          return automationEvent.type === 'exponentialRampToValue';
        };
        var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {
          return automationEvent.type === 'linearRampToValue';
        };
        var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {
          return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);
        };
        var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {
          return automationEvent.type === 'setValue';
        };
        var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {
          return automationEvent.type === 'setValueCurve';
        };
        var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {
          var automationEvent = automationEvents[index];
          return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);
        };
        var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {
          return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];
        };
        var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {
          return automationEvent.type === 'cancelAndHold';
        };
        var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {
          return automationEvent.type === 'cancelScheduledValues';
        };
        var getEventTime = function getEventTime(automationEvent) {
          if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
            return automationEvent.cancelTime;
          }
          if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {
            return automationEvent.endTime;
          }
          return automationEvent.startTime;
        };
        var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref13) {
          var endTime = _ref13.endTime,
            value = _ref13.value;
          if (valueAtStartTime === value) {
            return value;
          }
          if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {
            return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));
          }
          return 0;
        };
        var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref14) {
          var endTime = _ref14.endTime,
            value = _ref14.value;
          return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);
        };
        var interpolateValue = function interpolateValue(values, theoreticIndex) {
          var lowerIndex = Math.floor(theoreticIndex);
          var upperIndex = Math.ceil(theoreticIndex);
          if (lowerIndex === upperIndex) {
            return values[lowerIndex];
          }
          return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];
        };
        var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref15) {
          var duration = _ref15.duration,
            startTime = _ref15.startTime,
            values = _ref15.values;
          var theoreticIndex = (time - startTime) / duration * (values.length - 1);
          return interpolateValue(values, theoreticIndex);
        };
        var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {
          return automationEvent.type === 'setTarget';
        };
        var AutomationEventList = /*#__PURE__*/function (_Symbol$iterator) {
          function AutomationEventList(defaultValue) {
            _classCallCheck(this, AutomationEventList);
            this._automationEvents = [];
            this._currenTime = 0;
            this._defaultValue = defaultValue;
          }
          _createClass(AutomationEventList, [{
            key: _Symbol$iterator,
            value: function value() {
              return this._automationEvents[Symbol.iterator]();
            }
          }, {
            key: "add",
            value: function add(automationEvent) {
              var eventTime = getEventTime(automationEvent);
              if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
                var index = this._automationEvents.findIndex(function (currentAutomationEvent) {
                  if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {
                    return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;
                  }
                  return getEventTime(currentAutomationEvent) >= eventTime;
                });
                var removedAutomationEvent = this._automationEvents[index];
                if (index !== -1) {
                  this._automationEvents = this._automationEvents.slice(0, index);
                }
                if (isCancelAndHoldAutomationEvent(automationEvent)) {
                  var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];
                  if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {
                    if (isSetTargetAutomationEvent(lastAutomationEvent)) {
                      throw new Error('The internal list is malformed.');
                    }
                    var startTime = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);
                    var startValue = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;
                    var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);
                    var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);
                    this._automationEvents.push(truncatedAutomationEvent);
                  }
                  if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {
                    this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));
                  }
                  if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {
                    this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(new Float32Array([6, 7]), lastAutomationEvent.startTime, eventTime - lastAutomationEvent.startTime);
                  }
                }
              } else {
                var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {
                  return getEventTime(currentAutomationEvent) > eventTime;
                });
                var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];
                if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {
                  return false;
                }
                var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;
                if (_index === -1) {
                  this._automationEvents.push(persistentAutomationEvent);
                } else {
                  if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {
                    return false;
                  }
                  this._automationEvents.splice(_index, 0, persistentAutomationEvent);
                }
              }
              return true;
            }
          }, {
            key: "flush",
            value: function flush(time) {
              var index = this._automationEvents.findIndex(function (currentAutomationEvent) {
                return getEventTime(currentAutomationEvent) > time;
              });
              if (index > 1) {
                var remainingAutomationEvents = this._automationEvents.slice(index - 1);
                var firstRemainingAutomationEvent = remainingAutomationEvents[0];
                if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {
                  remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));
                }
                this._automationEvents = remainingAutomationEvents;
              }
            }
          }, {
            key: "getValue",
            value: function getValue(time) {
              if (this._automationEvents.length === 0) {
                return this._defaultValue;
              }
              var indexOfNextEvent = this._automationEvents.findIndex(function (automationEvent) {
                return getEventTime(automationEvent) > time;
              });
              var nextAutomationEvent = this._automationEvents[indexOfNextEvent];
              var indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;
              var currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];
              if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {
                return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);
              }
              if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
                return currentAutomationEvent.value;
              }
              if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {
                if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {
                  return getValueCurveValueAtTime(time, currentAutomationEvent);
                }
                return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];
              }
              if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
                return currentAutomationEvent.value;
              }
              if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {
                var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),
                  _getEndTimeAndValueOf2 = _slicedToArray(_getEndTimeAndValueOf, 2),
                  startTime = _getEndTimeAndValueOf2[0],
                  value = _getEndTimeAndValueOf2[1];
                return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);
              }
              if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {
                var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),
                  _getEndTimeAndValueOf4 = _slicedToArray(_getEndTimeAndValueOf3, 2),
                  _startTime = _getEndTimeAndValueOf4[0],
                  _value = _getEndTimeAndValueOf4[1];
                return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);
              }
              return this._defaultValue;
            }
          }]);
          return AutomationEventList;
        }(Symbol.iterator);
        var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {
          return {
            cancelTime: cancelTime,
            type: 'cancelAndHold'
          };
        };
        var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {
          return {
            cancelTime: cancelTime,
            type: 'cancelScheduledValues'
          };
        };
        var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {
          return {
            endTime: endTime,
            type: 'exponentialRampToValue',
            value: value
          };
        };
        var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {
          return {
            endTime: endTime,
            type: 'linearRampToValue',
            value: value
          };
        };
        var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {
          return {
            startTime: startTime,
            target: target,
            timeConstant: timeConstant,
            type: 'setTarget'
          };
        };
        var createAddActiveInputConnectionToAudioNode = function createAddActiveInputConnectionToAudioNode(insertElementInSet) {
          return function (activeInputs, source, _ref16, ignoreDuplicates) {
            var _ref17 = _slicedToArray(_ref16, 3),
              output = _ref17[0],
              input = _ref17[1],
              eventListener = _ref17[2];
            insertElementInSet(activeInputs[input], [source, output, eventListener], function (activeInputConnection) {
              return activeInputConnection[0] === source && activeInputConnection[1] === output;
            }, ignoreDuplicates);
          };
        };
        var createAddAudioNodeConnections = function createAddAudioNodeConnections(audioNodeConnectionsStore) {
          return function (audioNode, audioNodeRenderer, nativeAudioNode) {
            var activeInputs = [];
            for (var _i4 = 0; _i4 < nativeAudioNode.numberOfInputs; _i4 += 1) {
              activeInputs.push(new Set());
            }
            audioNodeConnectionsStore.set(audioNode, {
              activeInputs: activeInputs,
              outputs: new Set(),
              passiveInputs: new WeakMap(),
              renderer: audioNodeRenderer
            });
          };
        };
        var createAddAudioParamConnections = function createAddAudioParamConnections(audioParamConnectionsStore) {
          return function (audioParam, audioParamRenderer) {
            audioParamConnectionsStore.set(audioParam, {
              activeInputs: new Set(),
              passiveInputs: new WeakMap(),
              renderer: audioParamRenderer
            });
          };
        };
        var ACTIVE_AUDIO_NODE_STORE = new WeakSet();
        var AUDIO_NODE_CONNECTIONS_STORE = new WeakMap();
        var AUDIO_NODE_STORE = new WeakMap();
        var AUDIO_PARAM_CONNECTIONS_STORE = new WeakMap();
        var AUDIO_PARAM_STORE = new WeakMap();
        var CONTEXT_STORE = new WeakMap();
        var EVENT_LISTENERS = new WeakMap();
        var CYCLE_COUNTERS = new WeakMap();
        var getValueForKey = function getValueForKey(map, key) {
          var value = map.get(key);
          if (value === undefined) {
            throw new Error('A value with the given key could not be found.');
          }
          return value;
        };
        var pickElementFromSet = function pickElementFromSet(set, predicate) {
          var matchingElements = Array.from(set).filter(predicate);
          if (matchingElements.length > 1) {
            throw Error('More than one element was found.');
          }
          if (matchingElements.length === 0) {
            throw Error('No element was found.');
          }
          var _matchingElements = _slicedToArray(matchingElements, 1),
            matchingElement = _matchingElements[0];
          set.delete(matchingElement);
          return matchingElement;
        };
        var deletePassiveInputConnectionToAudioNode = function deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input) {
          var passiveInputConnections = getValueForKey(passiveInputs, source);
          var matchingConnection = pickElementFromSet(passiveInputConnections, function (passiveInputConnection) {
            return passiveInputConnection[0] === output && passiveInputConnection[1] === input;
          });
          if (passiveInputConnections.size === 0) {
            passiveInputs.delete(source);
          }
          return matchingConnection;
        };
        var getEventListenersOfAudioNode = function getEventListenersOfAudioNode(audioNode) {
          return getValueForKey(EVENT_LISTENERS, audioNode);
        };
        var setInternalStateToActive = function setInternalStateToActive(audioNode) {
          if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {
            throw new Error('The AudioNode is already stored.');
          }
          ACTIVE_AUDIO_NODE_STORE.add(audioNode);
          getEventListenersOfAudioNode(audioNode).forEach(function (eventListener) {
            return eventListener(true);
          });
        };
        var isAudioWorkletNode = function isAudioWorkletNode(audioNode) {
          return 'port' in audioNode;
        };
        var setInternalStateToPassive = function setInternalStateToPassive(audioNode) {
          if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {
            throw new Error('The AudioNode is not stored.');
          }
          ACTIVE_AUDIO_NODE_STORE.delete(audioNode);
          getEventListenersOfAudioNode(audioNode).forEach(function (eventListener) {
            return eventListener(false);
          });
        };

        // Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.
        var setInternalStateToPassiveWhenNecessary = function setInternalStateToPassiveWhenNecessary(audioNode, activeInputs) {
          if (!isAudioWorkletNode(audioNode) && activeInputs.every(function (connections) {
            return connections.size === 0;
          })) {
            setInternalStateToPassive(audioNode);
          }
        };
        var createAddConnectionToAudioNode = function createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode) {
          var tailTimeTimeoutIds = new WeakMap();
          return function (source, destination, output, input, isOffline) {
            var _getAudioNodeConnecti = getAudioNodeConnections(destination),
              activeInputs = _getAudioNodeConnecti.activeInputs,
              passiveInputs = _getAudioNodeConnecti.passiveInputs;
            var _getAudioNodeConnecti2 = getAudioNodeConnections(source),
              outputs = _getAudioNodeConnecti2.outputs;
            var eventListeners = getEventListenersOfAudioNode(source);
            var eventListener = function eventListener(isActive) {
              var nativeDestinationAudioNode = getNativeAudioNode(destination);
              var nativeSourceAudioNode = getNativeAudioNode(source);
              if (isActive) {
                var partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);
                addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);
                if (!isOffline && !isPartOfACycle(source)) {
                  connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);
                }
                if (isPassiveAudioNode(destination)) {
                  setInternalStateToActive(destination);
                }
              } else {
                var _partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);
                addPassiveInputConnectionToAudioNode(passiveInputs, input, _partialConnection, false);
                if (!isOffline && !isPartOfACycle(source)) {
                  disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);
                }
                var tailTime = getAudioNodeTailTime(destination);
                if (tailTime === 0) {
                  if (isActiveAudioNode(destination)) {
                    setInternalStateToPassiveWhenNecessary(destination, activeInputs);
                  }
                } else {
                  var tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);
                  if (tailTimeTimeoutId !== undefined) {
                    clearTimeout(tailTimeTimeoutId);
                  }
                  tailTimeTimeoutIds.set(destination, setTimeout(function () {
                    if (isActiveAudioNode(destination)) {
                      setInternalStateToPassiveWhenNecessary(destination, activeInputs);
                    }
                  }, tailTime * 1000));
                }
              }
            };
            if (insertElementInSet(outputs, [destination, output, input], function (outputConnection) {
              return outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input;
            }, true)) {
              eventListeners.add(eventListener);
              if (isActiveAudioNode(source)) {
                addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);
              } else {
                addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);
              }
              return true;
            }
            return false;
          };
        };
        var createAddPassiveInputConnectionToAudioNode = function createAddPassiveInputConnectionToAudioNode(insertElementInSet) {
          return function (passiveInputs, input, _ref18, ignoreDuplicates) {
            var _ref19 = _slicedToArray(_ref18, 3),
              source = _ref19[0],
              output = _ref19[1],
              eventListener = _ref19[2];
            var passiveInputConnections = passiveInputs.get(source);
            if (passiveInputConnections === undefined) {
              passiveInputs.set(source, new Set([[output, input, eventListener]]));
            } else {
              insertElementInSet(passiveInputConnections, [output, input, eventListener], function (passiveInputConnection) {
                return passiveInputConnection[0] === output && passiveInputConnection[1] === input;
              }, ignoreDuplicates);
            }
          };
        };
        var createAddSilentConnection = function createAddSilentConnection(createNativeGainNode) {
          return function (nativeContext, nativeAudioScheduledSourceNode) {
            var nativeGainNode = createNativeGainNode(nativeContext, {
              channelCount: 1,
              channelCountMode: 'explicit',
              channelInterpretation: 'discrete',
              gain: 0
            });
            nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);
            var disconnect = function disconnect() {
              nativeAudioScheduledSourceNode.removeEventListener('ended', disconnect);
              nativeAudioScheduledSourceNode.disconnect(nativeGainNode);
              nativeGainNode.disconnect();
            };
            nativeAudioScheduledSourceNode.addEventListener('ended', disconnect);
          };
        };
        var isOwnedByContext = function isOwnedByContext(nativeAudioNode, nativeContext) {
          return nativeAudioNode.context === nativeContext;
        };
        var testAudioBufferCopyChannelMethodsOutOfBoundsSupport = function testAudioBufferCopyChannelMethodsOutOfBoundsSupport(nativeAudioBuffer) {
          try {
            nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);
          } catch (_unused) {
            return false;
          }
          return true;
        };
        var createIndexSizeError = function createIndexSizeError() {
          return new DOMException('', 'IndexSizeError');
        };
        var wrapAudioBufferGetChannelDataMethod = function wrapAudioBufferGetChannelDataMethod(audioBuffer) {
          audioBuffer.getChannelData = function (getChannelData) {
            return function (channel) {
              try {
                return getChannelData.call(audioBuffer, channel);
              } catch (err) {
                if (err.code === 12) {
                  throw createIndexSizeError();
                }
                throw err;
              }
            };
          }(audioBuffer.getChannelData);
        };
        var DEFAULT_OPTIONS$5 = {
          numberOfChannels: 1
        };
        var createAudioBufferConstructor = function createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) {
          var nativeOfflineAudioContext = null;
          return /*#__PURE__*/function (_Symbol$hasInstance) {
            function AudioBuffer(options) {
              _classCallCheck(this, AudioBuffer);
              if (nativeOfflineAudioContextConstructor === null) {
                throw new Error('Missing the native OfflineAudioContext constructor.');
              }
              var _DEFAULT_OPTIONS$5$op = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS$5), options),
                length = _DEFAULT_OPTIONS$5$op.length,
                numberOfChannels = _DEFAULT_OPTIONS$5$op.numberOfChannels,
                sampleRate = _DEFAULT_OPTIONS$5$op.sampleRate;
              if (nativeOfflineAudioContext === null) {
                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);
              }
              /*
               * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the
               * factory function. But since Firefox also supports the constructor everything should be fine.
               */
              var audioBuffer = nativeAudioBufferConstructor !== null && cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor({
                length: length,
                numberOfChannels: numberOfChannels,
                sampleRate: sampleRate
              }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);
              // Bug #99: Safari does not throw an error when the numberOfChannels is zero.
              if (audioBuffer.numberOfChannels === 0) {
                throw createNotSupportedError();
              }
              // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
              // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.
              if (typeof audioBuffer.copyFromChannel !== 'function') {
                wrapAudioBufferCopyChannelMethods(audioBuffer);
                wrapAudioBufferGetChannelDataMethod(audioBuffer);
                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.
              } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, function () {
                return testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer);
              })) {
                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);
              }
              audioBufferStore.add(audioBuffer);
              /*
               * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native
               * (Offline)AudioContexts.
               */
              return audioBuffer;
            }
            _createClass(AudioBuffer, null, [{
              key: _Symbol$hasInstance,
              value: function value(instance) {
                return instance !== null && _typeof(instance) === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype || audioBufferStore.has(instance);
              }
            }]);
            return AudioBuffer;
          }(Symbol.hasInstance);
        };
        var MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;
        var MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;
        var isActiveAudioNode = function isActiveAudioNode(audioNode) {
          return ACTIVE_AUDIO_NODE_STORE.has(audioNode);
        };
        var DEFAULT_OPTIONS$4 = {
          buffer: null,
          channelCount: 2,
          channelCountMode: 'max',
          channelInterpretation: 'speakers',
          // Bug #149: Safari does not yet support the detune AudioParam.
          loop: false,
          loopEnd: 0,
          loopStart: 0,
          playbackRate: 1
        };
        var createAudioBufferSourceNodeConstructor = function createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) {
          return /*#__PURE__*/function (_audioNodeConstructor) {
            _inherits(AudioBufferSourceNode, _audioNodeConstructor);
            var _super3 = _createSuper(AudioBufferSourceNode);
            function AudioBufferSourceNode(context, options) {
              var _this12;
              _classCallCheck(this, AudioBufferSourceNode);
              var nativeContext = getNativeContext(context);
              var mergedOptions = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS$4), options);
              var nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);
              var isOffline = isNativeOfflineAudioContext(nativeContext);
              var audioBufferSourceNodeRenderer = isOffline ? createAudioBufferSourceNodeRenderer() : null;
              _this12 = _super3.call(this, context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);
              _this12._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;
              _this12._isBufferNullified = false;
              _this12._isBufferSet = mergedOptions.buffer !== null;
              _this12._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;
              _this12._onended = null;
              // Bug #73: Safari does not export the correct values for maxValue and minValue.
              _this12._playbackRate = createAudioParam(_assertThisInitialized2(_this12), isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
              return _this12;
            }
            _createClass(AudioBufferSourceNode, [{
              key: "buffer",
              get: function get() {
                if (this._isBufferNullified) {
                  return null;
                }
                return this._nativeAudioBufferSourceNode.buffer;
              },
              set: function set(value) {
                this._nativeAudioBufferSourceNode.buffer = value;
                // Bug #72: Only Chrome & Edge do not allow to reassign the buffer yet.
                if (value !== null) {
                  if (this._isBufferSet) {
                    throw createInvalidStateError();
                  }
                  this._isBufferSet = true;
                }
              }
            }, {
              key: "loop",
              get: function get() {
                return this._nativeAudioBufferSourceNode.loop;
              },
              set: function set(value) {
                this._nativeAudioBufferSourceNode.loop = value;
              }
            }, {
              key: "loopEnd",
              get: function get() {
                return this._nativeAudioBufferSourceNode.loopEnd;
              },
              set: function set(value) {
                this._nativeAudioBufferSourceNode.loopEnd = value;
              }
            }, {
              key: "loopStart",
              get: function get() {
                return this._nativeAudioBufferSourceNode.loopStart;
              },
              set: function set(value) {
                this._nativeAudioBufferSourceNode.loopStart = value;
              }
            }, {
              key: "onended",
              get: function get() {
                return this._onended;
              },
              set: function set(value) {
                var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;
                this._nativeAudioBufferSourceNode.onended = wrappedListener;
                var nativeOnEnded = this._nativeAudioBufferSourceNode.onended;
                this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
              }
            }, {
              key: "playbackRate",
              get: function get() {
                return this._playbackRate;
              }
            }, {
              key: "start",
              value: function start() {
                var _this13 = this;
                var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var duration = arguments.length > 2 ? arguments[2] : undefined;
                this._nativeAudioBufferSourceNode.start(when, offset, duration);
                if (this._audioBufferSourceNodeRenderer !== null) {
                  this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];
                }
                if (this.context.state !== 'closed') {
                  setInternalStateToActive(this);
                  var resetInternalStateToPassive = function resetInternalStateToPassive() {
                    _this13._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);
                    if (isActiveAudioNode(_this13)) {
                      setInternalStateToPassive(_this13);
                    }
                  };
                  this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);
                }
              }
            }, {
              key: "stop",
              value: function stop() {
                var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                this._nativeAudioBufferSourceNode.stop(when);
                if (this._audioBufferSourceNodeRenderer !== null) {
                  this._audioBufferSourceNodeRenderer.stop = when;
                }
              }
            }]);
            return AudioBufferSourceNode;
          }(audioNodeConstructor);
        };
        var createAudioBufferSourceNodeRendererFactory = function createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {
          return function () {
            var renderedNativeAudioBufferSourceNodes = new WeakMap();
            var start = null;
            var stop = null;
            var createAudioBufferSourceNode = /*#__PURE__*/function () {
              var _ref20 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(proxy, nativeOfflineAudioContext) {
                var nativeAudioBufferSourceNode, nativeAudioBufferSourceNodeIsOwnedByContext, options, _nativeAudioBufferSou;
                return _regeneratorRuntime().wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        nativeAudioBufferSourceNode = getNativeAudioNode(proxy);
                        /*
                         * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created
                         * again.
                         */
                        nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);
                        if (!nativeAudioBufferSourceNodeIsOwnedByContext) {
                          options = {
                            buffer: nativeAudioBufferSourceNode.buffer,
                            channelCount: nativeAudioBufferSourceNode.channelCount,
                            channelCountMode: nativeAudioBufferSourceNode.channelCountMode,
                            channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,
                            // Bug #149: Safari does not yet support the detune AudioParam.
                            loop: nativeAudioBufferSourceNode.loop,
                            loopEnd: nativeAudioBufferSourceNode.loopEnd,
                            loopStart: nativeAudioBufferSourceNode.loopStart,
                            playbackRate: nativeAudioBufferSourceNode.playbackRate.value
                          };
                          nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);
                          if (start !== null) {
                            (_nativeAudioBufferSou = nativeAudioBufferSourceNode).start.apply(_nativeAudioBufferSou, _toConsumableArray(start));
                          }
                          if (stop !== null) {
                            nativeAudioBufferSourceNode.stop(stop);
                          }
                        }
                        renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);
                        if (nativeAudioBufferSourceNodeIsOwnedByContext) {
                          _context.next = 9;
                          break;
                        }
                        _context.next = 7;
                        return renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);
                      case 7:
                        _context.next = 11;
                        break;
                      case 9:
                        _context.next = 11;
                        return connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);
                      case 11:
                        _context.next = 13;
                        return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);
                      case 13:
                        return _context.abrupt("return", nativeAudioBufferSourceNode);
                      case 14:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));
              return function createAudioBufferSourceNode(_x5, _x6) {
                return _ref20.apply(this, arguments);
              };
            }();
            return {
              set start(value) {
                start = value;
              },
              set stop(value) {
                stop = value;
              },
              render: function render(proxy, nativeOfflineAudioContext) {
                var renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);
                if (renderedNativeAudioBufferSourceNode !== undefined) {
                  return Promise.resolve(renderedNativeAudioBufferSourceNode);
                }
                return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);
              }
            };
          };
        };
        var isAudioBufferSourceNode = function isAudioBufferSourceNode(audioNode) {
          return 'playbackRate' in audioNode;
        };
        var isBiquadFilterNode = function isBiquadFilterNode(audioNode) {
          return 'frequency' in audioNode && 'gain' in audioNode;
        };
        var isConstantSourceNode = function isConstantSourceNode(audioNode) {
          return 'offset' in audioNode;
        };
        var isGainNode = function isGainNode(audioNode) {
          return !('frequency' in audioNode) && 'gain' in audioNode;
        };
        var isOscillatorNode = function isOscillatorNode(audioNode) {
          return 'detune' in audioNode && 'frequency' in audioNode;
        };
        var isStereoPannerNode = function isStereoPannerNode(audioNode) {
          return 'pan' in audioNode;
        };
        var getAudioNodeConnections = function getAudioNodeConnections(audioNode) {
          return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);
        };
        var getAudioParamConnections = function getAudioParamConnections(audioParam) {
          return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);
        };
        var deactivateActiveAudioNodeInputConnections = function deactivateActiveAudioNodeInputConnections(audioNode, trace) {
          var _getAudioNodeConnecti3 = getAudioNodeConnections(audioNode),
            activeInputs = _getAudioNodeConnecti3.activeInputs;
          activeInputs.forEach(function (connections) {
            return connections.forEach(function (_ref21) {
              var _ref22 = _slicedToArray(_ref21, 1),
                source = _ref22[0];
              if (!trace.includes(audioNode)) {
                deactivateActiveAudioNodeInputConnections(source, [].concat(_toConsumableArray(trace), [audioNode]));
              }
            });
          });
          var audioParams = isAudioBufferSourceNode(audioNode) ? [
          // Bug #149: Safari does not yet support the detune AudioParam.
          audioNode.playbackRate] : isAudioWorkletNode(audioNode) ? Array.from(audioNode.parameters.values()) : isBiquadFilterNode(audioNode) ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain] : isConstantSourceNode(audioNode) ? [audioNode.offset] : isGainNode(audioNode) ? [audioNode.gain] : isOscillatorNode(audioNode) ? [audioNode.detune, audioNode.frequency] : isStereoPannerNode(audioNode) ? [audioNode.pan] : [];
          var _iterator4 = _createForOfIteratorHelper(audioParams),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var audioParam = _step4.value;
              var audioParamConnections = getAudioParamConnections(audioParam);
              if (audioParamConnections !== undefined) {
                audioParamConnections.activeInputs.forEach(function (_ref23) {
                  var _ref24 = _slicedToArray(_ref23, 1),
                    source = _ref24[0];
                  return deactivateActiveAudioNodeInputConnections(source, trace);
                });
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
          if (isActiveAudioNode(audioNode)) {
            setInternalStateToPassive(audioNode);
          }
        };
        var deactivateAudioGraph = function deactivateAudioGraph(context) {
          deactivateActiveAudioNodeInputConnections(context.destination, []);
        };
        var isValidLatencyHint = function isValidLatencyHint(latencyHint) {
          return latencyHint === undefined || typeof latencyHint === 'number' || typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback');
        };
        var createAudioDestinationNodeConstructor = function createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode) {
          return /*#__PURE__*/function (_audioNodeConstructor2) {
            _inherits(AudioDestinationNode, _audioNodeConstructor2);
            var _super4 = _createSuper(AudioDestinationNode);
            function AudioDestinationNode(context, channelCount) {
              var _this14;
              _classCallCheck(this, AudioDestinationNode);
              var nativeContext = getNativeContext(context);
              var isOffline = isNativeOfflineAudioContext(nativeContext);
              var nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);
              var audioDestinationNodeRenderer = isOffline ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode) : null;
              _this14 = _super4.call(this, context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);
              _this14._isNodeOfNativeOfflineAudioContext = isOffline;
              _this14._nativeAudioDestinationNode = nativeAudioDestinationNode;
              return _this14;
            }
            _createClass(AudioDestinationNode, [{
              key: "channelCount",
              get: function get() {
                return this._nativeAudioDestinationNode.channelCount;
              },
              set: function set(value) {
                // Bug #52: Chrome, Edge & Safari do not throw an exception at all.
                // Bug #54: Firefox does throw an IndexSizeError.
                if (this._isNodeOfNativeOfflineAudioContext) {
                  throw createInvalidStateError();
                }
                // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.
                if (value > this._nativeAudioDestinationNode.maxChannelCount) {
                  throw createIndexSizeError();
                }
                this._nativeAudioDestinationNode.channelCount = value;
              }
            }, {
              key: "channelCountMode",
              get: function get() {
                return this._nativeAudioDestinationNode.channelCountMode;
              },
              set: function set(value) {
                // Bug #53: No browser does throw an exception yet.
                if (this._isNodeOfNativeOfflineAudioContext) {
                  throw createInvalidStateError();
                }
                this._nativeAudioDestinationNode.channelCountMode = value;
              }
            }, {
              key: "maxChannelCount",
              get: function get() {
                return this._nativeAudioDestinationNode.maxChannelCount;
              }
            }]);
            return AudioDestinationNode;
          }(audioNodeConstructor);
        };
        var createAudioDestinationNodeRenderer = function createAudioDestinationNodeRenderer(renderInputsOfAudioNode) {
          var renderedNativeAudioDestinationNodes = new WeakMap();
          var createAudioDestinationNode = /*#__PURE__*/function () {
            var _ref25 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(proxy, nativeOfflineAudioContext) {
              var nativeAudioDestinationNode;
              return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      nativeAudioDestinationNode = nativeOfflineAudioContext.destination;
                      renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);
                      _context2.next = 4;
                      return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);
                    case 4:
                      return _context2.abrupt("return", nativeAudioDestinationNode);
                    case 5:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            }));
            return function createAudioDestinationNode(_x7, _x8) {
              return _ref25.apply(this, arguments);
            };
          }();
          return {
            render: function render(proxy, nativeOfflineAudioContext) {
              var renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);
              if (renderedNativeAudioDestinationNode !== undefined) {
                return Promise.resolve(renderedNativeAudioDestinationNode);
              }
              return createAudioDestinationNode(proxy, nativeOfflineAudioContext);
            }
          };
        };
        var createAudioListenerFactory = function createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors) {
          return function (context, nativeContext) {
            var nativeListener = nativeContext.listener;
            // Bug #117: Only Chrome & Edge support the new interface already.
            var createFakeAudioParams = function createFakeAudioParams() {
              var buffer = new Float32Array(1);
              var channelMergerNode = createNativeChannelMergerNode(nativeContext, {
                channelCount: 1,
                channelCountMode: 'explicit',
                channelInterpretation: 'speakers',
                numberOfInputs: 9
              });
              var isOffline = isNativeOfflineAudioContext(nativeContext);
              var isScriptProcessorNodeCreated = false;
              var lastOrientation = [0, 0, -1, 0, 1, 0];
              var lastPosition = [0, 0, 0];
              var createScriptProcessorNode = function createScriptProcessorNode() {
                if (isScriptProcessorNodeCreated) {
                  return;
                }
                isScriptProcessorNodeCreated = true;
                var scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);
                // tslint:disable-next-line:deprecation
                scriptProcessorNode.onaudioprocess = function (_ref26) {
                  var inputBuffer = _ref26.inputBuffer;
                  var orientation = [getFirstSample(inputBuffer, buffer, 0), getFirstSample(inputBuffer, buffer, 1), getFirstSample(inputBuffer, buffer, 2), getFirstSample(inputBuffer, buffer, 3), getFirstSample(inputBuffer, buffer, 4), getFirstSample(inputBuffer, buffer, 5)];
                  if (orientation.some(function (value, index) {
                    return value !== lastOrientation[index];
                  })) {
                    nativeListener.setOrientation.apply(nativeListener, orientation); // tslint:disable-line:deprecation
                    lastOrientation = orientation;
                  }
                  var positon = [getFirstSample(inputBuffer, buffer, 6), getFirstSample(inputBuffer, buffer, 7), getFirstSample(inputBuffer, buffer, 8)];
                  if (positon.some(function (value, index) {
                    return value !== lastPosition[index];
                  })) {
                    nativeListener.setPosition.apply(nativeListener, positon); // tslint:disable-line:deprecation
                    lastPosition = positon;
                  }
                };
                channelMergerNode.connect(scriptProcessorNode);
              };
              var createSetOrientation = function createSetOrientation(index) {
                return function (value) {
                  if (value !== lastOrientation[index]) {
                    lastOrientation[index] = value;
                    nativeListener.setOrientation.apply(nativeListener, _toConsumableArray(lastOrientation)); // tslint:disable-line:deprecation
                  }
                };
              };

              var createSetPosition = function createSetPosition(index) {
                return function (value) {
                  if (value !== lastPosition[index]) {
                    lastPosition[index] = value;
                    nativeListener.setPosition.apply(nativeListener, _toConsumableArray(lastPosition)); // tslint:disable-line:deprecation
                  }
                };
              };

              var createFakeAudioParam = function createFakeAudioParam(input, initialValue, setValue) {
                var constantSourceNode = createNativeConstantSourceNode(nativeContext, {
                  channelCount: 1,
                  channelCountMode: 'explicit',
                  channelInterpretation: 'discrete',
                  offset: initialValue
                });
                constantSourceNode.connect(channelMergerNode, 0, input);
                // @todo This should be stopped when the context is closed.
                constantSourceNode.start();
                Object.defineProperty(constantSourceNode.offset, 'defaultValue', {
                  get: function get() {
                    return initialValue;
                  }
                });
                /*
                 * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and
                 * minValue for GainNodes.
                 */
                var audioParam = createAudioParam({
                  context: context
                }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
                overwriteAccessors(audioParam, 'value', function (get) {
                  return function () {
                    return get.call(audioParam);
                  };
                }, function (set) {
                  return function (value) {
                    try {
                      set.call(audioParam, value);
                    } catch (err) {
                      if (err.code !== 9) {
                        throw err;
                      }
                    }
                    createScriptProcessorNode();
                    if (isOffline) {
                      // Bug #117: Using setOrientation() and setPosition() doesn't work with an OfflineAudioContext.
                      setValue(value);
                    }
                  };
                });
                audioParam.cancelAndHoldAtTime = function (cancelAndHoldAtTime) {
                  if (isOffline) {
                    return function () {
                      throw createNotSupportedError();
                    };
                  }
                  return function () {
                    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                      args[_key3] = arguments[_key3];
                    }
                    var value = cancelAndHoldAtTime.apply(audioParam, args);
                    createScriptProcessorNode();
                    return value;
                  };
                }(audioParam.cancelAndHoldAtTime);
                audioParam.cancelScheduledValues = function (cancelScheduledValues) {
                  if (isOffline) {
                    return function () {
                      throw createNotSupportedError();
                    };
                  }
                  return function () {
                    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                      args[_key4] = arguments[_key4];
                    }
                    var value = cancelScheduledValues.apply(audioParam, args);
                    createScriptProcessorNode();
                    return value;
                  };
                }(audioParam.cancelScheduledValues);
                audioParam.exponentialRampToValueAtTime = function (exponentialRampToValueAtTime) {
                  if (isOffline) {
                    return function () {
                      throw createNotSupportedError();
                    };
                  }
                  return function () {
                    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                      args[_key5] = arguments[_key5];
                    }
                    var value = exponentialRampToValueAtTime.apply(audioParam, args);
                    createScriptProcessorNode();
                    return value;
                  };
                }(audioParam.exponentialRampToValueAtTime);
                audioParam.linearRampToValueAtTime = function (linearRampToValueAtTime) {
                  if (isOffline) {
                    return function () {
                      throw createNotSupportedError();
                    };
                  }
                  return function () {
                    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                      args[_key6] = arguments[_key6];
                    }
                    var value = linearRampToValueAtTime.apply(audioParam, args);
                    createScriptProcessorNode();
                    return value;
                  };
                }(audioParam.linearRampToValueAtTime);
                audioParam.setTargetAtTime = function (setTargetAtTime) {
                  if (isOffline) {
                    return function () {
                      throw createNotSupportedError();
                    };
                  }
                  return function () {
                    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
                      args[_key7] = arguments[_key7];
                    }
                    var value = setTargetAtTime.apply(audioParam, args);
                    createScriptProcessorNode();
                    return value;
                  };
                }(audioParam.setTargetAtTime);
                audioParam.setValueAtTime = function (setValueAtTime) {
                  if (isOffline) {
                    return function () {
                      throw createNotSupportedError();
                    };
                  }
                  return function () {
                    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
                      args[_key8] = arguments[_key8];
                    }
                    var value = setValueAtTime.apply(audioParam, args);
                    createScriptProcessorNode();
                    return value;
                  };
                }(audioParam.setValueAtTime);
                audioParam.setValueCurveAtTime = function (setValueCurveAtTime) {
                  if (isOffline) {
                    return function () {
                      throw createNotSupportedError();
                    };
                  }
                  return function () {
                    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
                      args[_key9] = arguments[_key9];
                    }
                    var value = setValueCurveAtTime.apply(audioParam, args);
                    createScriptProcessorNode();
                    return value;
                  };
                }(audioParam.setValueCurveAtTime);
                return audioParam;
              };
              return {
                forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),
                forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),
                forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),
                positionX: createFakeAudioParam(6, 0, createSetPosition(0)),
                positionY: createFakeAudioParam(7, 0, createSetPosition(1)),
                positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),
                upX: createFakeAudioParam(3, 0, createSetOrientation(3)),
                upY: createFakeAudioParam(4, 1, createSetOrientation(4)),
                upZ: createFakeAudioParam(5, 0, createSetOrientation(5))
              };
            };
            var _ref27 = nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener,
              forwardX = _ref27.forwardX,
              forwardY = _ref27.forwardY,
              forwardZ = _ref27.forwardZ,
              positionX = _ref27.positionX,
              positionY = _ref27.positionY,
              positionZ = _ref27.positionZ,
              upX = _ref27.upX,
              upY = _ref27.upY,
              upZ = _ref27.upZ;
            return {
              get forwardX() {
                return forwardX;
              },
              get forwardY() {
                return forwardY;
              },
              get forwardZ() {
                return forwardZ;
              },
              get positionX() {
                return positionX;
              },
              get positionY() {
                return positionY;
              },
              get positionZ() {
                return positionZ;
              },
              get upX() {
                return upX;
              },
              get upY() {
                return upY;
              },
              get upZ() {
                return upZ;
              }
            };
          };
        };
        var isAudioNode = function isAudioNode(audioNodeOrAudioParam) {
          return 'context' in audioNodeOrAudioParam;
        };
        var isAudioNodeOutputConnection = function isAudioNodeOutputConnection(outputConnection) {
          return isAudioNode(outputConnection[0]);
        };
        var insertElementInSet = function insertElementInSet(set, element, predicate, ignoreDuplicates) {
          var _iterator5 = _createForOfIteratorHelper(set),
            _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var lmnt = _step5.value;
              if (predicate(lmnt)) {
                if (ignoreDuplicates) {
                  return false;
                }
                throw Error('The set contains at least one similar element.');
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
          set.add(element);
          return true;
        };
        var addActiveInputConnectionToAudioParam = function addActiveInputConnectionToAudioParam(activeInputs, source, _ref28, ignoreDuplicates) {
          var _ref29 = _slicedToArray(_ref28, 2),
            output = _ref29[0],
            eventListener = _ref29[1];
          insertElementInSet(activeInputs, [source, output, eventListener], function (activeInputConnection) {
            return activeInputConnection[0] === source && activeInputConnection[1] === output;
          }, ignoreDuplicates);
        };
        var addPassiveInputConnectionToAudioParam = function addPassiveInputConnectionToAudioParam(passiveInputs, _ref30, ignoreDuplicates) {
          var _ref31 = _slicedToArray(_ref30, 3),
            source = _ref31[0],
            output = _ref31[1],
            eventListener = _ref31[2];
          var passiveInputConnections = passiveInputs.get(source);
          if (passiveInputConnections === undefined) {
            passiveInputs.set(source, new Set([[output, eventListener]]));
          } else {
            insertElementInSet(passiveInputConnections, [output, eventListener], function (passiveInputConnection) {
              return passiveInputConnection[0] === output;
            }, ignoreDuplicates);
          }
        };
        var isNativeAudioNodeFaker = function isNativeAudioNodeFaker(nativeAudioNodeOrNativeAudioNodeFaker) {
          return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;
        };
        var connectNativeAudioNodeToNativeAudioNode = function connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input) {
          if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {
            var fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];
            nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);
            return [fakeNativeDestinationAudioNode, output, 0];
          }
          nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);
          return [nativeDestinationAudioNode, output, input];
        };
        var deleteActiveInputConnection = function deleteActiveInputConnection(activeInputConnections, source, output) {
          var _iterator6 = _createForOfIteratorHelper(activeInputConnections),
            _step6;
          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var activeInputConnection = _step6.value;
              if (activeInputConnection[0] === source && activeInputConnection[1] === output) {
                activeInputConnections.delete(activeInputConnection);
                return activeInputConnection;
              }
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
          return null;
        };
        var deleteActiveInputConnectionToAudioParam = function deleteActiveInputConnectionToAudioParam(activeInputs, source, output) {
          return pickElementFromSet(activeInputs, function (activeInputConnection) {
            return activeInputConnection[0] === source && activeInputConnection[1] === output;
          });
        };
        var deleteEventListenerOfAudioNode = function deleteEventListenerOfAudioNode(audioNode, eventListener) {
          var eventListeners = getEventListenersOfAudioNode(audioNode);
          if (!eventListeners.delete(eventListener)) {
            throw new Error('Missing the expected event listener.');
          }
        };
        var deletePassiveInputConnectionToAudioParam = function deletePassiveInputConnectionToAudioParam(passiveInputs, source, output) {
          var passiveInputConnections = getValueForKey(passiveInputs, source);
          var matchingConnection = pickElementFromSet(passiveInputConnections, function (passiveInputConnection) {
            return passiveInputConnection[0] === output;
          });
          if (passiveInputConnections.size === 0) {
            passiveInputs.delete(source);
          }
          return matchingConnection;
        };
        var disconnectNativeAudioNodeFromNativeAudioNode = function disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input) {
          if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {
            nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);
          } else {
            nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);
          }
        };
        var getNativeAudioNode = function getNativeAudioNode(audioNode) {
          return getValueForKey(AUDIO_NODE_STORE, audioNode);
        };
        var getNativeAudioParam = function getNativeAudioParam(audioParam) {
          return getValueForKey(AUDIO_PARAM_STORE, audioParam);
        };
        var isPartOfACycle = function isPartOfACycle(audioNode) {
          return CYCLE_COUNTERS.has(audioNode);
        };
        var isPassiveAudioNode = function isPassiveAudioNode(audioNode) {
          return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);
        };
        var testAudioNodeDisconnectMethodSupport = function testAudioNodeDisconnectMethodSupport(nativeAudioContext, nativeAudioWorkletNodeConstructor) {
          return new Promise(function (resolve) {
            /*
             * This bug existed in Safari up until v14.0.2. Since AudioWorklets were not supported in Safari until v14.1 the presence of the
             * constructor for an AudioWorkletNode can be used here to skip the test.
             */
            if (nativeAudioWorkletNodeConstructor !== null) {
              resolve(true);
            } else {
              var analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1); // tslint:disable-line deprecation
              var dummy = nativeAudioContext.createGain();
              // Bug #95: Safari does not play one sample buffers.
              var ones = nativeAudioContext.createBuffer(1, 2, 44100);
              var channelData = ones.getChannelData(0);
              channelData[0] = 1;
              channelData[1] = 1;
              var source = nativeAudioContext.createBufferSource();
              source.buffer = ones;
              source.loop = true;
              source.connect(analyzer).connect(nativeAudioContext.destination);
              source.connect(dummy);
              source.disconnect(dummy);
              // tslint:disable-next-line:deprecation
              analyzer.onaudioprocess = function (event) {
                var chnnlDt = event.inputBuffer.getChannelData(0); // tslint:disable-line deprecation
                if (Array.prototype.some.call(chnnlDt, function (sample) {
                  return sample === 1;
                })) {
                  resolve(true);
                } else {
                  resolve(false);
                }
                source.stop();
                analyzer.onaudioprocess = null; // tslint:disable-line:deprecation
                source.disconnect(analyzer);
                analyzer.disconnect(nativeAudioContext.destination);
              };
              source.start();
            }
          });
        };
        var visitEachAudioNodeOnce = function visitEachAudioNodeOnce(cycles, visitor) {
          var counts = new Map();
          var _iterator7 = _createForOfIteratorHelper(cycles),
            _step7;
          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var cycle = _step7.value;
              var _iterator8 = _createForOfIteratorHelper(cycle),
                _step8;
              try {
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                  var audioNode = _step8.value;
                  var count = counts.get(audioNode);
                  counts.set(audioNode, count === undefined ? 1 : count + 1);
                }
              } catch (err) {
                _iterator8.e(err);
              } finally {
                _iterator8.f();
              }
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
          counts.forEach(function (count, audioNode) {
            return visitor(audioNode, count);
          });
        };
        var isNativeAudioNode$1 = function isNativeAudioNode$1(nativeAudioNodeOrAudioParam) {
          return 'context' in nativeAudioNodeOrAudioParam;
        };
        var wrapAudioNodeDisconnectMethod = function wrapAudioNodeDisconnectMethod(nativeAudioNode) {
          var connections = new Map();
          nativeAudioNode.connect = function (connect) {
            // tslint:disable-next-line:invalid-void no-inferrable-types
            return function (destination) {
              var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              var returnValue = isNativeAudioNode$1(destination) ? connect(destination, output, input) : connect(destination, output);
              // Save the new connection only if the calls to connect above didn't throw an error.
              var connectionsToDestination = connections.get(destination);
              if (connectionsToDestination === undefined) {
                connections.set(destination, [{
                  input: input,
                  output: output
                }]);
              } else {
                if (connectionsToDestination.every(function (connection) {
                  return connection.input !== input || connection.output !== output;
                })) {
                  connectionsToDestination.push({
                    input: input,
                    output: output
                  });
                }
              }
              return returnValue;
            };
          }(nativeAudioNode.connect.bind(nativeAudioNode));
          nativeAudioNode.disconnect = function (disconnect) {
            return function (destinationOrOutput, output, input) {
              disconnect.apply(nativeAudioNode);
              if (destinationOrOutput === undefined) {
                connections.clear();
              } else if (typeof destinationOrOutput === 'number') {
                var _iterator9 = _createForOfIteratorHelper(connections),
                  _step9;
                try {
                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                    var _step9$value = _slicedToArray(_step9.value, 2),
                      destination = _step9$value[0],
                      connectionsToDestination = _step9$value[1];
                    var filteredConnections = connectionsToDestination.filter(function (connection) {
                      return connection.output !== destinationOrOutput;
                    });
                    if (filteredConnections.length === 0) {
                      connections.delete(destination);
                    } else {
                      connections.set(destination, filteredConnections);
                    }
                  }
                } catch (err) {
                  _iterator9.e(err);
                } finally {
                  _iterator9.f();
                }
              } else if (connections.has(destinationOrOutput)) {
                if (output === undefined) {
                  connections.delete(destinationOrOutput);
                } else {
                  var _connectionsToDestination = connections.get(destinationOrOutput);
                  if (_connectionsToDestination !== undefined) {
                    var _filteredConnections = _connectionsToDestination.filter(function (connection) {
                      return connection.output !== output && (connection.input !== input || input === undefined);
                    });
                    if (_filteredConnections.length === 0) {
                      connections.delete(destinationOrOutput);
                    } else {
                      connections.set(destinationOrOutput, _filteredConnections);
                    }
                  }
                }
              }
              var _iterator10 = _createForOfIteratorHelper(connections),
                _step10;
              try {
                var _loop2 = function _loop2() {
                  var _step10$value = _slicedToArray(_step10.value, 2),
                    destination = _step10$value[0],
                    connectionsToDestination = _step10$value[1];
                  connectionsToDestination.forEach(function (connection) {
                    if (isNativeAudioNode$1(destination)) {
                      nativeAudioNode.connect(destination, connection.output, connection.input);
                    } else {
                      nativeAudioNode.connect(destination, connection.output);
                    }
                  });
                };
                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                  _loop2();
                }
              } catch (err) {
                _iterator10.e(err);
              } finally {
                _iterator10.f();
              }
            };
          }(nativeAudioNode.disconnect);
        };
        var addConnectionToAudioParamOfAudioContext = function addConnectionToAudioParamOfAudioContext(source, destination, output, isOffline) {
          var _getAudioParamConnect = getAudioParamConnections(destination),
            activeInputs = _getAudioParamConnect.activeInputs,
            passiveInputs = _getAudioParamConnect.passiveInputs;
          var _getAudioNodeConnecti4 = getAudioNodeConnections(source),
            outputs = _getAudioNodeConnecti4.outputs;
          var eventListeners = getEventListenersOfAudioNode(source);
          var eventListener = function eventListener(isActive) {
            var nativeAudioNode = getNativeAudioNode(source);
            var nativeAudioParam = getNativeAudioParam(destination);
            if (isActive) {
              var partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);
              addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);
              if (!isOffline && !isPartOfACycle(source)) {
                nativeAudioNode.connect(nativeAudioParam, output);
              }
            } else {
              var _partialConnection2 = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);
              addPassiveInputConnectionToAudioParam(passiveInputs, _partialConnection2, false);
              if (!isOffline && !isPartOfACycle(source)) {
                nativeAudioNode.disconnect(nativeAudioParam, output);
              }
            }
          };
          if (insertElementInSet(outputs, [destination, output], function (outputConnection) {
            return outputConnection[0] === destination && outputConnection[1] === output;
          }, true)) {
            eventListeners.add(eventListener);
            if (isActiveAudioNode(source)) {
              addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);
            } else {
              addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);
            }
            return true;
          }
          return false;
        };
        var deleteInputConnectionOfAudioNode = function deleteInputConnectionOfAudioNode(source, destination, output, input) {
          var _getAudioNodeConnecti5 = getAudioNodeConnections(destination),
            activeInputs = _getAudioNodeConnecti5.activeInputs,
            passiveInputs = _getAudioNodeConnecti5.passiveInputs;
          var activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);
          if (activeInputConnection === null) {
            var passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);
            return [passiveInputConnection[2], false];
          }
          return [activeInputConnection[2], true];
        };
        var deleteInputConnectionOfAudioParam = function deleteInputConnectionOfAudioParam(source, destination, output) {
          var _getAudioParamConnect2 = getAudioParamConnections(destination),
            activeInputs = _getAudioParamConnect2.activeInputs,
            passiveInputs = _getAudioParamConnect2.passiveInputs;
          var activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);
          if (activeInputConnection === null) {
            var passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);
            return [passiveInputConnection[1], false];
          }
          return [activeInputConnection[2], true];
        };
        var deleteInputsOfAudioNode = function deleteInputsOfAudioNode(source, isOffline, destination, output, input) {
          var _deleteInputConnectio = deleteInputConnectionOfAudioNode(source, destination, output, input),
            _deleteInputConnectio2 = _slicedToArray(_deleteInputConnectio, 2),
            listener = _deleteInputConnectio2[0],
            isActive = _deleteInputConnectio2[1];
          if (listener !== null) {
            deleteEventListenerOfAudioNode(source, listener);
            if (isActive && !isOffline && !isPartOfACycle(source)) {
              disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);
            }
          }
          if (isActiveAudioNode(destination)) {
            var _getAudioNodeConnecti6 = getAudioNodeConnections(destination),
              activeInputs = _getAudioNodeConnecti6.activeInputs;
            setInternalStateToPassiveWhenNecessary(destination, activeInputs);
          }
        };
        var deleteInputsOfAudioParam = function deleteInputsOfAudioParam(source, isOffline, destination, output) {
          var _deleteInputConnectio3 = deleteInputConnectionOfAudioParam(source, destination, output),
            _deleteInputConnectio4 = _slicedToArray(_deleteInputConnectio3, 2),
            listener = _deleteInputConnectio4[0],
            isActive = _deleteInputConnectio4[1];
          if (listener !== null) {
            deleteEventListenerOfAudioNode(source, listener);
            if (isActive && !isOffline && !isPartOfACycle(source)) {
              getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);
            }
          }
        };
        var deleteAnyConnection = function deleteAnyConnection(source, isOffline) {
          var audioNodeConnectionsOfSource = getAudioNodeConnections(source);
          var destinations = [];
          var _iterator11 = _createForOfIteratorHelper(audioNodeConnectionsOfSource.outputs),
            _step11;
          try {
            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
              var outputConnection = _step11.value;
              if (isAudioNodeOutputConnection(outputConnection)) {
                deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));
              } else {
                deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));
              }
              destinations.push(outputConnection[0]);
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }
          audioNodeConnectionsOfSource.outputs.clear();
          return destinations;
        };
        var deleteConnectionAtOutput = function deleteConnectionAtOutput(source, isOffline, output) {
          var audioNodeConnectionsOfSource = getAudioNodeConnections(source);
          var destinations = [];
          var _iterator12 = _createForOfIteratorHelper(audioNodeConnectionsOfSource.outputs),
            _step12;
          try {
            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
              var outputConnection = _step12.value;
              if (outputConnection[1] === output) {
                if (isAudioNodeOutputConnection(outputConnection)) {
                  deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));
                } else {
                  deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));
                }
                destinations.push(outputConnection[0]);
                audioNodeConnectionsOfSource.outputs.delete(outputConnection);
              }
            }
          } catch (err) {
            _iterator12.e(err);
          } finally {
            _iterator12.f();
          }
          return destinations;
        };
        var deleteConnectionToDestination = function deleteConnectionToDestination(source, isOffline, destination, output, input) {
          var audioNodeConnectionsOfSource = getAudioNodeConnections(source);
          return Array.from(audioNodeConnectionsOfSource.outputs).filter(function (outputConnection) {
            return outputConnection[0] === destination && (output === undefined || outputConnection[1] === output) && (input === undefined || outputConnection[2] === input);
          }).map(function (outputConnection) {
            if (isAudioNodeOutputConnection(outputConnection)) {
              deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));
            } else {
              deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));
            }
            audioNodeConnectionsOfSource.outputs.delete(outputConnection);
            return outputConnection[0];
          });
        };
        var createAudioNodeConstructor = function createAudioNodeConstructor(addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor) {
          return /*#__PURE__*/function (_eventTargetConstruct) {
            _inherits(AudioNode, _eventTargetConstruct);
            var _super5 = _createSuper(AudioNode);
            function AudioNode(context, isActive, nativeAudioNode, audioNodeRenderer) {
              var _this15;
              _classCallCheck(this, AudioNode);
              _this15 = _super5.call(this, nativeAudioNode);
              _this15._context = context;
              _this15._nativeAudioNode = nativeAudioNode;
              var nativeContext = getNativeContext(context);
              // Bug #12: Safari does not support to disconnect a specific destination.
              if (isNativeAudioContext(nativeContext) && true !== cacheTestResult(testAudioNodeDisconnectMethodSupport, function () {
                return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);
              })) {
                wrapAudioNodeDisconnectMethod(nativeAudioNode);
              }
              AUDIO_NODE_STORE.set(_assertThisInitialized2(_this15), nativeAudioNode);
              EVENT_LISTENERS.set(_assertThisInitialized2(_this15), new Set());
              if (context.state !== 'closed' && isActive) {
                setInternalStateToActive(_assertThisInitialized2(_this15));
              }
              addAudioNodeConnections(_assertThisInitialized2(_this15), audioNodeRenderer, nativeAudioNode);
              return _this15;
            }
            _createClass(AudioNode, [{
              key: "channelCount",
              get: function get() {
                return this._nativeAudioNode.channelCount;
              },
              set: function set(value) {
                this._nativeAudioNode.channelCount = value;
              }
            }, {
              key: "channelCountMode",
              get: function get() {
                return this._nativeAudioNode.channelCountMode;
              },
              set: function set(value) {
                this._nativeAudioNode.channelCountMode = value;
              }
            }, {
              key: "channelInterpretation",
              get: function get() {
                return this._nativeAudioNode.channelInterpretation;
              },
              set: function set(value) {
                this._nativeAudioNode.channelInterpretation = value;
              }
            }, {
              key: "context",
              get: function get() {
                return this._context;
              }
            }, {
              key: "numberOfInputs",
              get: function get() {
                return this._nativeAudioNode.numberOfInputs;
              }
            }, {
              key: "numberOfOutputs",
              get: function get() {
                return this._nativeAudioNode.numberOfOutputs;
              }
              // tslint:disable-next-line:invalid-void
            }, {
              key: "connect",
              value: function connect(destination) {
                var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.
                if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {
                  throw createIndexSizeError();
                }
                var nativeContext = getNativeContext(this._context);
                var isOffline = isNativeOfflineAudioContext(nativeContext);
                if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {
                  throw createInvalidAccessError();
                }
                if (isAudioNode(destination)) {
                  var nativeDestinationAudioNode = getNativeAudioNode(destination);
                  try {
                    var connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);
                    var isPassive = isPassiveAudioNode(this);
                    if (isOffline || isPassive) {
                      var _this$_nativeAudioNod;
                      (_this$_nativeAudioNod = this._nativeAudioNode).disconnect.apply(_this$_nativeAudioNod, _toConsumableArray(connection));
                    }
                    if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {
                      setInternalStateToActive(destination);
                    }
                  } catch (err) {
                    // Bug #41: Safari does not throw the correct exception so far.
                    if (err.code === 12) {
                      throw createInvalidAccessError();
                    }
                    throw err;
                  }
                  var isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline);
                  // Bug #164: Only Firefox detects cycles so far.
                  if (isNewConnectionToAudioNode) {
                    var cycles = detectCycles([this], destination);
                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));
                  }
                  return destination;
                }
                var nativeAudioParam = getNativeAudioParam(destination);
                /*
                 * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an
                 * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify
                 * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.
                 */
                if (nativeAudioParam.name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {
                  throw createNotSupportedError();
                }
                try {
                  this._nativeAudioNode.connect(nativeAudioParam, output);
                  if (isOffline || isPassiveAudioNode(this)) {
                    this._nativeAudioNode.disconnect(nativeAudioParam, output);
                  }
                } catch (err) {
                  // Bug #58: Safari doesn't throw an InvalidAccessError yet.
                  if (err.code === 12) {
                    throw createInvalidAccessError();
                  }
                  throw err;
                }
                var isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);
                // Bug #164: Only Firefox detects cycles so far.
                if (isNewConnectionToAudioParam) {
                  var _cycles = detectCycles([this], destination);
                  visitEachAudioNodeOnce(_cycles, createIncrementCycleCounter(isOffline));
                }
              }
            }, {
              key: "disconnect",
              value: function disconnect(destinationOrOutput, output, input) {
                var destinations;
                var nativeContext = getNativeContext(this._context);
                var isOffline = isNativeOfflineAudioContext(nativeContext);
                if (destinationOrOutput === undefined) {
                  destinations = deleteAnyConnection(this, isOffline);
                } else if (typeof destinationOrOutput === 'number') {
                  if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {
                    throw createIndexSizeError();
                  }
                  destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);
                } else {
                  if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {
                    throw createIndexSizeError();
                  }
                  if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {
                    throw createIndexSizeError();
                  }
                  destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);
                  if (destinations.length === 0) {
                    throw createInvalidAccessError();
                  }
                }
                // Bug #164: Only Firefox detects cycles so far.
                var _iterator13 = _createForOfIteratorHelper(destinations),
                  _step13;
                try {
                  for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
                    var destination = _step13.value;
                    var cycles = detectCycles([this], destination);
                    visitEachAudioNodeOnce(cycles, decrementCycleCounter);
                  }
                } catch (err) {
                  _iterator13.e(err);
                } finally {
                  _iterator13.f();
                }
              }
            }]);
            return AudioNode;
          }(eventTargetConstructor);
        };
        var createAudioParamFactory = function createAudioParamFactory(addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible) {
          return function (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam) {
            var maxValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
            var minValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
            var automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);
            var audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;
            var audioParam = {
              get defaultValue() {
                return nativeAudioParam.defaultValue;
              },
              get maxValue() {
                return maxValue === null ? nativeAudioParam.maxValue : maxValue;
              },
              get minValue() {
                return minValue === null ? nativeAudioParam.minValue : minValue;
              },
              get value() {
                return nativeAudioParam.value;
              },
              set value(value) {
                nativeAudioParam.value = value;
                // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().
                audioParam.setValueAtTime(value, audioNode.context.currentTime);
              },
              cancelAndHoldAtTime: function cancelAndHoldAtTime(cancelTime) {
                // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().
                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {
                  if (audioParamRenderer === null) {
                    automationEventList.flush(audioNode.context.currentTime);
                  }
                  automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));
                  nativeAudioParam.cancelAndHoldAtTime(cancelTime);
                } else {
                  var previousLastEvent = Array.from(automationEventList).pop();
                  if (audioParamRenderer === null) {
                    automationEventList.flush(audioNode.context.currentTime);
                  }
                  automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));
                  var currentLastEvent = Array.from(automationEventList).pop();
                  nativeAudioParam.cancelScheduledValues(cancelTime);
                  if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {
                    if (currentLastEvent.type === 'exponentialRampToValue') {
                      nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);
                    } else if (currentLastEvent.type === 'linearRampToValue') {
                      nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);
                    } else if (currentLastEvent.type === 'setValue') {
                      nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);
                    } else if (currentLastEvent.type === 'setValueCurve') {
                      nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);
                    }
                  }
                }
                return audioParam;
              },
              cancelScheduledValues: function cancelScheduledValues(cancelTime) {
                if (audioParamRenderer === null) {
                  automationEventList.flush(audioNode.context.currentTime);
                }
                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));
                nativeAudioParam.cancelScheduledValues(cancelTime);
                return audioParam;
              },
              exponentialRampToValueAtTime: function exponentialRampToValueAtTime(value, endTime) {
                // Bug #45: Safari does not throw an error yet.
                if (value === 0) {
                  throw new RangeError();
                }
                // Bug #187: Safari does not throw an error yet.
                if (!Number.isFinite(endTime) || endTime < 0) {
                  throw new RangeError();
                }
                if (audioParamRenderer === null) {
                  automationEventList.flush(audioNode.context.currentTime);
                }
                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));
                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);
                return audioParam;
              },
              linearRampToValueAtTime: function linearRampToValueAtTime(value, endTime) {
                if (audioParamRenderer === null) {
                  automationEventList.flush(audioNode.context.currentTime);
                }
                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));
                nativeAudioParam.linearRampToValueAtTime(value, endTime);
                return audioParam;
              },
              setTargetAtTime: function setTargetAtTime(target, startTime, timeConstant) {
                if (audioParamRenderer === null) {
                  automationEventList.flush(audioNode.context.currentTime);
                }
                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));
                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);
                return audioParam;
              },
              setValueAtTime: function setValueAtTime(value, startTime) {
                if (audioParamRenderer === null) {
                  automationEventList.flush(audioNode.context.currentTime);
                }
                automationEventList.add(createSetValueAutomationEvent(value, startTime));
                nativeAudioParam.setValueAtTime(value, startTime);
                return audioParam;
              },
              setValueCurveAtTime: function setValueCurveAtTime(values, startTime, duration) {
                // Bug 183: Safari only accepts a Float32Array.
                var convertedValues = values instanceof Float32Array ? values : new Float32Array(values);
                /*
                 * Bug #152: Safari does not correctly interpolate the values of the curve.
                 * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the
                 * existence of the webkitAudioContext is used as a workaround here.
                 */
                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {
                  var endTime = startTime + duration;
                  var sampleRate = audioNode.context.sampleRate;
                  var firstSample = Math.ceil(startTime * sampleRate);
                  var lastSample = Math.floor(endTime * sampleRate);
                  var numberOfInterpolatedValues = lastSample - firstSample;
                  var interpolatedValues = new Float32Array(numberOfInterpolatedValues);
                  for (var _i5 = 0; _i5 < numberOfInterpolatedValues; _i5 += 1) {
                    var theoreticIndex = (convertedValues.length - 1) / duration * ((firstSample + _i5) / sampleRate - startTime);
                    var lowerIndex = Math.floor(theoreticIndex);
                    var upperIndex = Math.ceil(theoreticIndex);
                    interpolatedValues[_i5] = lowerIndex === upperIndex ? convertedValues[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];
                  }
                  if (audioParamRenderer === null) {
                    automationEventList.flush(audioNode.context.currentTime);
                  }
                  automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));
                  nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);
                  var timeOfLastSample = lastSample / sampleRate;
                  if (timeOfLastSample < endTime) {
                    setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);
                  }
                  setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);
                } else {
                  if (audioParamRenderer === null) {
                    automationEventList.flush(audioNode.context.currentTime);
                  }
                  automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));
                  nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);
                }
                return audioParam;
              }
            };
            audioParamStore.set(audioParam, nativeAudioParam);
            audioParamAudioNodeStore.set(audioParam, audioNode);
            addAudioParamConnections(audioParam, audioParamRenderer);
            return audioParam;
          };
        };
        var createAudioParamRenderer = function createAudioParamRenderer(automationEventList) {
          return {
            replay: function replay(audioParam) {
              var _iterator14 = _createForOfIteratorHelper(automationEventList),
                _step14;
              try {
                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                  var automationEvent = _step14.value;
                  if (automationEvent.type === 'exponentialRampToValue') {
                    var endTime = automationEvent.endTime,
                      value = automationEvent.value;
                    audioParam.exponentialRampToValueAtTime(value, endTime);
                  } else if (automationEvent.type === 'linearRampToValue') {
                    var _endTime = automationEvent.endTime,
                      _value2 = automationEvent.value;
                    audioParam.linearRampToValueAtTime(_value2, _endTime);
                  } else if (automationEvent.type === 'setTarget') {
                    var startTime = automationEvent.startTime,
                      target = automationEvent.target,
                      timeConstant = automationEvent.timeConstant;
                    audioParam.setTargetAtTime(target, startTime, timeConstant);
                  } else if (automationEvent.type === 'setValue') {
                    var _startTime2 = automationEvent.startTime,
                      _value3 = automationEvent.value;
                    audioParam.setValueAtTime(_value3, _startTime2);
                  } else if (automationEvent.type === 'setValueCurve') {
                    var duration = automationEvent.duration,
                      _startTime3 = automationEvent.startTime,
                      values = automationEvent.values;
                    audioParam.setValueCurveAtTime(values, _startTime3, duration);
                  } else {
                    throw new Error("Can't apply an unknown automation.");
                  }
                }
              } catch (err) {
                _iterator14.e(err);
              } finally {
                _iterator14.f();
              }
            }
          };
        };
        var createCacheTestResult = function createCacheTestResult(ongoingTests, testResults) {
          return function (tester, test) {
            var cachedTestResult = testResults.get(tester);
            if (cachedTestResult !== undefined) {
              return cachedTestResult;
            }
            var ongoingTest = ongoingTests.get(tester);
            if (ongoingTest !== undefined) {
              return ongoingTest;
            }
            try {
              var synchronousTestResult = test();
              if (synchronousTestResult instanceof Promise) {
                ongoingTests.set(tester, synchronousTestResult);
                return synchronousTestResult.catch(function () {
                  return false;
                }).then(function (finalTestResult) {
                  ongoingTests.delete(tester);
                  testResults.set(tester, finalTestResult);
                  return finalTestResult;
                });
              }
              testResults.set(tester, synchronousTestResult);
              return synchronousTestResult;
            } catch (_unused2) {
              testResults.set(tester, false);
              return false;
            }
          };
        };
        var createConnectAudioParam = function createConnectAudioParam(renderInputsOfAudioParam) {
          return function (nativeOfflineAudioContext, audioParam, nativeAudioParam) {
            return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);
          };
        };
        var createConvertNumberToUnsignedLong = function createConvertNumberToUnsignedLong(unit32Array) {
          return function (value) {
            unit32Array[0] = value;
            return unit32Array[0];
          };
        };
        var DEFAULT_OPTIONS$3 = {
          buffer: null,
          channelCount: 2,
          channelCountMode: 'clamped-max',
          channelInterpretation: 'speakers',
          disableNormalization: false
        };
        var createConvolverNodeConstructor = function createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {
          return /*#__PURE__*/function (_audioNodeConstructor3) {
            _inherits(ConvolverNode, _audioNodeConstructor3);
            var _super6 = _createSuper(ConvolverNode);
            function ConvolverNode(context, options) {
              var _this16;
              _classCallCheck(this, ConvolverNode);
              var nativeContext = getNativeContext(context);
              var mergedOptions = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS$3), options);
              var nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);
              var isOffline = isNativeOfflineAudioContext(nativeContext);
              var convolverNodeRenderer = isOffline ? createConvolverNodeRenderer() : null;
              _this16 = _super6.call(this, context, false, nativeConvolverNode, convolverNodeRenderer);
              _this16._isBufferNullified = false;
              _this16._nativeConvolverNode = nativeConvolverNode;
              if (mergedOptions.buffer !== null) {
                setAudioNodeTailTime(_assertThisInitialized2(_this16), mergedOptions.buffer.duration);
              }
              return _this16;
            }
            _createClass(ConvolverNode, [{
              key: "buffer",
              get: function get() {
                if (this._isBufferNullified) {
                  return null;
                }
                return this._nativeConvolverNode.buffer;
              },
              set: function set(value) {
                this._nativeConvolverNode.buffer = value;
                // Bug #115: Safari does not allow to set the buffer to null.
                if (value === null && this._nativeConvolverNode.buffer !== null) {
                  var nativeContext = this._nativeConvolverNode.context;
                  this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);
                  this._isBufferNullified = true;
                  setAudioNodeTailTime(this, 0);
                } else {
                  this._isBufferNullified = false;
                  setAudioNodeTailTime(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);
                }
              }
            }, {
              key: "normalize",
              get: function get() {
                return this._nativeConvolverNode.normalize;
              },
              set: function set(value) {
                this._nativeConvolverNode.normalize = value;
              }
            }]);
            return ConvolverNode;
          }(audioNodeConstructor);
        };
        var createConvolverNodeRendererFactory = function createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode) {
          return function () {
            var renderedNativeConvolverNodes = new WeakMap();
            var createConvolverNode = /*#__PURE__*/function () {
              var _ref32 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(proxy, nativeOfflineAudioContext) {
                var nativeConvolverNode, nativeConvolverNodeIsOwnedByContext, options;
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        nativeConvolverNode = getNativeAudioNode(proxy); // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.
                        nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);
                        if (!nativeConvolverNodeIsOwnedByContext) {
                          options = {
                            buffer: nativeConvolverNode.buffer,
                            channelCount: nativeConvolverNode.channelCount,
                            channelCountMode: nativeConvolverNode.channelCountMode,
                            channelInterpretation: nativeConvolverNode.channelInterpretation,
                            disableNormalization: !nativeConvolverNode.normalize
                          };
                          nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);
                        }
                        renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);
                        if (!isNativeAudioNodeFaker(nativeConvolverNode)) {
                          _context3.next = 9;
                          break;
                        }
                        _context3.next = 7;
                        return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0]);
                      case 7:
                        _context3.next = 11;
                        break;
                      case 9:
                        _context3.next = 11;
                        return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode);
                      case 11:
                        return _context3.abrupt("return", nativeConvolverNode);
                      case 12:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));
              return function createConvolverNode(_x9, _x10) {
                return _ref32.apply(this, arguments);
              };
            }();
            return {
              render: function render(proxy, nativeOfflineAudioContext) {
                var renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);
                if (renderedNativeConvolverNode !== undefined) {
                  return Promise.resolve(renderedNativeConvolverNode);
                }
                return createConvolverNode(proxy, nativeOfflineAudioContext);
              }
            };
          };
        };
        var createDecrementCycleCounter = function createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, cycleCounters, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext) {
          return function (audioNode, count) {
            var cycleCounter = cycleCounters.get(audioNode);
            if (cycleCounter === undefined) {
              throw new Error('Missing the expected cycle count.');
            }
            var nativeContext = getNativeContext(audioNode.context);
            var isOffline = isNativeOfflineAudioContext(nativeContext);
            if (cycleCounter === count) {
              cycleCounters.delete(audioNode);
              if (!isOffline && isActiveAudioNode(audioNode)) {
                var nativeSourceAudioNode = getNativeAudioNode(audioNode);
                var _getAudioNodeConnecti7 = getAudioNodeConnections(audioNode),
                  outputs = _getAudioNodeConnecti7.outputs;
                var _iterator15 = _createForOfIteratorHelper(outputs),
                  _step15;
                try {
                  for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                    var output = _step15.value;
                    if (isAudioNodeOutputConnection(output)) {
                      var nativeDestinationAudioNode = getNativeAudioNode(output[0]);
                      connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);
                    } else {
                      var nativeDestinationAudioParam = getNativeAudioParam(output[0]);
                      nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);
                    }
                  }
                } catch (err) {
                  _iterator15.e(err);
                } finally {
                  _iterator15.f();
                }
              }
            } else {
              cycleCounters.set(audioNode, cycleCounter - count);
            }
          };
        };
        var createDeleteActiveInputConnectionToAudioNode = function createDeleteActiveInputConnectionToAudioNode(pickElementFromSet) {
          return function (activeInputs, source, output, input) {
            return pickElementFromSet(activeInputs[input], function (activeInputConnection) {
              return activeInputConnection[0] === source && activeInputConnection[1] === output;
            });
          };
        };
        var isDelayNode = function isDelayNode(audioNode) {
          return 'delayTime' in audioNode;
        };
        var createDetectCycles = function createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) {
          return function detectCycles(chain, nextLink) {
            var audioNode = isAudioNode(nextLink) ? nextLink : getValueForKey(audioParamAudioNodeStore, nextLink);
            if (isDelayNode(audioNode)) {
              return [];
            }
            if (chain[0] === audioNode) {
              return [chain];
            }
            if (chain.includes(audioNode)) {
              return [];
            }
            var _getAudioNodeConnecti8 = getAudioNodeConnections(audioNode),
              outputs = _getAudioNodeConnecti8.outputs;
            return Array.from(outputs).map(function (outputConnection) {
              return detectCycles([].concat(_toConsumableArray(chain), [audioNode]), outputConnection[0]);
            }).reduce(function (mergedCycles, nestedCycles) {
              return mergedCycles.concat(nestedCycles);
            }, []);
          };
        };
        var createEventTargetConstructor = function createEventTargetConstructor(wrapEventListener) {
          return /*#__PURE__*/function () {
            function EventTarget(_nativeEventTarget) {
              _classCallCheck(this, EventTarget);
              this._nativeEventTarget = _nativeEventTarget;
              this._listeners = new WeakMap();
            }
            _createClass(EventTarget, [{
              key: "addEventListener",
              value: function addEventListener(type, listener, options) {
                if (listener !== null) {
                  var wrappedEventListener = this._listeners.get(listener);
                  if (wrappedEventListener === undefined) {
                    wrappedEventListener = wrapEventListener(this, listener);
                    if (typeof listener === 'function') {
                      this._listeners.set(listener, wrappedEventListener);
                    }
                  }
                  this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);
                }
              }
            }, {
              key: "dispatchEvent",
              value: function dispatchEvent(event) {
                return this._nativeEventTarget.dispatchEvent(event);
              }
            }, {
              key: "removeEventListener",
              value: function removeEventListener(type, listener, options) {
                var wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);
                this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);
              }
            }]);
            return EventTarget;
          }();
        };
        var DEFAULT_OPTIONS$2 = {
          channelCount: 2,
          channelCountMode: 'max',
          channelInterpretation: 'speakers',
          gain: 1
        };
        var createGainNodeConstructor = function createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext) {
          return /*#__PURE__*/function (_audioNodeConstructor4) {
            _inherits(GainNode, _audioNodeConstructor4);
            var _super7 = _createSuper(GainNode);
            function GainNode(context, options) {
              var _this17;
              _classCallCheck(this, GainNode);
              var nativeContext = getNativeContext(context);
              var mergedOptions = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS$2), options);
              var nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);
              var isOffline = isNativeOfflineAudioContext(nativeContext);
              var gainNodeRenderer = isOffline ? createGainNodeRenderer() : null;
              _this17 = _super7.call(this, context, false, nativeGainNode, gainNodeRenderer);
              // Bug #74: Safari does not export the correct values for maxValue and minValue.
              _this17._gain = createAudioParam(_assertThisInitialized2(_this17), isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
              return _this17;
            }
            _createClass(GainNode, [{
              key: "gain",
              get: function get() {
                return this._gain;
              }
            }]);
            return GainNode;
          }(audioNodeConstructor);
        };
        var createGainNodeRendererFactory = function createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) {
          return function () {
            var renderedNativeGainNodes = new WeakMap();
            var createGainNode = /*#__PURE__*/function () {
              var _ref33 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(proxy, nativeOfflineAudioContext) {
                var nativeGainNode, nativeGainNodeIsOwnedByContext, options;
                return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        nativeGainNode = getNativeAudioNode(proxy); // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.
                        nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);
                        if (!nativeGainNodeIsOwnedByContext) {
                          options = {
                            channelCount: nativeGainNode.channelCount,
                            channelCountMode: nativeGainNode.channelCountMode,
                            channelInterpretation: nativeGainNode.channelInterpretation,
                            gain: nativeGainNode.gain.value
                          };
                          nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);
                        }
                        renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);
                        if (nativeGainNodeIsOwnedByContext) {
                          _context4.next = 9;
                          break;
                        }
                        _context4.next = 7;
                        return renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);
                      case 7:
                        _context4.next = 11;
                        break;
                      case 9:
                        _context4.next = 11;
                        return connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);
                      case 11:
                        _context4.next = 13;
                        return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode);
                      case 13:
                        return _context4.abrupt("return", nativeGainNode);
                      case 14:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));
              return function createGainNode(_x11, _x12) {
                return _ref33.apply(this, arguments);
              };
            }();
            return {
              render: function render(proxy, nativeOfflineAudioContext) {
                var renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);
                if (renderedNativeGainNode !== undefined) {
                  return Promise.resolve(renderedNativeGainNode);
                }
                return createGainNode(proxy, nativeOfflineAudioContext);
              }
            };
          };
        };
        var createGetAudioNodeRenderer = function createGetAudioNodeRenderer(getAudioNodeConnections) {
          return function (audioNode) {
            var audioNodeConnections = getAudioNodeConnections(audioNode);
            if (audioNodeConnections.renderer === null) {
              throw new Error('Missing the renderer of the given AudioNode in the audio graph.');
            }
            return audioNodeConnections.renderer;
          };
        };
        var createGetAudioNodeTailTime = function createGetAudioNodeTailTime(audioNodeTailTimeStore) {
          return function (audioNode) {
            var _a;
            return (_a = audioNodeTailTimeStore.get(audioNode)) !== null && _a !== void 0 ? _a : 0;
          };
        };
        var createGetAudioParamRenderer = function createGetAudioParamRenderer(getAudioParamConnections) {
          return function (audioParam) {
            var audioParamConnections = getAudioParamConnections(audioParam);
            if (audioParamConnections.renderer === null) {
              throw new Error('Missing the renderer of the given AudioParam in the audio graph.');
            }
            return audioParamConnections.renderer;
          };
        };
        var createInvalidStateError = function createInvalidStateError() {
          return new DOMException('', 'InvalidStateError');
        };
        var createGetNativeContext = function createGetNativeContext(contextStore) {
          return function (context) {
            var nativeContext = contextStore.get(context);
            if (nativeContext === undefined) {
              throw createInvalidStateError();
            }
            return nativeContext;
          };
        };
        var createInvalidAccessError = function createInvalidAccessError() {
          return new DOMException('', 'InvalidAccessError');
        };
        var wrapIIRFilterNodeGetFrequencyResponseMethod = function wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode) {
          nativeIIRFilterNode.getFrequencyResponse = function (getFrequencyResponse) {
            return function (frequencyHz, magResponse, phaseResponse) {
              if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
                throw createInvalidAccessError();
              }
              return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);
            };
          }(nativeIIRFilterNode.getFrequencyResponse);
        };
        var DEFAULT_OPTIONS$1 = {
          channelCount: 2,
          channelCountMode: 'max',
          channelInterpretation: 'speakers'
        };
        var createIIRFilterNodeConstructor = function createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {
          return /*#__PURE__*/function (_audioNodeConstructor5) {
            _inherits(IIRFilterNode, _audioNodeConstructor5);
            var _super8 = _createSuper(IIRFilterNode);
            function IIRFilterNode(context, options) {
              var _this18;
              _classCallCheck(this, IIRFilterNode);
              var nativeContext = getNativeContext(context);
              var isOffline = isNativeOfflineAudioContext(nativeContext);
              var mergedOptions = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS$1), options);
              var nativeIIRFilterNode = createNativeIIRFilterNode(nativeContext, isOffline ? null : context.baseLatency, mergedOptions);
              var iirFilterNodeRenderer = isOffline ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward) : null;
              _this18 = _super8.call(this, context, false, nativeIIRFilterNode, iirFilterNodeRenderer);
              // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.
              // @todo Write a test which allows other browsers to remain unpatched.
              wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);
              _this18._nativeIIRFilterNode = nativeIIRFilterNode;
              // @todo Determine a meaningful tail-time instead of just using one second.
              setAudioNodeTailTime(_assertThisInitialized2(_this18), 1);
              return _this18;
            }
            _createClass(IIRFilterNode, [{
              key: "getFrequencyResponse",
              value: function getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
                return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
              }
            }]);
            return IIRFilterNode;
          }(audioNodeConstructor);
        };

        // This implementation as shamelessly inspired by source code of
        // tslint:disable-next-line:max-line-length
        // {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.
        var filterBuffer = function filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input, output) {
          var inputLength = input.length;
          var i = bufferIndex;
          for (var _j2 = 0; _j2 < inputLength; _j2 += 1) {
            var y = feedforward[0] * input[_j2];
            for (var k = 1; k < minLength; k += 1) {
              var x = i - k & bufferLength - 1; // tslint:disable-line:no-bitwise
              y += feedforward[k] * xBuffer[x];
              y -= feedback[k] * yBuffer[x];
            }
            for (var _k = minLength; _k < feedforwardLength; _k += 1) {
              y += feedforward[_k] * xBuffer[i - _k & bufferLength - 1]; // tslint:disable-line:no-bitwise
            }

            for (var _k2 = minLength; _k2 < feedbackLength; _k2 += 1) {
              y -= feedback[_k2] * yBuffer[i - _k2 & bufferLength - 1]; // tslint:disable-line:no-bitwise
            }

            xBuffer[i] = input[_j2];
            yBuffer[i] = y;
            i = i + 1 & bufferLength - 1; // tslint:disable-line:no-bitwise
            output[_j2] = y;
          }
          return i;
        };
        var filterFullBuffer = function filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) {
          var convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);
          var convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);
          var feedbackLength = convertedFeedback.length;
          var feedforwardLength = convertedFeedforward.length;
          var minLength = Math.min(feedbackLength, feedforwardLength);
          if (convertedFeedback[0] !== 1) {
            for (var _i6 = 0; _i6 < feedbackLength; _i6 += 1) {
              convertedFeedforward[_i6] /= convertedFeedback[0];
            }
            for (var _i7 = 1; _i7 < feedforwardLength; _i7 += 1) {
              convertedFeedback[_i7] /= convertedFeedback[0];
            }
          }
          var bufferLength = 32;
          var xBuffer = new Float32Array(bufferLength);
          var yBuffer = new Float32Array(bufferLength);
          var filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);
          var numberOfChannels = renderedBuffer.numberOfChannels;
          for (var _i8 = 0; _i8 < numberOfChannels; _i8 += 1) {
            var input = renderedBuffer.getChannelData(_i8);
            var output = filteredBuffer.getChannelData(_i8);
            xBuffer.fill(0);
            yBuffer.fill(0);
            filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);
          }
          return filteredBuffer;
        };
        var createIIRFilterNodeRendererFactory = function createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext) {
          return function (feedback, feedforward) {
            var renderedNativeAudioNodes = new WeakMap();
            var filteredBufferPromise = null;
            var createAudioNode = /*#__PURE__*/function () {
              var _ref34 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(proxy, nativeOfflineAudioContext) {
                var nativeAudioBufferSourceNode, nativeIIRFilterNode, nativeIIRFilterNodeIsOwnedByContext, partialOfflineAudioContext, filteredBuffer;
                return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        nativeAudioBufferSourceNode = null;
                        nativeIIRFilterNode = getNativeAudioNode(proxy); // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.
                        nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext); // Bug #9: Safari does not support IIRFilterNodes.
                        if (nativeOfflineAudioContext.createIIRFilter === undefined) {
                          nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {
                            buffer: null,
                            channelCount: 2,
                            channelCountMode: 'max',
                            channelInterpretation: 'speakers',
                            loop: false,
                            loopEnd: 0,
                            loopStart: 0,
                            playbackRate: 1
                          });
                        } else if (!nativeIIRFilterNodeIsOwnedByContext) {
                          // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.
                          nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(feedforward, feedback);
                        }
                        renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);
                        if (!(nativeAudioBufferSourceNode !== null)) {
                          _context6.next = 17;
                          break;
                        }
                        if (!(filteredBufferPromise === null)) {
                          _context6.next = 11;
                          break;
                        }
                        if (!(nativeOfflineAudioContextConstructor === null)) {
                          _context6.next = 9;
                          break;
                        }
                        throw new Error('Missing the native OfflineAudioContext constructor.');
                      case 9:
                        partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(
                        // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.
                        proxy.context.destination.channelCount,
                        // Bug #17: Safari does not yet expose the length.
                        proxy.context.length, nativeOfflineAudioContext.sampleRate);
                        filteredBufferPromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
                          var renderedBuffer;
                          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                            while (1) {
                              switch (_context5.prev = _context5.next) {
                                case 0:
                                  _context5.next = 2;
                                  return renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);
                                case 2:
                                  _context5.next = 4;
                                  return renderNativeOfflineAudioContext(partialOfflineAudioContext);
                                case 4:
                                  renderedBuffer = _context5.sent;
                                  return _context5.abrupt("return", filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward));
                                case 6:
                                case "end":
                                  return _context5.stop();
                              }
                            }
                          }, _callee5);
                        }))();
                      case 11:
                        _context6.next = 13;
                        return filteredBufferPromise;
                      case 13:
                        filteredBuffer = _context6.sent;
                        nativeAudioBufferSourceNode.buffer = filteredBuffer;
                        nativeAudioBufferSourceNode.start(0);
                        return _context6.abrupt("return", nativeAudioBufferSourceNode);
                      case 17:
                        _context6.next = 19;
                        return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);
                      case 19:
                        return _context6.abrupt("return", nativeIIRFilterNode);
                      case 20:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee6);
              }));
              return function createAudioNode(_x13, _x14) {
                return _ref34.apply(this, arguments);
              };
            }();
            return {
              render: function render(proxy, nativeOfflineAudioContext) {
                var renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
                if (renderedNativeAudioNode !== undefined) {
                  return Promise.resolve(renderedNativeAudioNode);
                }
                return createAudioNode(proxy, nativeOfflineAudioContext);
              }
            };
          };
        };
        var createIncrementCycleCounterFactory = function createIncrementCycleCounterFactory(cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode) {
          return function (isOffline) {
            return function (audioNode, count) {
              var cycleCounter = cycleCounters.get(audioNode);
              if (cycleCounter === undefined) {
                if (!isOffline && isActiveAudioNode(audioNode)) {
                  var nativeSourceAudioNode = getNativeAudioNode(audioNode);
                  var _getAudioNodeConnecti9 = getAudioNodeConnections(audioNode),
                    outputs = _getAudioNodeConnecti9.outputs;
                  var _iterator16 = _createForOfIteratorHelper(outputs),
                    _step16;
                  try {
                    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                      var output = _step16.value;
                      if (isAudioNodeOutputConnection(output)) {
                        var nativeDestinationAudioNode = getNativeAudioNode(output[0]);
                        disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);
                      } else {
                        var nativeDestinationAudioParam = getNativeAudioParam(output[0]);
                        nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);
                      }
                    }
                  } catch (err) {
                    _iterator16.e(err);
                  } finally {
                    _iterator16.f();
                  }
                }
                cycleCounters.set(audioNode, count);
              } else {
                cycleCounters.set(audioNode, cycleCounter + count);
              }
            };
          };
        };
        var createIsNativeAudioContext = function createIsNativeAudioContext(nativeAudioContextConstructor) {
          return function (anything) {
            return nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor;
          };
        };
        var createIsNativeAudioNode = function createIsNativeAudioNode(window) {
          return function (anything) {
            return window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode;
          };
        };
        var createIsNativeAudioParam = function createIsNativeAudioParam(window) {
          return function (anything) {
            return window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam;
          };
        };
        var createIsNativeOfflineAudioContext = function createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor) {
          return function (anything) {
            return nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor;
          };
        };
        var createIsSecureContext = function createIsSecureContext(window) {
          return window !== null && window.isSecureContext;
        };
        var createMinimalAudioContextConstructor = function createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor) {
          return /*#__PURE__*/function (_minimalBaseAudioCont) {
            _inherits(MinimalAudioContext, _minimalBaseAudioCont);
            var _super9 = _createSuper(MinimalAudioContext);
            function MinimalAudioContext() {
              var _this19;
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              _classCallCheck(this, MinimalAudioContext);
              if (nativeAudioContextConstructor === null) {
                throw new Error('Missing the native AudioContext constructor.');
              }
              var nativeAudioContext;
              try {
                nativeAudioContext = new nativeAudioContextConstructor(options);
              } catch (err) {
                // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.
                if (err.code === 12 && err.message === 'sampleRate is not in range') {
                  throw createNotSupportedError();
                }
                throw err;
              }
              // Bug #131 Safari returns null when there are four other AudioContexts running already.
              if (nativeAudioContext === null) {
                throw createUnknownError();
              }
              // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.
              if (!isValidLatencyHint(options.latencyHint)) {
                throw new TypeError("The provided value '".concat(options.latencyHint, "' is not a valid enum value of type AudioContextLatencyCategory."));
              }
              // Bug #150 Safari does not support setting the sampleRate.
              if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {
                throw createNotSupportedError();
              }
              _this19 = _super9.call(this, nativeAudioContext, 2);
              var latencyHint = options.latencyHint;
              var _nativeAudioContext = nativeAudioContext,
                sampleRate = _nativeAudioContext.sampleRate;
              // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.
              _this19._baseLatency = typeof nativeAudioContext.baseLatency === 'number' ? nativeAudioContext.baseLatency : latencyHint === 'balanced' ? 512 / sampleRate : latencyHint === 'interactive' || latencyHint === undefined ? 256 / sampleRate : latencyHint === 'playback' ? 1024 / sampleRate :
              /*
               * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a
               * ScriptProcessorNode.
               */
              Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;
              _this19._nativeAudioContext = nativeAudioContext;
              // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.
              if (nativeAudioContextConstructor.name === 'webkitAudioContext') {
                _this19._nativeGainNode = nativeAudioContext.createGain();
                _this19._nativeOscillatorNode = nativeAudioContext.createOscillator();
                _this19._nativeGainNode.gain.value = 1e-37;
                _this19._nativeOscillatorNode.connect(_this19._nativeGainNode).connect(nativeAudioContext.destination);
                _this19._nativeOscillatorNode.start();
              } else {
                _this19._nativeGainNode = null;
                _this19._nativeOscillatorNode = null;
              }
              _this19._state = null;
              /*
               * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes
               * to 'running'.
               */
              if (nativeAudioContext.state === 'running') {
                _this19._state = 'suspended';
                var revokeState = function revokeState() {
                  if (_this19._state === 'suspended') {
                    _this19._state = null;
                  }
                  nativeAudioContext.removeEventListener('statechange', revokeState);
                };
                nativeAudioContext.addEventListener('statechange', revokeState);
              }
              return _this19;
            }
            _createClass(MinimalAudioContext, [{
              key: "baseLatency",
              get: function get() {
                return this._baseLatency;
              }
            }, {
              key: "state",
              get: function get() {
                return this._state !== null ? this._state : this._nativeAudioContext.state;
              }
            }, {
              key: "close",
              value: function close() {
                var _this20 = this;
                // Bug #35: Firefox does not throw an error if the AudioContext was closed before.
                if (this.state === 'closed') {
                  return this._nativeAudioContext.close().then(function () {
                    throw createInvalidStateError();
                  });
                }
                // Bug #34: If the state was set to suspended before it should be revoked now.
                if (this._state === 'suspended') {
                  this._state = null;
                }
                return this._nativeAudioContext.close().then(function () {
                  if (_this20._nativeGainNode !== null && _this20._nativeOscillatorNode !== null) {
                    _this20._nativeOscillatorNode.stop();
                    _this20._nativeGainNode.disconnect();
                    _this20._nativeOscillatorNode.disconnect();
                  }
                  deactivateAudioGraph(_this20);
                });
              }
            }, {
              key: "resume",
              value: function resume() {
                var _this21 = this;
                if (this._state === 'suspended') {
                  return new Promise(function (resolve, reject) {
                    var resolvePromise = function resolvePromise() {
                      _this21._nativeAudioContext.removeEventListener('statechange', resolvePromise);
                      if (_this21._nativeAudioContext.state === 'running') {
                        resolve();
                      } else {
                        _this21.resume().then(resolve, reject);
                      }
                    };
                    _this21._nativeAudioContext.addEventListener('statechange', resolvePromise);
                  });
                }
                return this._nativeAudioContext.resume().catch(function (err) {
                  // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.
                  // Bug #56: Safari invokes the catch handler but without an error.
                  if (err === undefined || err.code === 15) {
                    throw createInvalidStateError();
                  }
                  throw err;
                });
              }
            }, {
              key: "suspend",
              value: function suspend() {
                return this._nativeAudioContext.suspend().catch(function (err) {
                  // Bug #56: Safari invokes the catch handler but without an error.
                  if (err === undefined) {
                    throw createInvalidStateError();
                  }
                  throw err;
                });
              }
            }]);
            return MinimalAudioContext;
          }(minimalBaseAudioContextConstructor);
        };
        var createMinimalBaseAudioContextConstructor = function createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener) {
          return /*#__PURE__*/function (_eventTargetConstruct2) {
            _inherits(MinimalBaseAudioContext, _eventTargetConstruct2);
            var _super10 = _createSuper(MinimalBaseAudioContext);
            function MinimalBaseAudioContext(_nativeContext, numberOfChannels) {
              var _this22;
              _classCallCheck(this, MinimalBaseAudioContext);
              _this22 = _super10.call(this, _nativeContext);
              _this22._nativeContext = _nativeContext;
              CONTEXT_STORE.set(_assertThisInitialized2(_this22), _nativeContext);
              if (isNativeOfflineAudioContext(_nativeContext)) {
                unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());
              }
              _this22._destination = new audioDestinationNodeConstructor(_assertThisInitialized2(_this22), numberOfChannels);
              _this22._listener = createAudioListener(_assertThisInitialized2(_this22), _nativeContext);
              _this22._onstatechange = null;
              return _this22;
            }
            _createClass(MinimalBaseAudioContext, [{
              key: "currentTime",
              get: function get() {
                return this._nativeContext.currentTime;
              }
            }, {
              key: "destination",
              get: function get() {
                return this._destination;
              }
            }, {
              key: "listener",
              get: function get() {
                return this._listener;
              }
            }, {
              key: "onstatechange",
              get: function get() {
                return this._onstatechange;
              },
              set: function set(value) {
                var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;
                this._nativeContext.onstatechange = wrappedListener;
                var nativeOnStateChange = this._nativeContext.onstatechange;
                this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;
              }
            }, {
              key: "sampleRate",
              get: function get() {
                return this._nativeContext.sampleRate;
              }
            }, {
              key: "state",
              get: function get() {
                return this._nativeContext.state;
              }
            }]);
            return MinimalBaseAudioContext;
          }(eventTargetConstructor);
        };
        var testPromiseSupport = function testPromiseSupport(nativeContext) {
          // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.
          var uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
          try {
            // Bug #1: Safari requires a successCallback.
            var promise = nativeContext.decodeAudioData(uint32Array.buffer, function () {
              // Ignore the success callback.
            });
            if (promise === undefined) {
              return false;
            }
            promise.catch(function () {
              // Ignore rejected errors.
            });
            return true;
          } catch (_unused3) {
            // Ignore errors.
          }
          return false;
        };
        var createMonitorConnections = function createMonitorConnections(insertElementInSet, isNativeAudioNode) {
          return function (nativeAudioNode, whenConnected, whenDisconnected) {
            var connections = new Set();
            nativeAudioNode.connect = function (connect) {
              // tslint:disable-next-line:invalid-void no-inferrable-types
              return function (destination) {
                var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var wasDisconnected = connections.size === 0;
                if (isNativeAudioNode(destination)) {
                  // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.
                  connect.call(nativeAudioNode, destination, output, input);
                  insertElementInSet(connections, [destination, output, input], function (connection) {
                    return connection[0] === destination && connection[1] === output && connection[2] === input;
                  }, true);
                  if (wasDisconnected) {
                    whenConnected();
                  }
                  return destination;
                }
                connect.call(nativeAudioNode, destination, output);
                insertElementInSet(connections, [destination, output], function (connection) {
                  return connection[0] === destination && connection[1] === output;
                }, true);
                if (wasDisconnected) {
                  whenConnected();
                }
                return;
              };
            }(nativeAudioNode.connect);
            nativeAudioNode.disconnect = function (disconnect) {
              return function (destinationOrOutput, output, input) {
                var wasConnected = connections.size > 0;
                if (destinationOrOutput === undefined) {
                  disconnect.apply(nativeAudioNode);
                  connections.clear();
                } else if (typeof destinationOrOutput === 'number') {
                  // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.
                  disconnect.call(nativeAudioNode, destinationOrOutput);
                  var _iterator17 = _createForOfIteratorHelper(connections),
                    _step17;
                  try {
                    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                      var connection = _step17.value;
                      if (connection[1] === destinationOrOutput) {
                        connections.delete(connection);
                      }
                    }
                  } catch (err) {
                    _iterator17.e(err);
                  } finally {
                    _iterator17.f();
                  }
                } else {
                  if (isNativeAudioNode(destinationOrOutput)) {
                    // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.
                    disconnect.call(nativeAudioNode, destinationOrOutput, output, input);
                  } else {
                    // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.
                    disconnect.call(nativeAudioNode, destinationOrOutput, output);
                  }
                  var _iterator18 = _createForOfIteratorHelper(connections),
                    _step18;
                  try {
                    for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
                      var _connection = _step18.value;
                      if (_connection[0] === destinationOrOutput && (output === undefined || _connection[1] === output) && (input === undefined || _connection[2] === input)) {
                        connections.delete(_connection);
                      }
                    }
                  } catch (err) {
                    _iterator18.e(err);
                  } finally {
                    _iterator18.f();
                  }
                }
                var isDisconnected = connections.size === 0;
                if (wasConnected && isDisconnected) {
                  whenDisconnected();
                }
              };
            }(nativeAudioNode.disconnect);
            return nativeAudioNode;
          };
        };
        var assignNativeAudioNodeOption = function assignNativeAudioNodeOption(nativeAudioNode, options, option) {
          var value = options[option];
          if (value !== undefined && value !== nativeAudioNode[option]) {
            nativeAudioNode[option] = value;
          }
        };
        var assignNativeAudioNodeOptions = function assignNativeAudioNodeOptions(nativeAudioNode, options) {
          assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');
          assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');
          assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');
        };
        var createNativeAudioBufferConstructor = function createNativeAudioBufferConstructor(window) {
          if (window === null) {
            return null;
          }
          if (window.hasOwnProperty('AudioBuffer')) {
            return window.AudioBuffer;
          }
          return null;
        };
        var assignNativeAudioNodeAudioParamValue = function assignNativeAudioNodeAudioParamValue(nativeAudioNode, options, audioParam) {
          var value = options[audioParam];
          if (value !== undefined && value !== nativeAudioNode[audioParam].value) {
            nativeAudioNode[audioParam].value = value;
          }
        };
        var wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = function wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode) {
          nativeAudioBufferSourceNode.start = function (start) {
            var isScheduled = false;
            return function () {
              var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var duration = arguments.length > 2 ? arguments[2] : undefined;
              if (isScheduled) {
                throw createInvalidStateError();
              }
              start.call(nativeAudioBufferSourceNode, when, offset, duration);
              isScheduled = true;
            };
          }(nativeAudioBufferSourceNode.start);
        };
        var wrapAudioScheduledSourceNodeStartMethodNegativeParameters = function wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioScheduledSourceNode) {
          nativeAudioScheduledSourceNode.start = function (start) {
            return function () {
              var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var duration = arguments.length > 2 ? arguments[2] : undefined;
              if (typeof duration === 'number' && duration < 0 || offset < 0 || when < 0) {
                throw new RangeError("The parameters can't be negative.");
              }
              // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.
              start.call(nativeAudioScheduledSourceNode, when, offset, duration);
            };
          }(nativeAudioScheduledSourceNode.start);
        };
        var wrapAudioScheduledSourceNodeStopMethodNegativeParameters = function wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioScheduledSourceNode) {
          nativeAudioScheduledSourceNode.stop = function (stop) {
            return function () {
              var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              if (when < 0) {
                throw new RangeError("The parameter can't be negative.");
              }
              stop.call(nativeAudioScheduledSourceNode, when);
            };
          }(nativeAudioScheduledSourceNode.stop);
        };
        var createNativeAudioBufferSourceNodeFactory = function createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) {
          return function (nativeContext, options) {
            var nativeAudioBufferSourceNode = nativeContext.createBufferSource();
            assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);
            assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');
            assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');
            // Bug #149: Safari does not yet support the detune AudioParam.
            assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');
            assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');
            assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');
            // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.
            if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, function () {
              return testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext);
            })) {
              wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);
            }
            // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.
            if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, function () {
              return testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext);
            })) {
              wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);
            }
            // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.
            if (!cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, function () {
              return testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext);
            })) {
              wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);
            }
            // Bug #44: Safari does not throw a RangeError yet.
            if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, function () {
              return testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext);
            })) {
              wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);
            }
            // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.
            if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, function () {
              return testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext);
            })) {
              wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);
            }
            // Bug #44: Only Firefox does not throw a RangeError yet.
            if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, function () {
              return testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext);
            })) {
              wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);
            }
            // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.
            addSilentConnection(nativeContext, nativeAudioBufferSourceNode);
            return nativeAudioBufferSourceNode;
          };
        };
        var createNativeAudioContextConstructor = function createNativeAudioContextConstructor(window) {
          if (window === null) {
            return null;
          }
          if (window.hasOwnProperty('AudioContext')) {
            return window.AudioContext;
          }
          return window.hasOwnProperty('webkitAudioContext') ? window.webkitAudioContext : null;
        };
        var createNativeAudioDestinationNodeFactory = function createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors) {
          return function (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) {
            var nativeAudioDestinationNode = nativeContext.destination;
            // Bug #132: Safari does not have the correct channelCount.
            if (nativeAudioDestinationNode.channelCount !== channelCount) {
              try {
                nativeAudioDestinationNode.channelCount = channelCount;
              } catch (_unused4) {
                // Bug #169: Safari throws an error on each attempt to change the channelCount.
              }
            }
            // Bug #83: Safari does not have the correct channelCountMode.
            if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {
              nativeAudioDestinationNode.channelCountMode = 'explicit';
            }
            // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.
            if (nativeAudioDestinationNode.maxChannelCount === 0) {
              Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {
                value: channelCount
              });
            }
            // Bug #168: No browser does yet have an AudioDestinationNode with an output.
            var gainNode = createNativeGainNode(nativeContext, {
              channelCount: channelCount,
              channelCountMode: nativeAudioDestinationNode.channelCountMode,
              channelInterpretation: nativeAudioDestinationNode.channelInterpretation,
              gain: 1
            });
            overwriteAccessors(gainNode, 'channelCount', function (get) {
              return function () {
                return get.call(gainNode);
              };
            }, function (set) {
              return function (value) {
                set.call(gainNode, value);
                try {
                  nativeAudioDestinationNode.channelCount = value;
                } catch (err) {
                  // Bug #169: Safari throws an error on each attempt to change the channelCount.
                  if (value > nativeAudioDestinationNode.maxChannelCount) {
                    throw err;
                  }
                }
              };
            });
            overwriteAccessors(gainNode, 'channelCountMode', function (get) {
              return function () {
                return get.call(gainNode);
              };
            }, function (set) {
              return function (value) {
                set.call(gainNode, value);
                nativeAudioDestinationNode.channelCountMode = value;
              };
            });
            overwriteAccessors(gainNode, 'channelInterpretation', function (get) {
              return function () {
                return get.call(gainNode);
              };
            }, function (set) {
              return function (value) {
                set.call(gainNode, value);
                nativeAudioDestinationNode.channelInterpretation = value;
              };
            });
            Object.defineProperty(gainNode, 'maxChannelCount', {
              get: function get() {
                return nativeAudioDestinationNode.maxChannelCount;
              }
            });
            // @todo This should be disconnected when the context is closed.
            gainNode.connect(nativeAudioDestinationNode);
            return gainNode;
          };
        };
        var createNativeAudioWorkletNodeConstructor = function createNativeAudioWorkletNodeConstructor(window) {
          if (window === null) {
            return null;
          }
          return window.hasOwnProperty('AudioWorkletNode') ? window.AudioWorkletNode : null;
        };
        var computeBufferSize = function computeBufferSize(baseLatency, sampleRate) {
          if (baseLatency === null) {
            return 512;
          }
          return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));
        };
        var createNativeChannelMergerNodeFactory = function createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode) {
          return function (nativeContext, options) {
            var nativeChannelMergerNode = nativeContext.createChannelMerger(options.numberOfInputs);
            /*
             * Bug #20: Safari requires a connection of any kind to treat the input signal correctly.
             * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of
             * the webkitAudioContext is used as a workaround here.
             */
            if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {
              wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);
            }
            assignNativeAudioNodeOptions(nativeChannelMergerNode, options);
            return nativeChannelMergerNode;
          };
        };
        var createNativeConstantSourceNodeFactory = function createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport) {
          return function (nativeContext, options) {
            // Bug #62: Safari does not support ConstantSourceNodes.
            if (nativeContext.createConstantSource === undefined) {
              return createNativeConstantSourceNodeFaker(nativeContext, options);
            }
            var nativeConstantSourceNode = nativeContext.createConstantSource();
            assignNativeAudioNodeOptions(nativeConstantSourceNode, options);
            assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');
            // Bug #44: Safari does not throw a RangeError yet.
            if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, function () {
              return testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext);
            })) {
              wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);
            }
            // Bug #44: Only Firefox does not throw a RangeError yet.
            if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, function () {
              return testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext);
            })) {
              wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);
            }
            // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.
            addSilentConnection(nativeContext, nativeConstantSourceNode);
            return nativeConstantSourceNode;
          };
        };
        var interceptConnections = function interceptConnections(original, interceptor) {
          original.connect = interceptor.connect.bind(interceptor);
          original.disconnect = interceptor.disconnect.bind(interceptor);
          return original;
        };
        var createNativeConstantSourceNodeFakerFactory = function createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) {
          return function (nativeContext, _ref36) {
            var offset = _ref36.offset,
              audioNodeOptions = _objectWithoutProperties(_ref36, _excluded);
            var audioBuffer = nativeContext.createBuffer(1, 2, 44100);
            var audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {
              buffer: null,
              channelCount: 2,
              channelCountMode: 'max',
              channelInterpretation: 'speakers',
              loop: false,
              loopEnd: 0,
              loopStart: 0,
              playbackRate: 1
            });
            var gainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {
              gain: offset
            }));
            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
            var channelData = audioBuffer.getChannelData(0);
            // Bug #95: Safari does not play or loop one sample buffers.
            channelData[0] = 1;
            channelData[1] = 1;
            audioBufferSourceNode.buffer = audioBuffer;
            audioBufferSourceNode.loop = true;
            var nativeConstantSourceNodeFaker = {
              get bufferSize() {
                return undefined;
              },
              get channelCount() {
                return gainNode.channelCount;
              },
              set channelCount(value) {
                gainNode.channelCount = value;
              },
              get channelCountMode() {
                return gainNode.channelCountMode;
              },
              set channelCountMode(value) {
                gainNode.channelCountMode = value;
              },
              get channelInterpretation() {
                return gainNode.channelInterpretation;
              },
              set channelInterpretation(value) {
                gainNode.channelInterpretation = value;
              },
              get context() {
                return gainNode.context;
              },
              get inputs() {
                return [];
              },
              get numberOfInputs() {
                return audioBufferSourceNode.numberOfInputs;
              },
              get numberOfOutputs() {
                return gainNode.numberOfOutputs;
              },
              get offset() {
                return gainNode.gain;
              },
              get onended() {
                return audioBufferSourceNode.onended;
              },
              set onended(value) {
                audioBufferSourceNode.onended = value;
              },
              addEventListener: function addEventListener() {
                return audioBufferSourceNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);
              },
              dispatchEvent: function dispatchEvent() {
                return audioBufferSourceNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);
              },
              removeEventListener: function removeEventListener() {
                return audioBufferSourceNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);
              },
              start: function start() {
                var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                audioBufferSourceNode.start.call(audioBufferSourceNode, when);
              },
              stop: function stop() {
                var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);
              }
            };
            var whenConnected = function whenConnected() {
              return audioBufferSourceNode.connect(gainNode);
            };
            var whenDisconnected = function whenDisconnected() {
              return audioBufferSourceNode.disconnect(gainNode);
            };
            // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.
            addSilentConnection(nativeContext, audioBufferSourceNode);
            return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);
          };
        };
        var createNativeConvolverNodeFactory = function createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors) {
          return function (nativeContext, options) {
            var nativeConvolverNode = nativeContext.createConvolver();
            assignNativeAudioNodeOptions(nativeConvolverNode, options);
            // The normalize property needs to be set before setting the buffer.
            if (options.disableNormalization === nativeConvolverNode.normalize) {
              nativeConvolverNode.normalize = !options.disableNormalization;
            }
            assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer');
            // Bug #113: Safari does allow to set the channelCount to a value larger than 2.
            if (options.channelCount > 2) {
              throw createNotSupportedError();
            }
            overwriteAccessors(nativeConvolverNode, 'channelCount', function (get) {
              return function () {
                return get.call(nativeConvolverNode);
              };
            }, function (set) {
              return function (value) {
                if (value > 2) {
                  throw createNotSupportedError();
                }
                return set.call(nativeConvolverNode, value);
              };
            });
            // Bug #114: Safari allows to set the channelCountMode to 'max'.
            if (options.channelCountMode === 'max') {
              throw createNotSupportedError();
            }
            overwriteAccessors(nativeConvolverNode, 'channelCountMode', function (get) {
              return function () {
                return get.call(nativeConvolverNode);
              };
            }, function (set) {
              return function (value) {
                if (value === 'max') {
                  throw createNotSupportedError();
                }
                return set.call(nativeConvolverNode, value);
              };
            });
            return nativeConvolverNode;
          };
        };
        var createNativeGainNode = function createNativeGainNode(nativeContext, options) {
          var nativeGainNode = nativeContext.createGain();
          assignNativeAudioNodeOptions(nativeGainNode, options);
          assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');
          return nativeGainNode;
        };
        var createNativeIIRFilterNodeFactory = function createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker) {
          return function (nativeContext, baseLatency, options) {
            // Bug #9: Safari does not support IIRFilterNodes.
            if (nativeContext.createIIRFilter === undefined) {
              return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);
            }
            // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.
            var nativeIIRFilterNode = nativeContext.createIIRFilter(options.feedforward, options.feedback);
            assignNativeAudioNodeOptions(nativeIIRFilterNode, options);
            return nativeIIRFilterNode;
          };
        };
        function divide(a, b) {
          var denominator = b[0] * b[0] + b[1] * b[1];
          return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];
        }
        function multiply(a, b) {
          return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];
        }
        function evaluatePolynomial(coefficient, z) {
          var result = [0, 0];
          for (var _i9 = coefficient.length - 1; _i9 >= 0; _i9 -= 1) {
            result = multiply(result, z);
            result[0] += coefficient[_i9];
          }
          return result;
        }
        var createNativeIIRFilterNodeFakerFactory = function createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError) {
          return function (nativeContext, baseLatency, _ref37) {
            var channelCount = _ref37.channelCount,
              channelCountMode = _ref37.channelCountMode,
              channelInterpretation = _ref37.channelInterpretation,
              feedback = _ref37.feedback,
              feedforward = _ref37.feedforward;
            var bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);
            var convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);
            var convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);
            var feedbackLength = convertedFeedback.length;
            var feedforwardLength = convertedFeedforward.length;
            var minLength = Math.min(feedbackLength, feedforwardLength);
            if (feedbackLength === 0 || feedbackLength > 20) {
              throw createNotSupportedError();
            }
            if (convertedFeedback[0] === 0) {
              throw createInvalidStateError();
            }
            if (feedforwardLength === 0 || feedforwardLength > 20) {
              throw createNotSupportedError();
            }
            if (convertedFeedforward[0] === 0) {
              throw createInvalidStateError();
            }
            if (convertedFeedback[0] !== 1) {
              for (var _i10 = 0; _i10 < feedforwardLength; _i10 += 1) {
                convertedFeedforward[_i10] /= convertedFeedback[0];
              }
              for (var _i11 = 1; _i11 < feedbackLength; _i11 += 1) {
                convertedFeedback[_i11] /= convertedFeedback[0];
              }
            }
            var scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);
            scriptProcessorNode.channelCount = channelCount;
            scriptProcessorNode.channelCountMode = channelCountMode;
            scriptProcessorNode.channelInterpretation = channelInterpretation;
            var bufferLength = 32;
            var bufferIndexes = [];
            var xBuffers = [];
            var yBuffers = [];
            for (var _i12 = 0; _i12 < channelCount; _i12 += 1) {
              bufferIndexes.push(0);
              var xBuffer = new Float32Array(bufferLength);
              var yBuffer = new Float32Array(bufferLength);
              xBuffer.fill(0);
              yBuffer.fill(0);
              xBuffers.push(xBuffer);
              yBuffers.push(yBuffer);
            }
            // tslint:disable-next-line:deprecation
            scriptProcessorNode.onaudioprocess = function (event) {
              var inputBuffer = event.inputBuffer;
              var outputBuffer = event.outputBuffer;
              var numberOfChannels = inputBuffer.numberOfChannels;
              for (var _i13 = 0; _i13 < numberOfChannels; _i13 += 1) {
                var input = inputBuffer.getChannelData(_i13);
                var output = outputBuffer.getChannelData(_i13);
                bufferIndexes[_i13] = filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffers[_i13], yBuffers[_i13], bufferIndexes[_i13], bufferLength, input, output);
              }
            };
            var nyquist = nativeContext.sampleRate / 2;
            var nativeIIRFilterNodeFaker = {
              get bufferSize() {
                return bufferSize;
              },
              get channelCount() {
                return scriptProcessorNode.channelCount;
              },
              set channelCount(value) {
                scriptProcessorNode.channelCount = value;
              },
              get channelCountMode() {
                return scriptProcessorNode.channelCountMode;
              },
              set channelCountMode(value) {
                scriptProcessorNode.channelCountMode = value;
              },
              get channelInterpretation() {
                return scriptProcessorNode.channelInterpretation;
              },
              set channelInterpretation(value) {
                scriptProcessorNode.channelInterpretation = value;
              },
              get context() {
                return scriptProcessorNode.context;
              },
              get inputs() {
                return [scriptProcessorNode];
              },
              get numberOfInputs() {
                return scriptProcessorNode.numberOfInputs;
              },
              get numberOfOutputs() {
                return scriptProcessorNode.numberOfOutputs;
              },
              addEventListener: function addEventListener() {
                // @todo Dissallow adding an audioprocess listener.
                return scriptProcessorNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);
              },
              dispatchEvent: function dispatchEvent() {
                return scriptProcessorNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);
              },
              getFrequencyResponse: function getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
                if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
                  throw createInvalidAccessError();
                }
                var length = frequencyHz.length;
                for (var _i14 = 0; _i14 < length; _i14 += 1) {
                  var omega = -Math.PI * (frequencyHz[_i14] / nyquist);
                  var z = [Math.cos(omega), Math.sin(omega)];
                  var numerator = evaluatePolynomial(convertedFeedforward, z);
                  var denominator = evaluatePolynomial(convertedFeedback, z);
                  var response = divide(numerator, denominator);
                  magResponse[_i14] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);
                  phaseResponse[_i14] = Math.atan2(response[1], response[0]);
                }
              },
              removeEventListener: function removeEventListener() {
                return scriptProcessorNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);
              }
            };
            return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);
          };
        };
        var createNativeOfflineAudioContextConstructor = function createNativeOfflineAudioContextConstructor(window) {
          if (window === null) {
            return null;
          }
          if (window.hasOwnProperty('OfflineAudioContext')) {
            return window.OfflineAudioContext;
          }
          return window.hasOwnProperty('webkitOfflineAudioContext') ? window.webkitOfflineAudioContext : null;
        };
        var createNativeScriptProcessorNode = function createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) {
          return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels); // tslint:disable-line deprecation
        };

        var createNotSupportedError = function createNotSupportedError() {
          return new DOMException('', 'NotSupportedError');
        };
        var createRenderAutomation = function createRenderAutomation(getAudioParamRenderer, renderInputsOfAudioParam) {
          return function (nativeOfflineAudioContext, audioParam, nativeAudioParam) {
            var audioParamRenderer = getAudioParamRenderer(audioParam);
            audioParamRenderer.replay(nativeAudioParam);
            return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);
          };
        };
        var createRenderInputsOfAudioNode = function createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) {
          return /*#__PURE__*/function () {
            var _ref38 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(audioNode, nativeOfflineAudioContext, nativeAudioNode) {
              var audioNodeConnections;
              return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      audioNodeConnections = getAudioNodeConnections(audioNode);
                      _context8.next = 3;
                      return Promise.all(audioNodeConnections.activeInputs.map(function (connections, input) {
                        return Array.from(connections).map( /*#__PURE__*/function () {
                          var _ref40 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(_ref39) {
                            var _ref41, source, output, audioNodeRenderer, renderedNativeAudioNode, destination;
                            return _regeneratorRuntime().wrap(function _callee7$(_context7) {
                              while (1) {
                                switch (_context7.prev = _context7.next) {
                                  case 0:
                                    _ref41 = _slicedToArray(_ref39, 2), source = _ref41[0], output = _ref41[1];
                                    audioNodeRenderer = getAudioNodeRenderer(source);
                                    _context7.next = 4;
                                    return audioNodeRenderer.render(source, nativeOfflineAudioContext);
                                  case 4:
                                    renderedNativeAudioNode = _context7.sent;
                                    destination = audioNode.context.destination;
                                    if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {
                                      renderedNativeAudioNode.connect(nativeAudioNode, output, input);
                                    }
                                  case 7:
                                  case "end":
                                    return _context7.stop();
                                }
                              }
                            }, _callee7);
                          }));
                          return function (_x18) {
                            return _ref40.apply(this, arguments);
                          };
                        }());
                      }).reduce(function (allRenderingPromises, renderingPromises) {
                        return [].concat(_toConsumableArray(allRenderingPromises), _toConsumableArray(renderingPromises));
                      }, []));
                    case 3:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8);
            }));
            return function (_x15, _x16, _x17) {
              return _ref38.apply(this, arguments);
            };
          }();
        };
        var createRenderInputsOfAudioParam = function createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle) {
          return /*#__PURE__*/function () {
            var _ref42 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(audioParam, nativeOfflineAudioContext, nativeAudioParam) {
              var audioParamConnections;
              return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      audioParamConnections = getAudioParamConnections(audioParam);
                      _context10.next = 3;
                      return Promise.all(Array.from(audioParamConnections.activeInputs).map( /*#__PURE__*/function () {
                        var _ref44 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(_ref43) {
                          var _ref45, source, output, audioNodeRenderer, renderedNativeAudioNode;
                          return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                            while (1) {
                              switch (_context9.prev = _context9.next) {
                                case 0:
                                  _ref45 = _slicedToArray(_ref43, 2), source = _ref45[0], output = _ref45[1];
                                  audioNodeRenderer = getAudioNodeRenderer(source);
                                  _context9.next = 4;
                                  return audioNodeRenderer.render(source, nativeOfflineAudioContext);
                                case 4:
                                  renderedNativeAudioNode = _context9.sent;
                                  if (!isPartOfACycle(source)) {
                                    renderedNativeAudioNode.connect(nativeAudioParam, output);
                                  }
                                case 6:
                                case "end":
                                  return _context9.stop();
                              }
                            }
                          }, _callee9);
                        }));
                        return function (_x22) {
                          return _ref44.apply(this, arguments);
                        };
                      }()));
                    case 3:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10);
            }));
            return function (_x19, _x20, _x21) {
              return _ref42.apply(this, arguments);
            };
          }();
        };
        var createRenderNativeOfflineAudioContext = function createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, testOfflineAudioContextCurrentTimeSupport) {
          return function (nativeOfflineAudioContext) {
            // Bug #21: Safari does not support promises yet.
            if (cacheTestResult(testPromiseSupport, function () {
              return testPromiseSupport(nativeOfflineAudioContext);
            })) {
              // Bug #158: Chrome and Edge do not advance currentTime if it is not accessed while rendering the audio.
              return Promise.resolve(cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then(function (isOfflineAudioContextCurrentTimeSupported) {
                if (!isOfflineAudioContextCurrentTimeSupported) {
                  var scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);
                  nativeOfflineAudioContext.oncomplete = function () {
                    scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation
                    scriptProcessorNode.disconnect();
                  };
                  scriptProcessorNode.onaudioprocess = function () {
                    return nativeOfflineAudioContext.currentTime;
                  }; // tslint:disable-line:deprecation
                  scriptProcessorNode.connect(nativeOfflineAudioContext.destination);
                }
                return nativeOfflineAudioContext.startRendering();
              });
            }
            return new Promise(function (resolve) {
              // Bug #48: Safari does not render an OfflineAudioContext without any connected node.
              var gainNode = createNativeGainNode(nativeOfflineAudioContext, {
                channelCount: 1,
                channelCountMode: 'explicit',
                channelInterpretation: 'discrete',
                gain: 0
              });
              nativeOfflineAudioContext.oncomplete = function (event) {
                gainNode.disconnect();
                resolve(event.renderedBuffer);
              };
              gainNode.connect(nativeOfflineAudioContext.destination);
              nativeOfflineAudioContext.startRendering();
            });
          };
        };
        var createSetAudioNodeTailTime = function createSetAudioNodeTailTime(audioNodeTailTimeStore) {
          return function (audioNode, tailTime) {
            return audioNodeTailTimeStore.set(audioNode, tailTime);
          };
        };

        // Bug #33: Safari exposes an AudioBuffer but it can't be used as a constructor.
        var createTestAudioBufferConstructorSupport = function createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor) {
          return function () {
            if (nativeAudioBufferConstructor === null) {
              return false;
            }
            try {
              new nativeAudioBufferConstructor({
                length: 1,
                sampleRate: 44100
              }); // tslint:disable-line:no-unused-expression
            } catch (_unused5) {
              return false;
            }
            return true;
          };
        };
        var createTestOfflineAudioContextCurrentTimeSupport = function createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor) {
          return function () {
            if (nativeOfflineAudioContextConstructor === null) {
              return Promise.resolve(false);
            }
            var nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);
            // Bug #48: Safari does not render an OfflineAudioContext without any connected node.
            var gainNode = createNativeGainNode(nativeOfflineAudioContext, {
              channelCount: 1,
              channelCountMode: 'explicit',
              channelInterpretation: 'discrete',
              gain: 0
            });
            // Bug #21: Safari does not support promises yet.
            return new Promise(function (resolve) {
              nativeOfflineAudioContext.oncomplete = function () {
                gainNode.disconnect();
                resolve(nativeOfflineAudioContext.currentTime !== 0);
              };
              nativeOfflineAudioContext.startRendering();
            });
          };
        };
        var createUnknownError = function createUnknownError() {
          return new DOMException('', 'UnknownError');
        };
        var createWindow = function createWindow() {
          return typeof window === 'undefined' ? null : window;
        };
        var createWrapAudioBufferCopyChannelMethods = function createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError) {
          return function (audioBuffer) {
            audioBuffer.copyFromChannel = function (destination, channelNumberAsNumber) {
              var bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              var bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);
              var channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);
              if (channelNumber >= audioBuffer.numberOfChannels) {
                throw createIndexSizeError();
              }
              var audioBufferLength = audioBuffer.length;
              var channelData = audioBuffer.getChannelData(channelNumber);
              var destinationLength = destination.length;
              for (var _i15 = bufferOffset < 0 ? -bufferOffset : 0; _i15 + bufferOffset < audioBufferLength && _i15 < destinationLength; _i15 += 1) {
                destination[_i15] = channelData[_i15 + bufferOffset];
              }
            };
            audioBuffer.copyToChannel = function (source, channelNumberAsNumber) {
              var bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              var bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);
              var channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);
              if (channelNumber >= audioBuffer.numberOfChannels) {
                throw createIndexSizeError();
              }
              var audioBufferLength = audioBuffer.length;
              var channelData = audioBuffer.getChannelData(channelNumber);
              var sourceLength = source.length;
              for (var _i16 = bufferOffset < 0 ? -bufferOffset : 0; _i16 + bufferOffset < audioBufferLength && _i16 < sourceLength; _i16 += 1) {
                channelData[_i16 + bufferOffset] = source[_i16];
              }
            };
          };
        };
        var createWrapAudioBufferCopyChannelMethodsOutOfBounds = function createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong) {
          return function (audioBuffer) {
            audioBuffer.copyFromChannel = function (copyFromChannel) {
              return function (destination, channelNumberAsNumber) {
                var bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);
                var channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);
                if (bufferOffset < audioBuffer.length) {
                  return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);
                }
              };
            }(audioBuffer.copyFromChannel);
            audioBuffer.copyToChannel = function (copyToChannel) {
              return function (source, channelNumberAsNumber) {
                var bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);
                var channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);
                if (bufferOffset < audioBuffer.length) {
                  return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);
                }
              };
            }(audioBuffer.copyToChannel);
          };
        };
        var createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = function createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors) {
          return function (nativeAudioBufferSourceNode, nativeContext) {
            var nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);
            if (nativeAudioBufferSourceNode.buffer === null) {
              nativeAudioBufferSourceNode.buffer = nullifiedBuffer;
            }
            overwriteAccessors(nativeAudioBufferSourceNode, 'buffer', function (get) {
              return function () {
                var value = get.call(nativeAudioBufferSourceNode);
                return value === nullifiedBuffer ? null : value;
              };
            }, function (set) {
              return function (value) {
                return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);
              };
            });
          };
        };
        var createWrapChannelMergerNode = function createWrapChannelMergerNode(createInvalidStateError, monitorConnections) {
          return function (nativeContext, channelMergerNode) {
            // Bug #15: Safari does not return the default properties.
            channelMergerNode.channelCount = 1;
            channelMergerNode.channelCountMode = 'explicit';
            // Bug #16: Safari does not throw an error when setting a different channelCount or channelCountMode.
            Object.defineProperty(channelMergerNode, 'channelCount', {
              get: function get() {
                return 1;
              },
              set: function set() {
                throw createInvalidStateError();
              }
            });
            Object.defineProperty(channelMergerNode, 'channelCountMode', {
              get: function get() {
                return 'explicit';
              },
              set: function set() {
                throw createInvalidStateError();
              }
            });
            // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.
            var audioBufferSourceNode = nativeContext.createBufferSource();
            var whenConnected = function whenConnected() {
              var length = channelMergerNode.numberOfInputs;
              for (var _i17 = 0; _i17 < length; _i17 += 1) {
                audioBufferSourceNode.connect(channelMergerNode, 0, _i17);
              }
            };
            var whenDisconnected = function whenDisconnected() {
              return audioBufferSourceNode.disconnect(channelMergerNode);
            };
            monitorConnections(channelMergerNode, whenConnected, whenDisconnected);
          };
        };
        var getFirstSample = function getFirstSample(audioBuffer, buffer, channelNumber) {
          // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
          if (audioBuffer.copyFromChannel === undefined) {
            return audioBuffer.getChannelData(channelNumber)[0];
          }
          audioBuffer.copyFromChannel(buffer, channelNumber);
          return buffer[0];
        };
        var overwriteAccessors = function overwriteAccessors(object, property, createGetter, createSetter) {
          var prototype = object;
          while (!prototype.hasOwnProperty(property)) {
            prototype = Object.getPrototypeOf(prototype);
          }
          var _Object$getOwnPropert = Object.getOwnPropertyDescriptor(prototype, property),
            get = _Object$getOwnPropert.get,
            set = _Object$getOwnPropert.set;
          Object.defineProperty(object, property, {
            get: createGetter(get),
            set: createSetter(set)
          });
        };
        var setValueAtTimeUntilPossible = function setValueAtTimeUntilPossible(audioParam, value, startTime) {
          try {
            audioParam.setValueAtTime(value, startTime);
          } catch (err) {
            if (err.code !== 9) {
              throw err;
            }
            setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);
          }
        };
        var testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = function testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext) {
          var nativeAudioBufferSourceNode = nativeContext.createBufferSource();
          nativeAudioBufferSourceNode.start();
          try {
            nativeAudioBufferSourceNode.start();
          } catch (_unused6) {
            return true;
          }
          return false;
        };
        var testAudioBufferSourceNodeStartMethodOffsetClampingSupport = function testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext) {
          var nativeAudioBufferSourceNode = nativeContext.createBufferSource();
          var nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);
          nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
          try {
            nativeAudioBufferSourceNode.start(0, 1);
          } catch (_unused7) {
            return false;
          }
          return true;
        };
        var testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = function testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext) {
          var nativeAudioBufferSourceNode = nativeContext.createBufferSource();
          nativeAudioBufferSourceNode.start();
          try {
            nativeAudioBufferSourceNode.stop();
          } catch (_unused8) {
            return false;
          }
          return true;
        };
        var testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = function testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext) {
          var nativeAudioBufferSourceNode = nativeContext.createOscillator();
          try {
            nativeAudioBufferSourceNode.start(-1);
          } catch (err) {
            return err instanceof RangeError;
          }
          return false;
        };
        var testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = function testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext) {
          var nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);
          var nativeAudioBufferSourceNode = nativeContext.createBufferSource();
          nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
          nativeAudioBufferSourceNode.start();
          nativeAudioBufferSourceNode.stop();
          try {
            nativeAudioBufferSourceNode.stop();
            return true;
          } catch (_unused9) {
            return false;
          }
        };
        var testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = function testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext) {
          var nativeAudioBufferSourceNode = nativeContext.createOscillator();
          try {
            nativeAudioBufferSourceNode.stop(-1);
          } catch (err) {
            return err instanceof RangeError;
          }
          return false;
        };
        var wrapAudioBufferSourceNodeStartMethodOffsetClamping = function wrapAudioBufferSourceNodeStartMethodOffsetClamping(nativeAudioBufferSourceNode) {
          nativeAudioBufferSourceNode.start = function (start) {
            return function () {
              var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var duration = arguments.length > 2 ? arguments[2] : undefined;
              var buffer = nativeAudioBufferSourceNode.buffer;
              // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.
              var clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);
              // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.
              if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {
                start.call(nativeAudioBufferSourceNode, when, 0, 0);
              } else {
                start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);
              }
            };
          }(nativeAudioBufferSourceNode.start);
        };
        var wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = function wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioScheduledSourceNode, nativeContext) {
          var nativeGainNode = nativeContext.createGain();
          nativeAudioScheduledSourceNode.connect(nativeGainNode);
          var disconnectGainNode = function (disconnect) {
            return function () {
              // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.
              disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);
              nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);
            };
          }(nativeAudioScheduledSourceNode.disconnect);
          nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);
          interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);
          nativeAudioScheduledSourceNode.stop = function (stop) {
            var isStopped = false;
            return function () {
              var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              if (isStopped) {
                try {
                  stop.call(nativeAudioScheduledSourceNode, when);
                } catch (_unused10) {
                  nativeGainNode.gain.setValueAtTime(0, when);
                }
              } else {
                stop.call(nativeAudioScheduledSourceNode, when);
                isStopped = true;
              }
            };
          }(nativeAudioScheduledSourceNode.stop);
        };
        var wrapEventListener = function wrapEventListener(target, eventListener) {
          return function (event) {
            var descriptor = {
              value: target
            };
            Object.defineProperties(event, {
              currentTarget: descriptor,
              target: descriptor
            });
            if (typeof eventListener === 'function') {
              return eventListener.call(target, event);
            }
            return eventListener.handleEvent.call(target, event);
          };
        };
        var addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);
        var addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);
        var deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);
        var audioNodeTailTimeStore = new WeakMap();
        var getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);
        var cacheTestResult = createCacheTestResult(new Map(), new WeakMap());
        var window$1 = createWindow();
        var getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);
        var renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);
        var getNativeContext = createGetNativeContext(CONTEXT_STORE);
        var nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window$1);
        var isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);
        var audioParamAudioNodeStore = new WeakMap();
        var eventTargetConstructor = createEventTargetConstructor(wrapEventListener);
        var nativeAudioContextConstructor = createNativeAudioContextConstructor(window$1);
        var isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);
        var isNativeAudioNode = createIsNativeAudioNode(window$1);
        var isNativeAudioParam = createIsNativeAudioParam(window$1);
        var nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window$1);
        var audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode), cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor);
        var audioBufferStore = new WeakSet();
        var nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window$1);
        var convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));
        var wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);
        var wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);
        var audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
        var addSilentConnection = createAddSilentConnection(createNativeGainNode);
        var renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);
        var connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);
        var createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);
        var renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);
        var createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
        var createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible);
        var audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
        var audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);
        var setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);
        var monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);
        var wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);
        var createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);
        var createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);
        var createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);
        var createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors);
        var createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);
        var convolverNodeConstructor = createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
        var createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
        var gainNodeConstructor = createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);
        var createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);
        var renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));
        var createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
        var createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);
        var iIRFilterNodeConstructor = createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
        var createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors);
        var unrenderedAudioWorkletNodeStore = new WeakMap();
        var minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener);
        createIsSecureContext(window$1);
        var minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);
        var SpectrumAudio = /*#__PURE__*/function () {
          function SpectrumAudio(endpoint) {
            var _this23 = this;
            _classCallCheck(this, SpectrumAudio);
            this.endpoint = endpoint;
            this.playAmount = 0;
            this.playMovingAverage = [];
            this.playSampleLength = 1;
            this.audioQueue = [];
            this.demodulation = 'USB';

            // Audio controls
            this.mute = false;
            this.squelchMute = false;
            this.squelch = false;
            this.squelchThreshold = 0;
            this.power = 1;

            // for chrome
            var userGestureFunc = function userGestureFunc() {
              if (_this23.audioCtx && _this23.audioCtx.state !== 'running') {
                _this23.audioCtx.resume();
              }
              document.documentElement.removeEventListener('mousedown', userGestureFunc);
            };
            document.documentElement.addEventListener('mousedown', userGestureFunc);
            this.mode = 0;
            this.d = 10;
            this.v = 10;
            this.n2 = 10;
            this.n1 = 10;
            this.var = 10;
            this.highThres = 1;
            this.lastdebug = 0;
          }
          _createClass(SpectrumAudio, [{
            key: "init",
            value: function () {
              var _init2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
                var _this24 = this;
                return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                  while (1) {
                    switch (_context11.prev = _context11.next) {
                      case 0:
                        if (!this.promise) {
                          _context11.next = 2;
                          break;
                        }
                        return _context11.abrupt("return", this.promise);
                      case 2:
                        this.audioProcessor = new AudioProcessor();
                        this.promise = new Promise(function (resolve, reject) {
                          _this24.resolvePromise = resolve;
                          _this24.rejectPromise = reject;
                        });
                        this.audioSocket = new WebSocket(this.endpoint);
                        this.audioSocket.binaryType = 'arraybuffer';
                        this.firstAudioMessage = true;
                        this.audioSocket.onmessage = this.socketMessageInitial.bind(this);
                        return _context11.abrupt("return", this.promise);
                      case 9:
                      case "end":
                        return _context11.stop();
                    }
                  }
                }, _callee11, this);
              }));
              function init() {
                return _init2.apply(this, arguments);
              }
              return init;
            }()
          }, {
            key: "stop",
            value: function stop() {
              this.audioSocket.close();
              this.decoder.destroy();
              if (this.resampler) {
                this.resampler.destroy();
              }
            }
          }, {
            key: "initAudio",
            value: function initAudio(settings) {
              var _this25 = this;
              var sampleRate = this.audioOutputSps;
              try {
                this.audioCtx = new minimalAudioContextConstructor({
                  sampleRate: sampleRate
                });
              } catch (_unused11) {
                this.resolvePromise();
                return;
              }

              // this.decoder = createFlacDecoder()

              if (settings.audio_compression === 'flac') {
                this.decoder = createFlacDecoder();
              } else if (settings.audio_compression === 'opus') {
                this.decoder = createOpusDecoder(Math.min(this.trueAudioSps, 48000));
              }
              this.audioStartTime = this.audioCtx.currentTime;
              this.playTime = this.audioCtx.currentTime + 0.1;
              this.playStartTime = this.audioCtx.currentTime;
              this.gainNode = new gainNodeConstructor(this.audioCtx);
              this.setGain(10);
              this.gainNode.connect(this.audioCtx.destination);
              this.convolverNode = new convolverNodeConstructor(this.audioCtx);
              this.setLowpass(15000);
              this.convolverNode.connect(this.gainNode);
              this.audioInputNode = this.convolverNode;

              // this.wbfmStereo = new LiquidDSP.WBFMStereo(this.trueAudioSps)

              if (this.trueAudioSps > 96000) {
                createResampler(this.trueAudioSps, 96000).then(function (src) {
                  _this25.resampler = src;
                  _this25.resolvePromise(settings);
                });
              } else {
                this.resolvePromise(settings);
              }
            }
          }, {
            key: "setFIRFilter",
            value: function setFIRFilter(fir) {
              var firAudioBuffer = new audioBufferConstructor({
                length: fir.length,
                numberOfChannels: 1,
                sampleRate: this.audioOutputSps
              });
              firAudioBuffer.copyToChannel(fir, 0, 0);
              this.convolverNode.buffer = firAudioBuffer;
            }
          }, {
            key: "setLowpass",
            value: function setLowpass(lowpass) {
              var sampleRate = this.audioOutputSps;
              // Bypass the FIR filter if the sample rate is low enough
              if (lowpass >= sampleRate / 2) {
                lowpass = sampleRate / 2;
              }
              var fir = LiquidDSP.FirDesKaiser(1000 / sampleRate, lowpass / sampleRate, 60, 0);
              this.setFIRFilter(fir);
            }
          }, {
            key: "setFmDeemph",
            value: function setFmDeemph(tau) {
              if (tau === 0) {
                this.audioInputNode = this.convolverNode;
                return;
              }
              // FM deemph https://github.com/gnuradio/gnuradio/blob/master/gr-analog/python/analog/fm_emph.py
              // Digital corner frequency
              var wc = 1.0 / tau;
              var fs = this.audioOutputSps;

              // Prewarped analog corner frequency
              var wca = 2.0 * fs * Math.tan(wc / (2.0 * fs));

              // Resulting digital pole, zero, and gain term from the bilinear
              // transformation of H(s) = w_ca / (s + w_ca) to
              // H(z) = b0 (1 - z1 z^-1)/(1 - p1 z^-1)
              var k = -wca / (2.0 * fs);
              var z1 = -1.0;
              var p1 = (1.0 + k) / (1.0 - k);
              var b0 = -k / (1.0 - k);
              var feedForwardTaps = [b0 * 1.0, b0 * -z1];
              var feedBackwardTaps = [1.0, -p1];
              this.fmDeemphNode = new iIRFilterNodeConstructor(this.audioCtx, {
                feedforward: feedForwardTaps,
                feedback: feedBackwardTaps
              });
              this.fmDeemphNode.connect(this.convolverNode);
              this.audioInputNode = this.fmDeemphNode;
            }
          }, {
            key: "socketMessageInitial",
            value: function socketMessageInitial(event) {
              // first message gives the parameters in json
              var settings = JSON.parse(event.data);
              this.settings = settings;
              this.fftSize = settings.fft_size;
              this.audioMaxSize = settings.fft_result_size;
              this.baseFreq = settings.basefreq;
              this.totalBandwidth = settings.total_bandwidth;
              this.sps = settings.sps;
              this.audioOverlap = settings.fft_overlap / 2;
              this.audioMaxSps = settings.audio_max_sps;
              this.audioL = settings.defaults.l;
              this.audioM = settings.defaults.m;
              this.audioR = settings.defaults.r;
              var targetFFTBins = Math.ceil(this.audioMaxSps * this.audioMaxSize / this.sps / 4) * 4;
              this.trueAudioSps = targetFFTBins / this.audioMaxSize * this.sps;
              this.audioOutputSps = Math.min(this.audioMaxSps, 96000);
              this.audioSocket.onmessage = this.socketMessage.bind(this);
              this.initAudio(settings);
              console.log('Audio Samplerate: ', this.trueAudioSps);
            }
          }, {
            key: "socketMessage",
            value: function socketMessage(event) {
              if (event.data instanceof ArrayBuffer) {
                var floats = new Float64Array(event.data.slice(0, 3 * 8));
                // const ints = new Int32Array(event.data.slice(0, 3 * 8))
                var bytes = new Uint8Array(event.data);
                var receivedPower = floats[2];
                this.power = 0.5 * this.power + 0.5 * receivedPower || 1;
                var dBpower = 20 * Math.log10(Math.sqrt(this.power) / 2);
                this.dBPower = dBpower;
                if (this.squelch && dBpower < this.squelchThreshold) {
                  this.squelchMute = true;
                } else {
                  this.squelchMute = false;
                }
                if (!this.audioCtx) return;
                var encodedArray = bytes.subarray(3 * 8);
                this.decode(encodedArray);
              }
            }
          }, {
            key: "decode",
            value: function decode(encoded) {
              var sample = new Int16Array();
              try {
                sample = this.decoder.decode(encoded);
              } catch (err) {
                return;
              }
              // If the decoder does not output samples, return immediately
              if (sample.length === 0) {
                return;
              }

              // Scale the array
              var pcmArray = new Float32Array(sample);
              pcmArray = pcmArray.map(function (x) {
                return x / 65536;
              });

              // Resample

              this.intervals = this.intervals || liveMovingAverage(10000, 0);
              this.lens = this.lens || liveMovingAverage(10000, 0);
              this.lastReceived = this.lastReceived || 0;
              // For checking sample rate
              if (this.lastReceived === 0) {
                this.lastReceived = performance.now();
              } else {
                var curReceived = performance.now();
                var delay = curReceived - this.lastReceived;
                this.intervals.push(delay);
                this.lastReceived = curReceived;
                this.lens.push(pcmArray.length);
                var updatedv = true;
                if (this.mode === 0) {
                  if (Math.abs(delay - this.n1) > Math.abs(this.v) * 2 + 800) {
                    this.var = 0;
                    this.mode = 1;
                  }
                } else {
                  this.var = this.var / 2 + Math.abs((2 * delay - this.n1 - this.n2) / 8);
                  if (this.var <= 63) {
                    this.mode = 0;
                    updatedv = false;
                  }
                }
                if (updatedv) {
                  if (this.mode === 0) {
                    this.d = 0.125 * delay + 0.875 * this.d;
                  } else {
                    this.d = this.d + delay - this.n1;
                  }
                  this.v = 0.125 * Math.abs(delay - this.d) + 0.875 * this.v;
                }
                this.n2 = this.n1;
                this.n1 = delay;
              }
              this.pcmArray = pcmArray;
              if (this.signalDecoder) {
                this.signalDecoder.decode(pcmArray);
              }
              if (this.resampler) {
                pcmArray = this.resampler.resample(pcmArray);
              }
              pcmArray = this.audioProcessor.process(pcmArray);
              this.playAudio(pcmArray);
            }
          }, {
            key: "updateAudioParams",
            value: function updateAudioParams() {
              this.audioSocket.send(JSON.stringify({
                cmd: 'window',
                l: this.audioL,
                m: this.audioM,
                r: this.audioR
              }));
            }
          }, {
            key: "setAudioDemodulation",
            value: function setAudioDemodulation(demodulation) {
              this.demodulation = demodulation;
              this.audioSocket.send(JSON.stringify({
                cmd: 'demodulation',
                demodulation: demodulation
              }));
            }
          }, {
            key: "setAudioRange",
            value: function setAudioRange(audioL, audioM, audioR) {
              this.audioL = audioL;
              this.audioM = audioM;
              this.audioR = audioR;
              this.updateAudioParams();
            }
          }, {
            key: "getAudioRange",
            value: function getAudioRange() {
              return [this.audioL, this.audioM, this.audioR];
            }
          }, {
            key: "setAudioOptions",
            value: function setAudioOptions(options) {
              this.audioOptions = options;
              this.audioSocket.send(JSON.stringify({
                cmd: 'options',
                options: options
              }));
            }
          }, {
            key: "setGain",
            value: function setGain(gain) {
              this.gain = gain;
              this.gainNode.gain.value = gain;
            }
          }, {
            key: "setMute",
            value: function setMute(mute) {
              if (mute === this.mute) {
                return;
              }
              this.mute = mute;
              this.audioSocket.send(JSON.stringify({
                cmd: 'mute',
                mute: mute
              }));
            }
          }, {
            key: "setSquelch",
            value: function setSquelch(squelch) {
              this.squelch = squelch;
            }
          }, {
            key: "setSquelchThreshold",
            value: function setSquelchThreshold(squelchThreshold) {
              this.squelchThreshold = squelchThreshold;
            }
          }, {
            key: "getPowerDb",
            value: function getPowerDb() {
              return this.dBPower;
            }
          }, {
            key: "setUserID",
            value: function setUserID(userID) {
              this.audioSocket.send(JSON.stringify({
                cmd: 'userid',
                userid: userID
              }));
            }
          }, {
            key: "setSignalDecoder",
            value: function setSignalDecoder(decoder) {
              this.signalDecoder = decoder;
            }
          }, {
            key: "getSignalDecoder",
            value: function getSignalDecoder() {
              return this.signalDecoder;
            }
          }, {
            key: "playAudio",
            value: function playAudio(pcmArray) {
              if (this.mute || this.squelchMute && this.squelch) {
                return;
              }
              if (this.audioCtx.state !== 'running') {
                return;
              }
              var curPlayTime = this.playPCM(pcmArray, this.playTime, this.audioOutputSps, 1);

              // buffering issues
              if (this.playTime - this.audioCtx.currentTime <= curPlayTime) {
                this.playTime = this.audioCtx.currentTime + (this.d + 4 * this.v) / 1000;
                console.log('underrun');
              } else if (this.playTime - this.audioCtx.currentTime > 2) {
                this.playTime = this.audioCtx.currentTime + (this.d + 4 * this.v) / 1000;
                console.log('overrun');
              }
            }
          }, {
            key: "playPCM",
            value: function playPCM(buffer, playTime, sampleRate, scale) {
              // Wait for the audio to be initialised
              if (!this.audioInputNode) {
                return;
              }
              var source = new audioBufferSourceNodeConstructor(this.audioCtx);
              var audioBuffer = new audioBufferConstructor({
                length: buffer.length,
                numberOfChannels: 1,
                sampleRate: this.audioOutputSps
              });
              audioBuffer.copyToChannel(buffer, 0, 0);
              source.buffer = audioBuffer;
              source.start(playTime);
              this.playTime += audioBuffer.duration;
              source.connect(this.audioInputNode);
              return audioBuffer.duration;
            }
          }]);
          return SpectrumAudio;
        }();
        var colorScale$1 = {
          "jet": [{
            "index": 0,
            "rgb": [0, 0, 131]
          }, {
            "index": 0.125,
            "rgb": [0, 60, 170]
          }, {
            "index": 0.375,
            "rgb": [5, 255, 255]
          }, {
            "index": 0.625,
            "rgb": [255, 255, 0]
          }, {
            "index": 0.875,
            "rgb": [250, 0, 0]
          }, {
            "index": 1,
            "rgb": [128, 0, 0]
          }],
          "hsv": [{
            "index": 0,
            "rgb": [255, 0, 0]
          }, {
            "index": 0.169,
            "rgb": [253, 255, 2]
          }, {
            "index": 0.173,
            "rgb": [247, 255, 2]
          }, {
            "index": 0.337,
            "rgb": [0, 252, 4]
          }, {
            "index": 0.341,
            "rgb": [0, 252, 10]
          }, {
            "index": 0.506,
            "rgb": [1, 249, 255]
          }, {
            "index": 0.671,
            "rgb": [2, 0, 253]
          }, {
            "index": 0.675,
            "rgb": [8, 0, 253]
          }, {
            "index": 0.839,
            "rgb": [255, 0, 251]
          }, {
            "index": 0.843,
            "rgb": [255, 0, 245]
          }, {
            "index": 1,
            "rgb": [255, 0, 6]
          }],
          "hot": [{
            "index": 0,
            "rgb": [0, 0, 0]
          }, {
            "index": 0.3,
            "rgb": [230, 0, 0]
          }, {
            "index": 0.6,
            "rgb": [255, 210, 0]
          }, {
            "index": 1,
            "rgb": [255, 255, 255]
          }],
          "spring": [{
            "index": 0,
            "rgb": [255, 0, 255]
          }, {
            "index": 1,
            "rgb": [255, 255, 0]
          }],
          "summer": [{
            "index": 0,
            "rgb": [0, 128, 102]
          }, {
            "index": 1,
            "rgb": [255, 255, 102]
          }],
          "autumn": [{
            "index": 0,
            "rgb": [255, 0, 0]
          }, {
            "index": 1,
            "rgb": [255, 255, 0]
          }],
          "winter": [{
            "index": 0,
            "rgb": [0, 0, 255]
          }, {
            "index": 1,
            "rgb": [0, 255, 128]
          }],
          "bone": [{
            "index": 0,
            "rgb": [0, 0, 0]
          }, {
            "index": 0.376,
            "rgb": [84, 84, 116]
          }, {
            "index": 0.753,
            "rgb": [169, 200, 200]
          }, {
            "index": 1,
            "rgb": [255, 255, 255]
          }],
          "copper": [{
            "index": 0,
            "rgb": [0, 0, 0]
          }, {
            "index": 0.804,
            "rgb": [255, 160, 102]
          }, {
            "index": 1,
            "rgb": [255, 199, 127]
          }],
          "greys": [{
            "index": 0,
            "rgb": [0, 0, 0]
          }, {
            "index": 1,
            "rgb": [255, 255, 255]
          }],
          "yignbu": [{
            "index": 0,
            "rgb": [8, 29, 88]
          }, {
            "index": 0.125,
            "rgb": [37, 52, 148]
          }, {
            "index": 0.25,
            "rgb": [34, 94, 168]
          }, {
            "index": 0.375,
            "rgb": [29, 145, 192]
          }, {
            "index": 0.5,
            "rgb": [65, 182, 196]
          }, {
            "index": 0.625,
            "rgb": [127, 205, 187]
          }, {
            "index": 0.75,
            "rgb": [199, 233, 180]
          }, {
            "index": 0.875,
            "rgb": [237, 248, 217]
          }, {
            "index": 1,
            "rgb": [255, 255, 217]
          }],
          "greens": [{
            "index": 0,
            "rgb": [0, 68, 27]
          }, {
            "index": 0.125,
            "rgb": [0, 109, 44]
          }, {
            "index": 0.25,
            "rgb": [35, 139, 69]
          }, {
            "index": 0.375,
            "rgb": [65, 171, 93]
          }, {
            "index": 0.5,
            "rgb": [116, 196, 118]
          }, {
            "index": 0.625,
            "rgb": [161, 217, 155]
          }, {
            "index": 0.75,
            "rgb": [199, 233, 192]
          }, {
            "index": 0.875,
            "rgb": [229, 245, 224]
          }, {
            "index": 1,
            "rgb": [247, 252, 245]
          }],
          "yiorrd": [{
            "index": 0,
            "rgb": [128, 0, 38]
          }, {
            "index": 0.125,
            "rgb": [189, 0, 38]
          }, {
            "index": 0.25,
            "rgb": [227, 26, 28]
          }, {
            "index": 0.375,
            "rgb": [252, 78, 42]
          }, {
            "index": 0.5,
            "rgb": [253, 141, 60]
          }, {
            "index": 0.625,
            "rgb": [254, 178, 76]
          }, {
            "index": 0.75,
            "rgb": [254, 217, 118]
          }, {
            "index": 0.875,
            "rgb": [255, 237, 160]
          }, {
            "index": 1,
            "rgb": [255, 255, 204]
          }],
          "bluered": [{
            "index": 0,
            "rgb": [0, 0, 255]
          }, {
            "index": 1,
            "rgb": [255, 0, 0]
          }],
          "rdbu": [{
            "index": 0,
            "rgb": [5, 10, 172]
          }, {
            "index": 0.35,
            "rgb": [106, 137, 247]
          }, {
            "index": 0.5,
            "rgb": [190, 190, 190]
          }, {
            "index": 0.6,
            "rgb": [220, 170, 132]
          }, {
            "index": 0.7,
            "rgb": [230, 145, 90]
          }, {
            "index": 1,
            "rgb": [178, 10, 28]
          }],
          "picnic": [{
            "index": 0,
            "rgb": [0, 0, 255]
          }, {
            "index": 0.1,
            "rgb": [51, 153, 255]
          }, {
            "index": 0.2,
            "rgb": [102, 204, 255]
          }, {
            "index": 0.3,
            "rgb": [153, 204, 255]
          }, {
            "index": 0.4,
            "rgb": [204, 204, 255]
          }, {
            "index": 0.5,
            "rgb": [255, 255, 255]
          }, {
            "index": 0.6,
            "rgb": [255, 204, 255]
          }, {
            "index": 0.7,
            "rgb": [255, 153, 255]
          }, {
            "index": 0.8,
            "rgb": [255, 102, 204]
          }, {
            "index": 0.9,
            "rgb": [255, 102, 102]
          }, {
            "index": 1,
            "rgb": [255, 0, 0]
          }],
          "rainbow": [{
            "index": 0,
            "rgb": [150, 0, 90]
          }, {
            "index": 0.125,
            "rgb": [0, 0, 200]
          }, {
            "index": 0.25,
            "rgb": [0, 25, 255]
          }, {
            "index": 0.375,
            "rgb": [0, 152, 255]
          }, {
            "index": 0.5,
            "rgb": [44, 255, 150]
          }, {
            "index": 0.625,
            "rgb": [151, 255, 0]
          }, {
            "index": 0.75,
            "rgb": [255, 234, 0]
          }, {
            "index": 0.875,
            "rgb": [255, 111, 0]
          }, {
            "index": 1,
            "rgb": [255, 0, 0]
          }],
          "portland": [{
            "index": 0,
            "rgb": [12, 51, 131]
          }, {
            "index": 0.25,
            "rgb": [10, 136, 186]
          }, {
            "index": 0.5,
            "rgb": [242, 211, 56]
          }, {
            "index": 0.75,
            "rgb": [242, 143, 56]
          }, {
            "index": 1,
            "rgb": [217, 30, 30]
          }],
          "blackbody": [{
            "index": 0,
            "rgb": [0, 0, 0]
          }, {
            "index": 0.2,
            "rgb": [230, 0, 0]
          }, {
            "index": 0.4,
            "rgb": [230, 210, 0]
          }, {
            "index": 0.7,
            "rgb": [255, 255, 255]
          }, {
            "index": 1,
            "rgb": [160, 200, 255]
          }],
          "earth": [{
            "index": 0,
            "rgb": [0, 0, 130]
          }, {
            "index": 0.1,
            "rgb": [0, 180, 180]
          }, {
            "index": 0.2,
            "rgb": [40, 210, 40]
          }, {
            "index": 0.4,
            "rgb": [230, 230, 50]
          }, {
            "index": 0.6,
            "rgb": [120, 70, 20]
          }, {
            "index": 1,
            "rgb": [255, 255, 255]
          }],
          "electric": [{
            "index": 0,
            "rgb": [0, 0, 0]
          }, {
            "index": 0.15,
            "rgb": [30, 0, 100]
          }, {
            "index": 0.4,
            "rgb": [120, 0, 100]
          }, {
            "index": 0.6,
            "rgb": [160, 90, 0]
          }, {
            "index": 0.8,
            "rgb": [230, 200, 0]
          }, {
            "index": 1,
            "rgb": [255, 250, 220]
          }],
          "alpha": [{
            "index": 0,
            "rgb": [255, 255, 255, 0]
          }, {
            "index": 1,
            "rgb": [255, 255, 255, 1]
          }],
          "viridis": [{
            "index": 0,
            "rgb": [68, 1, 84]
          }, {
            "index": 0.13,
            "rgb": [71, 44, 122]
          }, {
            "index": 0.25,
            "rgb": [59, 81, 139]
          }, {
            "index": 0.38,
            "rgb": [44, 113, 142]
          }, {
            "index": 0.5,
            "rgb": [33, 144, 141]
          }, {
            "index": 0.63,
            "rgb": [39, 173, 129]
          }, {
            "index": 0.75,
            "rgb": [92, 200, 99]
          }, {
            "index": 0.88,
            "rgb": [170, 220, 50]
          }, {
            "index": 1,
            "rgb": [253, 231, 37]
          }],
          "inferno": [{
            "index": 0,
            "rgb": [0, 0, 4]
          }, {
            "index": 0.13,
            "rgb": [31, 12, 72]
          }, {
            "index": 0.25,
            "rgb": [85, 15, 109]
          }, {
            "index": 0.38,
            "rgb": [136, 34, 106]
          }, {
            "index": 0.5,
            "rgb": [186, 54, 85]
          }, {
            "index": 0.63,
            "rgb": [227, 89, 51]
          }, {
            "index": 0.75,
            "rgb": [249, 140, 10]
          }, {
            "index": 0.88,
            "rgb": [249, 201, 50]
          }, {
            "index": 1,
            "rgb": [252, 255, 164]
          }],
          "magma": [{
            "index": 0,
            "rgb": [0, 0, 4]
          }, {
            "index": 0.13,
            "rgb": [28, 16, 68]
          }, {
            "index": 0.25,
            "rgb": [79, 18, 123]
          }, {
            "index": 0.38,
            "rgb": [129, 37, 129]
          }, {
            "index": 0.5,
            "rgb": [181, 54, 122]
          }, {
            "index": 0.63,
            "rgb": [229, 80, 100]
          }, {
            "index": 0.75,
            "rgb": [251, 135, 97]
          }, {
            "index": 0.88,
            "rgb": [254, 194, 135]
          }, {
            "index": 1,
            "rgb": [252, 253, 191]
          }],
          "plasma": [{
            "index": 0,
            "rgb": [13, 8, 135]
          }, {
            "index": 0.13,
            "rgb": [75, 3, 161]
          }, {
            "index": 0.25,
            "rgb": [125, 3, 168]
          }, {
            "index": 0.38,
            "rgb": [168, 34, 150]
          }, {
            "index": 0.5,
            "rgb": [203, 70, 121]
          }, {
            "index": 0.63,
            "rgb": [229, 107, 93]
          }, {
            "index": 0.75,
            "rgb": [248, 148, 65]
          }, {
            "index": 0.88,
            "rgb": [253, 195, 40]
          }, {
            "index": 1,
            "rgb": [240, 249, 33]
          }],
          "warm": [{
            "index": 0,
            "rgb": [125, 0, 179]
          }, {
            "index": 0.13,
            "rgb": [172, 0, 187]
          }, {
            "index": 0.25,
            "rgb": [219, 0, 170]
          }, {
            "index": 0.38,
            "rgb": [255, 0, 130]
          }, {
            "index": 0.5,
            "rgb": [255, 63, 74]
          }, {
            "index": 0.63,
            "rgb": [255, 123, 0]
          }, {
            "index": 0.75,
            "rgb": [234, 176, 0]
          }, {
            "index": 0.88,
            "rgb": [190, 228, 0]
          }, {
            "index": 1,
            "rgb": [147, 255, 0]
          }],
          "cool": [{
            "index": 0,
            "rgb": [125, 0, 179]
          }, {
            "index": 0.13,
            "rgb": [116, 0, 218]
          }, {
            "index": 0.25,
            "rgb": [98, 74, 237]
          }, {
            "index": 0.38,
            "rgb": [68, 146, 231]
          }, {
            "index": 0.5,
            "rgb": [0, 204, 197]
          }, {
            "index": 0.63,
            "rgb": [0, 247, 146]
          }, {
            "index": 0.75,
            "rgb": [0, 255, 88]
          }, {
            "index": 0.88,
            "rgb": [40, 255, 8]
          }, {
            "index": 1,
            "rgb": [147, 255, 0]
          }],
          "rainbow-soft": [{
            "index": 0,
            "rgb": [125, 0, 179]
          }, {
            "index": 0.1,
            "rgb": [199, 0, 180]
          }, {
            "index": 0.2,
            "rgb": [255, 0, 121]
          }, {
            "index": 0.3,
            "rgb": [255, 108, 0]
          }, {
            "index": 0.4,
            "rgb": [222, 194, 0]
          }, {
            "index": 0.5,
            "rgb": [150, 255, 0]
          }, {
            "index": 0.6,
            "rgb": [0, 255, 55]
          }, {
            "index": 0.7,
            "rgb": [0, 246, 150]
          }, {
            "index": 0.8,
            "rgb": [50, 167, 222]
          }, {
            "index": 0.9,
            "rgb": [103, 51, 235]
          }, {
            "index": 1,
            "rgb": [124, 0, 186]
          }],
          "bathymetry": [{
            "index": 0,
            "rgb": [40, 26, 44]
          }, {
            "index": 0.13,
            "rgb": [59, 49, 90]
          }, {
            "index": 0.25,
            "rgb": [64, 76, 139]
          }, {
            "index": 0.38,
            "rgb": [63, 110, 151]
          }, {
            "index": 0.5,
            "rgb": [72, 142, 158]
          }, {
            "index": 0.63,
            "rgb": [85, 174, 163]
          }, {
            "index": 0.75,
            "rgb": [120, 206, 163]
          }, {
            "index": 0.88,
            "rgb": [187, 230, 172]
          }, {
            "index": 1,
            "rgb": [253, 254, 204]
          }],
          "cdom": [{
            "index": 0,
            "rgb": [47, 15, 62]
          }, {
            "index": 0.13,
            "rgb": [87, 23, 86]
          }, {
            "index": 0.25,
            "rgb": [130, 28, 99]
          }, {
            "index": 0.38,
            "rgb": [171, 41, 96]
          }, {
            "index": 0.5,
            "rgb": [206, 67, 86]
          }, {
            "index": 0.63,
            "rgb": [230, 106, 84]
          }, {
            "index": 0.75,
            "rgb": [242, 149, 103]
          }, {
            "index": 0.88,
            "rgb": [249, 193, 135]
          }, {
            "index": 1,
            "rgb": [254, 237, 176]
          }],
          "chlorophyll": [{
            "index": 0,
            "rgb": [18, 36, 20]
          }, {
            "index": 0.13,
            "rgb": [25, 63, 41]
          }, {
            "index": 0.25,
            "rgb": [24, 91, 59]
          }, {
            "index": 0.38,
            "rgb": [13, 119, 72]
          }, {
            "index": 0.5,
            "rgb": [18, 148, 80]
          }, {
            "index": 0.63,
            "rgb": [80, 173, 89]
          }, {
            "index": 0.75,
            "rgb": [132, 196, 122]
          }, {
            "index": 0.88,
            "rgb": [175, 221, 162]
          }, {
            "index": 1,
            "rgb": [215, 249, 208]
          }],
          "density": [{
            "index": 0,
            "rgb": [54, 14, 36]
          }, {
            "index": 0.13,
            "rgb": [89, 23, 80]
          }, {
            "index": 0.25,
            "rgb": [110, 45, 132]
          }, {
            "index": 0.38,
            "rgb": [120, 77, 178]
          }, {
            "index": 0.5,
            "rgb": [120, 113, 213]
          }, {
            "index": 0.63,
            "rgb": [115, 151, 228]
          }, {
            "index": 0.75,
            "rgb": [134, 185, 227]
          }, {
            "index": 0.88,
            "rgb": [177, 214, 227]
          }, {
            "index": 1,
            "rgb": [230, 241, 241]
          }],
          "freesurface-blue": [{
            "index": 0,
            "rgb": [30, 4, 110]
          }, {
            "index": 0.13,
            "rgb": [47, 14, 176]
          }, {
            "index": 0.25,
            "rgb": [41, 45, 236]
          }, {
            "index": 0.38,
            "rgb": [25, 99, 212]
          }, {
            "index": 0.5,
            "rgb": [68, 131, 200]
          }, {
            "index": 0.63,
            "rgb": [114, 156, 197]
          }, {
            "index": 0.75,
            "rgb": [157, 181, 203]
          }, {
            "index": 0.88,
            "rgb": [200, 208, 216]
          }, {
            "index": 1,
            "rgb": [241, 237, 236]
          }],
          "freesurface-red": [{
            "index": 0,
            "rgb": [60, 9, 18]
          }, {
            "index": 0.13,
            "rgb": [100, 17, 27]
          }, {
            "index": 0.25,
            "rgb": [142, 20, 29]
          }, {
            "index": 0.38,
            "rgb": [177, 43, 27]
          }, {
            "index": 0.5,
            "rgb": [192, 87, 63]
          }, {
            "index": 0.63,
            "rgb": [205, 125, 105]
          }, {
            "index": 0.75,
            "rgb": [216, 162, 148]
          }, {
            "index": 0.88,
            "rgb": [227, 199, 193]
          }, {
            "index": 1,
            "rgb": [241, 237, 236]
          }],
          "oxygen": [{
            "index": 0,
            "rgb": [64, 5, 5]
          }, {
            "index": 0.13,
            "rgb": [106, 6, 15]
          }, {
            "index": 0.25,
            "rgb": [144, 26, 7]
          }, {
            "index": 0.38,
            "rgb": [168, 64, 3]
          }, {
            "index": 0.5,
            "rgb": [188, 100, 4]
          }, {
            "index": 0.63,
            "rgb": [206, 136, 11]
          }, {
            "index": 0.75,
            "rgb": [220, 174, 25]
          }, {
            "index": 0.88,
            "rgb": [231, 215, 44]
          }, {
            "index": 1,
            "rgb": [248, 254, 105]
          }],
          "par": [{
            "index": 0,
            "rgb": [51, 20, 24]
          }, {
            "index": 0.13,
            "rgb": [90, 32, 35]
          }, {
            "index": 0.25,
            "rgb": [129, 44, 34]
          }, {
            "index": 0.38,
            "rgb": [159, 68, 25]
          }, {
            "index": 0.5,
            "rgb": [182, 99, 19]
          }, {
            "index": 0.63,
            "rgb": [199, 134, 22]
          }, {
            "index": 0.75,
            "rgb": [212, 171, 35]
          }, {
            "index": 0.88,
            "rgb": [221, 210, 54]
          }, {
            "index": 1,
            "rgb": [225, 253, 75]
          }],
          "phase": [{
            "index": 0,
            "rgb": [145, 105, 18]
          }, {
            "index": 0.13,
            "rgb": [184, 71, 38]
          }, {
            "index": 0.25,
            "rgb": [186, 58, 115]
          }, {
            "index": 0.38,
            "rgb": [160, 71, 185]
          }, {
            "index": 0.5,
            "rgb": [110, 97, 218]
          }, {
            "index": 0.63,
            "rgb": [50, 123, 164]
          }, {
            "index": 0.75,
            "rgb": [31, 131, 110]
          }, {
            "index": 0.88,
            "rgb": [77, 129, 34]
          }, {
            "index": 1,
            "rgb": [145, 105, 18]
          }],
          "salinity": [{
            "index": 0,
            "rgb": [42, 24, 108]
          }, {
            "index": 0.13,
            "rgb": [33, 50, 162]
          }, {
            "index": 0.25,
            "rgb": [15, 90, 145]
          }, {
            "index": 0.38,
            "rgb": [40, 118, 137]
          }, {
            "index": 0.5,
            "rgb": [59, 146, 135]
          }, {
            "index": 0.63,
            "rgb": [79, 175, 126]
          }, {
            "index": 0.75,
            "rgb": [120, 203, 104]
          }, {
            "index": 0.88,
            "rgb": [193, 221, 100]
          }, {
            "index": 1,
            "rgb": [253, 239, 154]
          }],
          "temperature": [{
            "index": 0,
            "rgb": [4, 35, 51]
          }, {
            "index": 0.13,
            "rgb": [23, 51, 122]
          }, {
            "index": 0.25,
            "rgb": [85, 59, 157]
          }, {
            "index": 0.38,
            "rgb": [129, 79, 143]
          }, {
            "index": 0.5,
            "rgb": [175, 95, 130]
          }, {
            "index": 0.63,
            "rgb": [222, 112, 101]
          }, {
            "index": 0.75,
            "rgb": [249, 146, 66]
          }, {
            "index": 0.88,
            "rgb": [249, 196, 65]
          }, {
            "index": 1,
            "rgb": [232, 250, 91]
          }],
          "turbidity": [{
            "index": 0,
            "rgb": [34, 31, 27]
          }, {
            "index": 0.13,
            "rgb": [65, 50, 41]
          }, {
            "index": 0.25,
            "rgb": [98, 69, 52]
          }, {
            "index": 0.38,
            "rgb": [131, 89, 57]
          }, {
            "index": 0.5,
            "rgb": [161, 112, 59]
          }, {
            "index": 0.63,
            "rgb": [185, 140, 66]
          }, {
            "index": 0.75,
            "rgb": [202, 174, 88]
          }, {
            "index": 0.88,
            "rgb": [216, 209, 126]
          }, {
            "index": 1,
            "rgb": [233, 246, 171]
          }],
          "velocity-blue": [{
            "index": 0,
            "rgb": [17, 32, 64]
          }, {
            "index": 0.13,
            "rgb": [35, 52, 116]
          }, {
            "index": 0.25,
            "rgb": [29, 81, 156]
          }, {
            "index": 0.38,
            "rgb": [31, 113, 162]
          }, {
            "index": 0.5,
            "rgb": [50, 144, 169]
          }, {
            "index": 0.63,
            "rgb": [87, 173, 176]
          }, {
            "index": 0.75,
            "rgb": [149, 196, 189]
          }, {
            "index": 0.88,
            "rgb": [203, 221, 211]
          }, {
            "index": 1,
            "rgb": [254, 251, 230]
          }],
          "velocity-green": [{
            "index": 0,
            "rgb": [23, 35, 19]
          }, {
            "index": 0.13,
            "rgb": [24, 64, 38]
          }, {
            "index": 0.25,
            "rgb": [11, 95, 45]
          }, {
            "index": 0.38,
            "rgb": [39, 123, 35]
          }, {
            "index": 0.5,
            "rgb": [95, 146, 12]
          }, {
            "index": 0.63,
            "rgb": [152, 165, 18]
          }, {
            "index": 0.75,
            "rgb": [201, 186, 69]
          }, {
            "index": 0.88,
            "rgb": [233, 216, 137]
          }, {
            "index": 1,
            "rgb": [255, 253, 205]
          }],
          "cubehelix": [{
            "index": 0,
            "rgb": [0, 0, 0]
          }, {
            "index": 0.07,
            "rgb": [22, 5, 59]
          }, {
            "index": 0.13,
            "rgb": [60, 4, 105]
          }, {
            "index": 0.2,
            "rgb": [109, 1, 135]
          }, {
            "index": 0.27,
            "rgb": [161, 0, 147]
          }, {
            "index": 0.33,
            "rgb": [210, 2, 142]
          }, {
            "index": 0.4,
            "rgb": [251, 11, 123]
          }, {
            "index": 0.47,
            "rgb": [255, 29, 97]
          }, {
            "index": 0.53,
            "rgb": [255, 54, 69]
          }, {
            "index": 0.6,
            "rgb": [255, 85, 46]
          }, {
            "index": 0.67,
            "rgb": [255, 120, 34]
          }, {
            "index": 0.73,
            "rgb": [255, 157, 37]
          }, {
            "index": 0.8,
            "rgb": [241, 191, 57]
          }, {
            "index": 0.87,
            "rgb": [224, 220, 93]
          }, {
            "index": 0.93,
            "rgb": [218, 241, 142]
          }, {
            "index": 1,
            "rgb": [227, 253, 198]
          }]
        };
        function lerp$1(v0, v1, t) {
          return v0 * (1 - t) + v1 * t;
        }
        var lerp_1 = lerp$1;

        /*
         * Ben Postlethwaite
         * January 2013
         * License MIT
         */

        var colorScale = colorScale$1;
        var lerp = lerp_1;
        var colormap = createColormap;
        function createColormap(spec) {
          /*
           * Default Options
           */
          var indicies, fromrgba, torgba, nsteps, cmap, colormap, format, nshades, colors, alpha, i;
          if (!spec) spec = {};
          nshades = (spec.nshades || 72) - 1;
          format = spec.format || 'hex';
          colormap = spec.colormap;
          if (!colormap) colormap = 'jet';
          if (typeof colormap === 'string') {
            colormap = colormap.toLowerCase();
            if (!colorScale[colormap]) {
              throw Error(colormap + ' not a supported colorscale');
            }
            cmap = colorScale[colormap];
          } else if (Array.isArray(colormap)) {
            cmap = colormap.slice();
          } else {
            throw Error('unsupported colormap option', colormap);
          }
          if (cmap.length > nshades + 1) {
            throw new Error(colormap + ' map requires nshades to be at least size ' + cmap.length);
          }
          if (!Array.isArray(spec.alpha)) {
            if (typeof spec.alpha === 'number') {
              alpha = [spec.alpha, spec.alpha];
            } else {
              alpha = [1, 1];
            }
          } else if (spec.alpha.length !== 2) {
            alpha = [1, 1];
          } else {
            alpha = spec.alpha.slice();
          }

          // map index points from 0..1 to 0..n-1
          indicies = cmap.map(function (c) {
            return Math.round(c.index * nshades);
          });

          // Add alpha channel to the map
          alpha[0] = Math.min(Math.max(alpha[0], 0), 1);
          alpha[1] = Math.min(Math.max(alpha[1], 0), 1);
          var steps = cmap.map(function (c, i) {
            var index = cmap[i].index;
            var rgba = cmap[i].rgb.slice();

            // if user supplies their own map use it
            if (rgba.length === 4 && rgba[3] >= 0 && rgba[3] <= 1) {
              return rgba;
            }
            rgba[3] = alpha[0] + (alpha[1] - alpha[0]) * index;
            return rgba;
          });

          /*
           * map increasing linear values between indicies to
           * linear steps in colorvalues
           */
          var colors = [];
          for (i = 0; i < indicies.length - 1; ++i) {
            nsteps = indicies[i + 1] - indicies[i];
            fromrgba = steps[i];
            torgba = steps[i + 1];
            for (var j = 0; j < nsteps; j++) {
              var amt = j / nsteps;
              colors.push([Math.round(lerp(fromrgba[0], torgba[0], amt)), Math.round(lerp(fromrgba[1], torgba[1], amt)), Math.round(lerp(fromrgba[2], torgba[2], amt)), lerp(fromrgba[3], torgba[3], amt)]);
            }
          }

          //add 1 step as last value
          colors.push(cmap[cmap.length - 1].rgb.concat(alpha[1]));
          if (format === 'hex') colors = colors.map(rgb2hex);else if (format === 'rgbaString') colors = colors.map(rgbaStr);else if (format === 'float') colors = colors.map(rgb2float);
          return colors;
        }
        function rgb2float(rgba) {
          return [rgba[0] / 255, rgba[1] / 255, rgba[2] / 255, rgba[3]];
        }
        function rgb2hex(rgba) {
          var dig,
            hex = '#';
          for (var i = 0; i < 3; ++i) {
            dig = rgba[i];
            dig = dig.toString(16);
            hex += ('00' + dig).substr(dig.length);
          }
          return hex;
        }
        function rgbaStr(rgba) {
          return 'rgba(' + rgba.join(',') + ')';
        }
        var turboColormap = [[0.18995, 0.07176, 0.23217], [0.19483, 0.08339, 0.26149], [0.19956, 0.09498, 0.29024], [0.20415, 0.10652, 0.31844], [0.20860, 0.11802, 0.34607], [0.21291, 0.12947, 0.37314], [0.21708, 0.14087, 0.39964], [0.22111, 0.15223, 0.42558], [0.22500, 0.16354, 0.45096], [0.22875, 0.17481, 0.47578], [0.23236, 0.18603, 0.50004], [0.23582, 0.19720, 0.52373], [0.23915, 0.20833, 0.54686], [0.24234, 0.21941, 0.56942], [0.24539, 0.23044, 0.59142], [0.24830, 0.24143, 0.61286], [0.25107, 0.25237, 0.63374], [0.25369, 0.26327, 0.65406], [0.25618, 0.27412, 0.67381], [0.25853, 0.28492, 0.69300], [0.26074, 0.29568, 0.71162], [0.26280, 0.30639, 0.72968], [0.26473, 0.31706, 0.74718], [0.26652, 0.32768, 0.76412], [0.26816, 0.33825, 0.78050], [0.26967, 0.34878, 0.79631], [0.27103, 0.35926, 0.81156], [0.27226, 0.36970, 0.82624], [0.27334, 0.38008, 0.84037], [0.27429, 0.39043, 0.85393], [0.27509, 0.40072, 0.86692], [0.27576, 0.41097, 0.87936], [0.27628, 0.42118, 0.89123], [0.27667, 0.43134, 0.90254], [0.27691, 0.44145, 0.91328], [0.27701, 0.45152, 0.92347], [0.27698, 0.46153, 0.93309], [0.27680, 0.47151, 0.94214], [0.27648, 0.48144, 0.95064], [0.27603, 0.49132, 0.95857], [0.27543, 0.50115, 0.96594], [0.27469, 0.51094, 0.97275], [0.27381, 0.52069, 0.97899], [0.27273, 0.53040, 0.98461], [0.27106, 0.54015, 0.98930], [0.26878, 0.54995, 0.99303], [0.26592, 0.55979, 0.99583], [0.26252, 0.56967, 0.99773], [0.25862, 0.57958, 0.99876], [0.25425, 0.58950, 0.99896], [0.24946, 0.59943, 0.99835], [0.24427, 0.60937, 0.99697], [0.23874, 0.61931, 0.99485], [0.23288, 0.62923, 0.99202], [0.22676, 0.63913, 0.98851], [0.22039, 0.64901, 0.98436], [0.21382, 0.65886, 0.97959], [0.20708, 0.66866, 0.97423], [0.20021, 0.67842, 0.96833], [0.19326, 0.68812, 0.96190], [0.18625, 0.69775, 0.95498], [0.17923, 0.70732, 0.94761], [0.17223, 0.71680, 0.93981], [0.16529, 0.72620, 0.93161], [0.15844, 0.73551, 0.92305], [0.15173, 0.74472, 0.91416], [0.14519, 0.75381, 0.90496], [0.13886, 0.76279, 0.89550], [0.13278, 0.77165, 0.88580], [0.12698, 0.78037, 0.87590], [0.12151, 0.78896, 0.86581], [0.11639, 0.79740, 0.85559], [0.11167, 0.80569, 0.84525], [0.10738, 0.81381, 0.83484], [0.10357, 0.82177, 0.82437], [0.10026, 0.82955, 0.81389], [0.09750, 0.83714, 0.80342], [0.09532, 0.84455, 0.79299], [0.09377, 0.85175, 0.78264], [0.09287, 0.85875, 0.77240], [0.09267, 0.86554, 0.76230], [0.09320, 0.87211, 0.75237], [0.09451, 0.87844, 0.74265], [0.09662, 0.88454, 0.73316], [0.09958, 0.89040, 0.72393], [0.10342, 0.89600, 0.71500], [0.10815, 0.90142, 0.70599], [0.11374, 0.90673, 0.69651], [0.12014, 0.91193, 0.68660], [0.12733, 0.91701, 0.67627], [0.13526, 0.92197, 0.66556], [0.14391, 0.92680, 0.65448], [0.15323, 0.93151, 0.64308], [0.16319, 0.93609, 0.63137], [0.17377, 0.94053, 0.61938], [0.18491, 0.94484, 0.60713], [0.19659, 0.94901, 0.59466], [0.20877, 0.95304, 0.58199], [0.22142, 0.95692, 0.56914], [0.23449, 0.96065, 0.55614], [0.24797, 0.96423, 0.54303], [0.26180, 0.96765, 0.52981], [0.27597, 0.97092, 0.51653], [0.29042, 0.97403, 0.50321], [0.30513, 0.97697, 0.48987], [0.32006, 0.97974, 0.47654], [0.33517, 0.98234, 0.46325], [0.35043, 0.98477, 0.45002], [0.36581, 0.98702, 0.43688], [0.38127, 0.98909, 0.42386], [0.39678, 0.99098, 0.41098], [0.41229, 0.99268, 0.39826], [0.42778, 0.99419, 0.38575], [0.44321, 0.99551, 0.37345], [0.45854, 0.99663, 0.36140], [0.47375, 0.99755, 0.34963], [0.48879, 0.99828, 0.33816], [0.50362, 0.99879, 0.32701], [0.51822, 0.99910, 0.31622], [0.53255, 0.99919, 0.30581], [0.54658, 0.99907, 0.29581], [0.56026, 0.99873, 0.28623], [0.57357, 0.99817, 0.27712], [0.58646, 0.99739, 0.26849], [0.59891, 0.99638, 0.26038], [0.61088, 0.99514, 0.25280], [0.62233, 0.99366, 0.24579], [0.63323, 0.99195, 0.23937], [0.64362, 0.98999, 0.23356], [0.65394, 0.98775, 0.22835], [0.66428, 0.98524, 0.22370], [0.67462, 0.98246, 0.21960], [0.68494, 0.97941, 0.21602], [0.69525, 0.97610, 0.21294], [0.70553, 0.97255, 0.21032], [0.71577, 0.96875, 0.20815], [0.72596, 0.96470, 0.20640], [0.73610, 0.96043, 0.20504], [0.74617, 0.95593, 0.20406], [0.75617, 0.95121, 0.20343], [0.76608, 0.94627, 0.20311], [0.77591, 0.94113, 0.20310], [0.78563, 0.93579, 0.20336], [0.79524, 0.93025, 0.20386], [0.80473, 0.92452, 0.20459], [0.81410, 0.91861, 0.20552], [0.82333, 0.91253, 0.20663], [0.83241, 0.90627, 0.20788], [0.84133, 0.89986, 0.20926], [0.85010, 0.89328, 0.21074], [0.85868, 0.88655, 0.21230], [0.86709, 0.87968, 0.21391], [0.87530, 0.87267, 0.21555], [0.88331, 0.86553, 0.21719], [0.89112, 0.85826, 0.21880], [0.89870, 0.85087, 0.22038], [0.90605, 0.84337, 0.22188], [0.91317, 0.83576, 0.22328], [0.92004, 0.82806, 0.22456], [0.92666, 0.82025, 0.22570], [0.93301, 0.81236, 0.22667], [0.93909, 0.80439, 0.22744], [0.94489, 0.79634, 0.22800], [0.95039, 0.78823, 0.22831], [0.95560, 0.78005, 0.22836], [0.96049, 0.77181, 0.22811], [0.96507, 0.76352, 0.22754], [0.96931, 0.75519, 0.22663], [0.97323, 0.74682, 0.22536], [0.97679, 0.73842, 0.22369], [0.98000, 0.73000, 0.22161], [0.98289, 0.72140, 0.21918], [0.98549, 0.71250, 0.21650], [0.98781, 0.70330, 0.21358], [0.98986, 0.69382, 0.21043], [0.99163, 0.68408, 0.20706], [0.99314, 0.67408, 0.20348], [0.99438, 0.66386, 0.19971], [0.99535, 0.65341, 0.19577], [0.99607, 0.64277, 0.19165], [0.99654, 0.63193, 0.18738], [0.99675, 0.62093, 0.18297], [0.99672, 0.60977, 0.17842], [0.99644, 0.59846, 0.17376], [0.99593, 0.58703, 0.16899], [0.99517, 0.57549, 0.16412], [0.99419, 0.56386, 0.15918], [0.99297, 0.55214, 0.15417], [0.99153, 0.54036, 0.14910], [0.98987, 0.52854, 0.14398], [0.98799, 0.51667, 0.13883], [0.98590, 0.50479, 0.13367], [0.98360, 0.49291, 0.12849], [0.98108, 0.48104, 0.12332], [0.97837, 0.46920, 0.11817], [0.97545, 0.45740, 0.11305], [0.97234, 0.44565, 0.10797], [0.96904, 0.43399, 0.10294], [0.96555, 0.42241, 0.09798], [0.96187, 0.41093, 0.09310], [0.95801, 0.39958, 0.08831], [0.95398, 0.38836, 0.08362], [0.94977, 0.37729, 0.07905], [0.94538, 0.36638, 0.07461], [0.94084, 0.35566, 0.07031], [0.93612, 0.34513, 0.06616], [0.93125, 0.33482, 0.06218], [0.92623, 0.32473, 0.05837], [0.92105, 0.31489, 0.05475], [0.91572, 0.30530, 0.05134], [0.91024, 0.29599, 0.04814], [0.90463, 0.28696, 0.04516], [0.89888, 0.27824, 0.04243], [0.89298, 0.26981, 0.03993], [0.88691, 0.26152, 0.03753], [0.88066, 0.25334, 0.03521], [0.87422, 0.24526, 0.03297], [0.86760, 0.23730, 0.03082], [0.86079, 0.22945, 0.02875], [0.85380, 0.22170, 0.02677], [0.84662, 0.21407, 0.02487], [0.83926, 0.20654, 0.02305], [0.83172, 0.19912, 0.02131], [0.82399, 0.19182, 0.01966], [0.81608, 0.18462, 0.01809], [0.80799, 0.17753, 0.01660], [0.79971, 0.17055, 0.01520], [0.79125, 0.16368, 0.01387], [0.78260, 0.15693, 0.01264], [0.77377, 0.15028, 0.01148], [0.76476, 0.14374, 0.01041], [0.75556, 0.13731, 0.00942], [0.74617, 0.13098, 0.00851], [0.73661, 0.12477, 0.00769], [0.72686, 0.11867, 0.00695], [0.71692, 0.11268, 0.00629], [0.70680, 0.10680, 0.00571], [0.69650, 0.10102, 0.00522], [0.68602, 0.09536, 0.00481], [0.67535, 0.08980, 0.00449], [0.66449, 0.08436, 0.00424], [0.65345, 0.07902, 0.00408], [0.64223, 0.07380, 0.00401], [0.63082, 0.06868, 0.00401], [0.61923, 0.06367, 0.00410], [0.60746, 0.05878, 0.00427], [0.59550, 0.05399, 0.00453], [0.58336, 0.04931, 0.00486], [0.57103, 0.04474, 0.00529], [0.55852, 0.04028, 0.00579], [0.54583, 0.03593, 0.00638], [0.53295, 0.03169, 0.00705], [0.51989, 0.02756, 0.00780], [0.50664, 0.02354, 0.00863], [0.49321, 0.01963, 0.00955], [0.47960, 0.01583, 0.01055]];

        // https://github.com/csete/gqrx/blob/master/src/qtgui/plotter.cpp
        var gqrxData = [];
        for (var _i18 = 0; _i18 < 256; _i18++) {
          if (_i18 < 20) {
            // level 0: black background
            gqrxData.push([0, 0, 0]);
          } else if (_i18 >= 20 && _i18 < 70) {
            // level 1: black -> blue
            gqrxData.push([0, 0, 140 * (_i18 - 20) / 50]);
          } else if (_i18 >= 70 && _i18 < 100) {
            // level 2: blue -> light-blue / greenish
            gqrxData.push([60 * (_i18 - 70) / 30, 125 * (_i18 - 70) / 30, 115 * (_i18 - 70) / 30 + 140]);
          } else if (_i18 >= 100 && _i18 < 150) {
            // level 3: light blue -> yellow
            gqrxData.push([195 * (_i18 - 100) / 50 + 60, 130 * (_i18 - 100) / 50 + 125, 255 - 255 * (_i18 - 100) / 50]);
          } else if (_i18 >= 150 && _i18 < 250) {
            // level 4: yellow -> red
            gqrxData.push([255, 255 - 255 * (_i18 - 150) / 100, 0]);
          } else if (_i18 >= 250) {
            // level 5: red -> white
            gqrxData.push([255, 255 * (_i18 - 250) / 5, 255 * (_i18 - 250) / 5]);
          }
          gqrxData[_i18] = gqrxData[_i18].map(function (x) {
            return x / 255;
          });
        }
        var definedColormaps = {
          turbo: turboColormap,
          gqrx: gqrxData
        };
        var availableColormaps = ['turbo', 'gqrx'].concat(_toConsumableArray(Object.keys(colorScale$1)));
        function computeColormapArray(colormap) {
          return colormap.map(function (rgb) {
            var rgbcolor = new Uint8ClampedArray(4);
            if (rgb.length < 4) {
              rgb = [].concat(_toConsumableArray(rgb), [255]);
            }
            rgbcolor.set(rgb.map(function (x) {
              return Math.round(x * 255);
            }));
            return rgbcolor;
          });
        }
        function drawColormapPreview(name, elem) {
          var ctx = elem.getContext('2d');
          var height = elem.height;
          var colormapArray = computeColormapArray(getColormap(name));
          for (var _i19 = 0; _i19 < 256; _i19++) {
            var _colormapArray$_i = _slicedToArray(colormapArray[_i19], 4),
              r = _colormapArray$_i[0],
              _g = _colormapArray$_i[1],
              b = _colormapArray$_i[2],
              a = _colormapArray$_i[3];
            ctx.fillStyle = "rgba(".concat(r, ", ").concat(_g, ", ").concat(b, ", ").concat(a, ")");
            ctx.fillRect(_i19, 0, 1, height);
          }
        }
        function getColormap(name) {
          var colors;
          if (name in definedColormaps) {
            colors = definedColormaps[name];
          } else {
            colors = colormap({
              colormap: name,
              nshades: 256,
              format: 'float',
              alpha: 1
            });
          }
          return colors;
        }

        /**
         * Copyright (c) 2013 Petka Antonov
         * 
         * Permission is hereby granted, free of charge, to any person obtaining a copy
         * of this software and associated documentation files (the "Software"), to deal
         * in the Software without restriction, including without limitation the rights
         * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
         * copies of the Software, and to permit persons to whom the Software is
         * furnished to do so, subject to the following conditions:</p>
         * 
         * The above copyright notice and this permission notice shall be included in
         * all copies or substantial portions of the Software.
         * 
         * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
         * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
         * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
         * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
         * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
         * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
         * THE SOFTWARE.
         */
        function Deque(capacity) {
          this._capacity = getCapacity(capacity);
          this._length = 0;
          this._front = 0;
          if (isArray$4(capacity)) {
            var len = capacity.length;
            for (var i = 0; i < len; ++i) {
              this[i] = capacity[i];
            }
            this._length = len;
          }
        }
        Deque.prototype.toArray = function Deque$toArray() {
          var len = this._length;
          var ret = new Array(len);
          var front = this._front;
          var capacity = this._capacity;
          for (var j = 0; j < len; ++j) {
            ret[j] = this[front + j & capacity - 1];
          }
          return ret;
        };
        Deque.prototype.push = function Deque$push(item) {
          var argsLength = arguments.length;
          var length = this._length;
          if (argsLength > 1) {
            var capacity = this._capacity;
            if (length + argsLength > capacity) {
              for (var i = 0; i < argsLength; ++i) {
                this._checkCapacity(length + 1);
                var j = this._front + length & this._capacity - 1;
                this[j] = arguments[i];
                length++;
                this._length = length;
              }
              return length;
            } else {
              var j = this._front;
              for (var i = 0; i < argsLength; ++i) {
                this[j + length & capacity - 1] = arguments[i];
                j++;
              }
              this._length = length + argsLength;
              return length + argsLength;
            }
          }
          if (argsLength === 0) return length;
          this._checkCapacity(length + 1);
          var i = this._front + length & this._capacity - 1;
          this[i] = item;
          this._length = length + 1;
          return length + 1;
        };
        Deque.prototype.pop = function Deque$pop() {
          var length = this._length;
          if (length === 0) {
            return void 0;
          }
          var i = this._front + length - 1 & this._capacity - 1;
          var ret = this[i];
          this[i] = void 0;
          this._length = length - 1;
          return ret;
        };
        Deque.prototype.shift = function Deque$shift() {
          var length = this._length;
          if (length === 0) {
            return void 0;
          }
          var front = this._front;
          var ret = this[front];
          this[front] = void 0;
          this._front = front + 1 & this._capacity - 1;
          this._length = length - 1;
          return ret;
        };
        Deque.prototype.unshift = function Deque$unshift(item) {
          var length = this._length;
          var argsLength = arguments.length;
          if (argsLength > 1) {
            var capacity = this._capacity;
            if (length + argsLength > capacity) {
              for (var i = argsLength - 1; i >= 0; i--) {
                this._checkCapacity(length + 1);
                var capacity = this._capacity;
                var j = (this._front - 1 & capacity - 1 ^ capacity) - capacity;
                this[j] = arguments[i];
                length++;
                this._length = length;
                this._front = j;
              }
              return length;
            } else {
              var front = this._front;
              for (var i = argsLength - 1; i >= 0; i--) {
                var j = (front - 1 & capacity - 1 ^ capacity) - capacity;
                this[j] = arguments[i];
                front = j;
              }
              this._front = front;
              this._length = length + argsLength;
              return length + argsLength;
            }
          }
          if (argsLength === 0) return length;
          this._checkCapacity(length + 1);
          var capacity = this._capacity;
          var i = (this._front - 1 & capacity - 1 ^ capacity) - capacity;
          this[i] = item;
          this._length = length + 1;
          this._front = i;
          return length + 1;
        };
        Deque.prototype.peekBack = function Deque$peekBack() {
          var length = this._length;
          if (length === 0) {
            return void 0;
          }
          var index = this._front + length - 1 & this._capacity - 1;
          return this[index];
        };
        Deque.prototype.peekFront = function Deque$peekFront() {
          if (this._length === 0) {
            return void 0;
          }
          return this[this._front];
        };
        Deque.prototype.get = function Deque$get(index) {
          var i = index;
          if (i !== (i | 0)) {
            return void 0;
          }
          var len = this._length;
          if (i < 0) {
            i = i + len;
          }
          if (i < 0 || i >= len) {
            return void 0;
          }
          return this[this._front + i & this._capacity - 1];
        };
        Deque.prototype.isEmpty = function Deque$isEmpty() {
          return this._length === 0;
        };
        Deque.prototype.clear = function Deque$clear() {
          var len = this._length;
          var front = this._front;
          var capacity = this._capacity;
          for (var j = 0; j < len; ++j) {
            this[front + j & capacity - 1] = void 0;
          }
          this._length = 0;
          this._front = 0;
        };
        Deque.prototype.toString = function Deque$toString() {
          return this.toArray().toString();
        };
        Deque.prototype.valueOf = Deque.prototype.toString;
        Deque.prototype.removeFront = Deque.prototype.shift;
        Deque.prototype.removeBack = Deque.prototype.pop;
        Deque.prototype.insertFront = Deque.prototype.unshift;
        Deque.prototype.insertBack = Deque.prototype.push;
        Deque.prototype.enqueue = Deque.prototype.push;
        Deque.prototype.dequeue = Deque.prototype.shift;
        Deque.prototype.toJSON = Deque.prototype.toArray;
        Object.defineProperty(Deque.prototype, "length", {
          get: function get() {
            return this._length;
          },
          set: function set() {
            throw new RangeError("");
          }
        });
        Deque.prototype._checkCapacity = function Deque$_checkCapacity(size) {
          if (this._capacity < size) {
            this._resizeTo(getCapacity(this._capacity * 1.5 + 16));
          }
        };
        Deque.prototype._resizeTo = function Deque$_resizeTo(capacity) {
          var oldCapacity = this._capacity;
          this._capacity = capacity;
          var front = this._front;
          var length = this._length;
          if (front + length > oldCapacity) {
            var moveItemsCount = front + length & oldCapacity - 1;
            arrayMove(this, 0, this, oldCapacity, moveItemsCount);
          }
        };
        var isArray$4 = Array.isArray;
        function arrayMove(src, srcIndex, dst, dstIndex, len) {
          for (var j = 0; j < len; ++j) {
            dst[j + dstIndex] = src[j + srcIndex];
            src[j + srcIndex] = void 0;
          }
        }
        function pow2AtLeast(n) {
          n = n >>> 0;
          n = n - 1;
          n = n | n >> 1;
          n = n | n >> 2;
          n = n | n >> 4;
          n = n | n >> 8;
          n = n | n >> 16;
          return n + 1;
        }
        function getCapacity(capacity) {
          if (typeof capacity !== "number") {
            if (isArray$4(capacity)) {
              capacity = capacity.length;
            } else {
              return 16;
            }
          }
          return pow2AtLeast(Math.min(Math.max(16, capacity), 1073741824));
        }
        var deque = Deque;
        var check = function check(it) {
          return it && it.Math == Math && it;
        };

        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
        var global$f =
        // eslint-disable-next-line es/no-global-this -- safe
        check((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) == 'object' && globalThis) || check((typeof window === "undefined" ? "undefined" : _typeof(window)) == 'object' && window) ||
        // eslint-disable-next-line no-restricted-globals -- safe
        check((typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self) || check(_typeof(commonjsGlobal) == 'object' && commonjsGlobal) ||
        // eslint-disable-next-line no-new-func -- fallback
        function () {
          return this;
        }() || Function('return this')();
        var objectGetOwnPropertyDescriptor = {};
        var fails$9 = function fails$9(exec) {
          try {
            return !!exec();
          } catch (error) {
            return true;
          }
        };
        var fails$8 = fails$9;

        // Detect IE8's incomplete defineProperty implementation
        var descriptors = !fails$8(function () {
          // eslint-disable-next-line es/no-object-defineproperty -- required for testing
          return Object.defineProperty({}, 1, {
            get: function get() {
              return 7;
            }
          })[1] != 7;
        });
        var fails$7 = fails$9;
        var functionBindNative = !fails$7(function () {
          // eslint-disable-next-line es/no-function-prototype-bind -- safe
          var test = function () {/* empty */}.bind();
          // eslint-disable-next-line no-prototype-builtins -- safe
          return typeof test != 'function' || test.hasOwnProperty('prototype');
        });
        var NATIVE_BIND$3 = functionBindNative;
        var call$5 = Function.prototype.call;
        var functionCall = NATIVE_BIND$3 ? call$5.bind(call$5) : function () {
          return call$5.apply(call$5, arguments);
        };
        var objectPropertyIsEnumerable = {};
        var $propertyIsEnumerable = {}.propertyIsEnumerable;
        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
        var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

        // Nashorn ~ JDK8 bug
        var NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({
          1: 2
        }, 1);

        // `Object.prototype.propertyIsEnumerable` method implementation
        // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
        objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
          var descriptor = getOwnPropertyDescriptor$1(this, V);
          return !!descriptor && descriptor.enumerable;
        } : $propertyIsEnumerable;
        var createPropertyDescriptor$2 = function createPropertyDescriptor$2(bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value: value
          };
        };
        var NATIVE_BIND$2 = functionBindNative;
        var FunctionPrototype$2 = Function.prototype;
        var call$4 = FunctionPrototype$2.call;
        var uncurryThisWithBind = NATIVE_BIND$2 && FunctionPrototype$2.bind.bind(call$4, call$4);
        var functionUncurryThis = NATIVE_BIND$2 ? uncurryThisWithBind : function (fn) {
          return function () {
            return call$4.apply(fn, arguments);
          };
        };
        var uncurryThis$a = functionUncurryThis;
        var toString$1 = uncurryThis$a({}.toString);
        var stringSlice = uncurryThis$a(''.slice);
        var classofRaw$1 = function classofRaw$1(it) {
          return stringSlice(toString$1(it), 8, -1);
        };
        var uncurryThis$9 = functionUncurryThis;
        var fails$6 = fails$9;
        var classof$1 = classofRaw$1;
        var $Object$2 = Object;
        var split$1 = uncurryThis$9(''.split);

        // fallback for non-array-like ES3 and non-enumerable old V8 strings
        var indexedObject = fails$6(function () {
          // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
          // eslint-disable-next-line no-prototype-builtins -- safe
          return !$Object$2('z').propertyIsEnumerable(0);
        }) ? function (it) {
          return classof$1(it) == 'String' ? split$1(it, '') : $Object$2(it);
        } : $Object$2;

        // we can't use just `it == null` since of `document.all` special case
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
        var isNullOrUndefined$2 = function isNullOrUndefined$2(it) {
          return it === null || it === undefined;
        };
        var isNullOrUndefined$1 = isNullOrUndefined$2;
        var $TypeError$8 = TypeError;

        // `RequireObjectCoercible` abstract operation
        // https://tc39.es/ecma262/#sec-requireobjectcoercible
        var requireObjectCoercible$2 = function requireObjectCoercible$2(it) {
          if (isNullOrUndefined$1(it)) throw $TypeError$8("Can't call method on " + it);
          return it;
        };

        // toObject with fallback for non-array-like ES3 strings
        var IndexedObject = indexedObject;
        var requireObjectCoercible$1 = requireObjectCoercible$2;
        var toIndexedObject$3 = function toIndexedObject$3(it) {
          return IndexedObject(requireObjectCoercible$1(it));
        };
        var documentAll$2 = (typeof document === "undefined" ? "undefined" : _typeof(document)) == 'object' && document.all;

        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        var IS_HTMLDDA = typeof documentAll$2 == 'undefined' && documentAll$2 !== undefined;
        var documentAll_1 = {
          all: documentAll$2,
          IS_HTMLDDA: IS_HTMLDDA
        };
        var $documentAll$1 = documentAll_1;
        var documentAll$1 = $documentAll$1.all;

        // `IsCallable` abstract operation
        // https://tc39.es/ecma262/#sec-iscallable
        var isCallable$b = $documentAll$1.IS_HTMLDDA ? function (argument) {
          return typeof argument == 'function' || argument === documentAll$1;
        } : function (argument) {
          return typeof argument == 'function';
        };
        var isCallable$a = isCallable$b;
        var $documentAll = documentAll_1;
        var documentAll = $documentAll.all;
        var isObject$5 = $documentAll.IS_HTMLDDA ? function (it) {
          return _typeof(it) == 'object' ? it !== null : isCallable$a(it) || it === documentAll;
        } : function (it) {
          return _typeof(it) == 'object' ? it !== null : isCallable$a(it);
        };
        var global$e = global$f;
        var isCallable$9 = isCallable$b;
        var aFunction = function aFunction(argument) {
          return isCallable$9(argument) ? argument : undefined;
        };
        var getBuiltIn$4 = function getBuiltIn$4(namespace, method) {
          return arguments.length < 2 ? aFunction(global$e[namespace]) : global$e[namespace] && global$e[namespace][method];
        };
        var uncurryThis$8 = functionUncurryThis;
        var objectIsPrototypeOf = uncurryThis$8({}.isPrototypeOf);
        var getBuiltIn$3 = getBuiltIn$4;
        var engineUserAgent = getBuiltIn$3('navigator', 'userAgent') || '';
        var global$d = global$f;
        var userAgent$1 = engineUserAgent;
        var process$2 = global$d.process;
        var Deno = global$d.Deno;
        var versions = process$2 && process$2.versions || Deno && Deno.version;
        var v8 = versions && versions.v8;
        var match, version;
        if (v8) {
          match = v8.split('.');
          // in old Chrome, versions of V8 isn't V8 = Chrome / 10
          // but their correct versions are not interesting for us
          version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
        }

        // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
        // so check `userAgent` even if `.v8` exists, but 0
        if (!version && userAgent$1) {
          match = userAgent$1.match(/Edge\/(\d+)/);
          if (!match || match[1] >= 74) {
            match = userAgent$1.match(/Chrome\/(\d+)/);
            if (match) version = +match[1];
          }
        }
        var engineV8Version = version;

        /* eslint-disable es/no-symbol -- required for testing */

        var V8_VERSION = engineV8Version;
        var fails$5 = fails$9;

        // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
        var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$5(function () {
          var symbol = Symbol();
          // Chrome 38 Symbol has incorrect toString conversion
          // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
          return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
          // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
          !Symbol.sham && V8_VERSION && V8_VERSION < 41;
        });

        /* eslint-disable es/no-symbol -- required for testing */

        var NATIVE_SYMBOL$1 = symbolConstructorDetection;
        var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && _typeof(Symbol.iterator) == 'symbol';
        var getBuiltIn$2 = getBuiltIn$4;
        var isCallable$8 = isCallable$b;
        var isPrototypeOf = objectIsPrototypeOf;
        var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
        var $Object$1 = Object;
        var isSymbol$3 = USE_SYMBOL_AS_UID$1 ? function (it) {
          return _typeof(it) == 'symbol';
        } : function (it) {
          var $Symbol = getBuiltIn$2('Symbol');
          return isCallable$8($Symbol) && isPrototypeOf($Symbol.prototype, $Object$1(it));
        };
        var $String$1 = String;
        var tryToString$1 = function tryToString$1(argument) {
          try {
            return $String$1(argument);
          } catch (error) {
            return 'Object';
          }
        };
        var isCallable$7 = isCallable$b;
        var tryToString = tryToString$1;
        var $TypeError$7 = TypeError;

        // `Assert: IsCallable(argument) is true`
        var aCallable$2 = function aCallable$2(argument) {
          if (isCallable$7(argument)) return argument;
          throw $TypeError$7(tryToString(argument) + ' is not a function');
        };
        var aCallable$1 = aCallable$2;
        var isNullOrUndefined = isNullOrUndefined$2;

        // `GetMethod` abstract operation
        // https://tc39.es/ecma262/#sec-getmethod
        var getMethod$1 = function getMethod$1(V, P) {
          var func = V[P];
          return isNullOrUndefined(func) ? undefined : aCallable$1(func);
        };
        var call$3 = functionCall;
        var isCallable$6 = isCallable$b;
        var isObject$4 = isObject$5;
        var $TypeError$6 = TypeError;

        // `OrdinaryToPrimitive` abstract operation
        // https://tc39.es/ecma262/#sec-ordinarytoprimitive
        var ordinaryToPrimitive$1 = function ordinaryToPrimitive$1(input, pref) {
          var fn, val;
          if (pref === 'string' && isCallable$6(fn = input.toString) && !isObject$4(val = call$3(fn, input))) return val;
          if (isCallable$6(fn = input.valueOf) && !isObject$4(val = call$3(fn, input))) return val;
          if (pref !== 'string' && isCallable$6(fn = input.toString) && !isObject$4(val = call$3(fn, input))) return val;
          throw $TypeError$6("Can't convert object to primitive value");
        };
        var shared$3 = {
          exports: {}
        };
        var global$c = global$f;

        // eslint-disable-next-line es/no-object-defineproperty -- safe
        var defineProperty$1 = Object.defineProperty;
        var defineGlobalProperty$3 = function defineGlobalProperty$3(key, value) {
          try {
            defineProperty$1(global$c, key, {
              value: value,
              configurable: true,
              writable: true
            });
          } catch (error) {
            global$c[key] = value;
          }
          return value;
        };
        var global$b = global$f;
        var defineGlobalProperty$2 = defineGlobalProperty$3;
        var SHARED = '__core-js_shared__';
        var store$3 = global$b[SHARED] || defineGlobalProperty$2(SHARED, {});
        var sharedStore = store$3;
        var store$2 = sharedStore;
        (shared$3.exports = function (key, value) {
          return store$2[key] || (store$2[key] = value !== undefined ? value : {});
        })('versions', []).push({
          version: '3.26.1',
          mode: 'global',
          copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
          license: 'https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE',
          source: 'https://github.com/zloirock/core-js'
        });
        var requireObjectCoercible = requireObjectCoercible$2;
        var $Object = Object;

        // `ToObject` abstract operation
        // https://tc39.es/ecma262/#sec-toobject
        var toObject$1 = function toObject$1(argument) {
          return $Object(requireObjectCoercible(argument));
        };
        var uncurryThis$7 = functionUncurryThis;
        var toObject = toObject$1;
        var hasOwnProperty = uncurryThis$7({}.hasOwnProperty);

        // `HasOwnProperty` abstract operation
        // https://tc39.es/ecma262/#sec-hasownproperty
        // eslint-disable-next-line es/no-object-hasown -- safe
        var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
          return hasOwnProperty(toObject(it), key);
        };
        var uncurryThis$6 = functionUncurryThis;
        var id = 0;
        var postfix = Math.random();
        var toString = uncurryThis$6(1.0.toString);
        var uid$2 = function uid$2(key) {
          return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
        };
        var global$a = global$f;
        var shared$2 = shared$3.exports;
        var hasOwn$9 = hasOwnProperty_1;
        var uid$1 = uid$2;
        var NATIVE_SYMBOL = symbolConstructorDetection;
        var USE_SYMBOL_AS_UID = useSymbolAsUid;
        var WellKnownSymbolsStore = shared$2('wks');
        var Symbol$1 = global$a.Symbol;
        var symbolFor = Symbol$1 && Symbol$1['for'];
        var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;
        var wellKnownSymbol$1 = function wellKnownSymbol$1(name) {
          if (!hasOwn$9(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
            var description = 'Symbol.' + name;
            if (NATIVE_SYMBOL && hasOwn$9(Symbol$1, name)) {
              WellKnownSymbolsStore[name] = Symbol$1[name];
            } else if (USE_SYMBOL_AS_UID && symbolFor) {
              WellKnownSymbolsStore[name] = symbolFor(description);
            } else {
              WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
            }
          }
          return WellKnownSymbolsStore[name];
        };
        var call$2 = functionCall;
        var isObject$3 = isObject$5;
        var isSymbol$2 = isSymbol$3;
        var getMethod = getMethod$1;
        var ordinaryToPrimitive = ordinaryToPrimitive$1;
        var wellKnownSymbol = wellKnownSymbol$1;
        var $TypeError$5 = TypeError;
        var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

        // `ToPrimitive` abstract operation
        // https://tc39.es/ecma262/#sec-toprimitive
        var toPrimitive$1 = function toPrimitive$1(input, pref) {
          if (!isObject$3(input) || isSymbol$2(input)) return input;
          var exoticToPrim = getMethod(input, TO_PRIMITIVE);
          var result;
          if (exoticToPrim) {
            if (pref === undefined) pref = 'default';
            result = call$2(exoticToPrim, input, pref);
            if (!isObject$3(result) || isSymbol$2(result)) return result;
            throw $TypeError$5("Can't convert object to primitive value");
          }
          if (pref === undefined) pref = 'number';
          return ordinaryToPrimitive(input, pref);
        };
        var toPrimitive = toPrimitive$1;
        var isSymbol$1 = isSymbol$3;

        // `ToPropertyKey` abstract operation
        // https://tc39.es/ecma262/#sec-topropertykey
        var toPropertyKey$2 = function toPropertyKey$2(argument) {
          var key = toPrimitive(argument, 'string');
          return isSymbol$1(key) ? key : key + '';
        };
        var global$9 = global$f;
        var isObject$2 = isObject$5;
        var document$1 = global$9.document;
        // typeof document.createElement is 'object' in old IE
        var EXISTS$1 = isObject$2(document$1) && isObject$2(document$1.createElement);
        var documentCreateElement = function documentCreateElement(it) {
          return EXISTS$1 ? document$1.createElement(it) : {};
        };
        var DESCRIPTORS$6 = descriptors;
        var fails$4 = fails$9;
        var createElement$1 = documentCreateElement;

        // Thanks to IE8 for its funny defineProperty
        var ie8DomDefine = !DESCRIPTORS$6 && !fails$4(function () {
          // eslint-disable-next-line es/no-object-defineproperty -- required for testing
          return Object.defineProperty(createElement$1('div'), 'a', {
            get: function get() {
              return 7;
            }
          }).a != 7;
        });
        var DESCRIPTORS$5 = descriptors;
        var call$1 = functionCall;
        var propertyIsEnumerableModule = objectPropertyIsEnumerable;
        var createPropertyDescriptor$1 = createPropertyDescriptor$2;
        var toIndexedObject$2 = toIndexedObject$3;
        var toPropertyKey$1 = toPropertyKey$2;
        var hasOwn$8 = hasOwnProperty_1;
        var IE8_DOM_DEFINE$1 = ie8DomDefine;

        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
        var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

        // `Object.getOwnPropertyDescriptor` method
        // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
        objectGetOwnPropertyDescriptor.f = DESCRIPTORS$5 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
          O = toIndexedObject$2(O);
          P = toPropertyKey$1(P);
          if (IE8_DOM_DEFINE$1) try {
            return $getOwnPropertyDescriptor$1(O, P);
          } catch (error) {/* empty */}
          if (hasOwn$8(O, P)) return createPropertyDescriptor$1(!call$1(propertyIsEnumerableModule.f, O, P), O[P]);
        };
        var objectDefineProperty = {};
        var DESCRIPTORS$4 = descriptors;
        var fails$3 = fails$9;

        // V8 ~ Chrome 36-
        // https://bugs.chromium.org/p/v8/issues/detail?id=3334
        var v8PrototypeDefineBug = DESCRIPTORS$4 && fails$3(function () {
          // eslint-disable-next-line es/no-object-defineproperty -- required for testing
          return Object.defineProperty(function () {/* empty */}, 'prototype', {
            value: 42,
            writable: false
          }).prototype != 42;
        });
        var isObject$1 = isObject$5;
        var $String = String;
        var $TypeError$4 = TypeError;

        // `Assert: Type(argument) is Object`
        var anObject$2 = function anObject$2(argument) {
          if (isObject$1(argument)) return argument;
          throw $TypeError$4($String(argument) + ' is not an object');
        };
        var DESCRIPTORS$3 = descriptors;
        var IE8_DOM_DEFINE = ie8DomDefine;
        var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
        var anObject$1 = anObject$2;
        var toPropertyKey = toPropertyKey$2;
        var $TypeError$3 = TypeError;
        // eslint-disable-next-line es/no-object-defineproperty -- safe
        var $defineProperty = Object.defineProperty;
        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var ENUMERABLE = 'enumerable';
        var CONFIGURABLE$1 = 'configurable';
        var WRITABLE = 'writable';

        // `Object.defineProperty` method
        // https://tc39.es/ecma262/#sec-object.defineproperty
        objectDefineProperty.f = DESCRIPTORS$3 ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
          anObject$1(O);
          P = toPropertyKey(P);
          anObject$1(Attributes);
          if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
            var current = $getOwnPropertyDescriptor(O, P);
            if (current && current[WRITABLE]) {
              O[P] = Attributes.value;
              Attributes = {
                configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
                enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                writable: false
              };
            }
          }
          return $defineProperty(O, P, Attributes);
        } : $defineProperty : function defineProperty(O, P, Attributes) {
          anObject$1(O);
          P = toPropertyKey(P);
          anObject$1(Attributes);
          if (IE8_DOM_DEFINE) try {
            return $defineProperty(O, P, Attributes);
          } catch (error) {/* empty */}
          if ('get' in Attributes || 'set' in Attributes) throw $TypeError$3('Accessors not supported');
          if ('value' in Attributes) O[P] = Attributes.value;
          return O;
        };
        var DESCRIPTORS$2 = descriptors;
        var definePropertyModule$2 = objectDefineProperty;
        var createPropertyDescriptor = createPropertyDescriptor$2;
        var createNonEnumerableProperty$2 = DESCRIPTORS$2 ? function (object, key, value) {
          return definePropertyModule$2.f(object, key, createPropertyDescriptor(1, value));
        } : function (object, key, value) {
          object[key] = value;
          return object;
        };
        var makeBuiltIn$2 = {
          exports: {}
        };
        var DESCRIPTORS$1 = descriptors;
        var hasOwn$7 = hasOwnProperty_1;
        var FunctionPrototype$1 = Function.prototype;
        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
        var getDescriptor = DESCRIPTORS$1 && Object.getOwnPropertyDescriptor;
        var EXISTS = hasOwn$7(FunctionPrototype$1, 'name');
        // additional protection from minified / mangled / dropped function names
        var PROPER = EXISTS && function something() {/* empty */}.name === 'something';
        var CONFIGURABLE = EXISTS && (!DESCRIPTORS$1 || DESCRIPTORS$1 && getDescriptor(FunctionPrototype$1, 'name').configurable);
        var functionName = {
          EXISTS: EXISTS,
          PROPER: PROPER,
          CONFIGURABLE: CONFIGURABLE
        };
        var uncurryThis$5 = functionUncurryThis;
        var isCallable$5 = isCallable$b;
        var store$1 = sharedStore;
        var functionToString$1 = uncurryThis$5(Function.toString);

        // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
        if (!isCallable$5(store$1.inspectSource)) {
          store$1.inspectSource = function (it) {
            return functionToString$1(it);
          };
        }
        var inspectSource$1 = store$1.inspectSource;
        var global$8 = global$f;
        var isCallable$4 = isCallable$b;
        var WeakMap$2 = global$8.WeakMap;
        var weakMapBasicDetection = isCallable$4(WeakMap$2) && /native code/.test(String(WeakMap$2));
        var shared$1 = shared$3.exports;
        var uid = uid$2;
        var keys = shared$1('keys');
        var sharedKey$1 = function sharedKey$1(key) {
          return keys[key] || (keys[key] = uid(key));
        };
        var hiddenKeys$3 = {};
        var NATIVE_WEAK_MAP = weakMapBasicDetection;
        var global$7 = global$f;
        var isObject = isObject$5;
        var createNonEnumerableProperty$1 = createNonEnumerableProperty$2;
        var hasOwn$6 = hasOwnProperty_1;
        var shared = sharedStore;
        var sharedKey = sharedKey$1;
        var hiddenKeys$2 = hiddenKeys$3;
        var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
        var TypeError$1 = global$7.TypeError;
        var WeakMap$1 = global$7.WeakMap;
        var set$1, get, has$4;
        var enforce = function enforce(it) {
          return has$4(it) ? get(it) : set$1(it, {});
        };
        var getterFor = function getterFor(TYPE) {
          return function (it) {
            var state;
            if (!isObject(it) || (state = get(it)).type !== TYPE) {
              throw TypeError$1('Incompatible receiver, ' + TYPE + ' required');
            }
            return state;
          };
        };
        if (NATIVE_WEAK_MAP || shared.state) {
          var store = shared.state || (shared.state = new WeakMap$1());
          /* eslint-disable no-self-assign -- prototype methods protection */
          store.get = store.get;
          store.has = store.has;
          store.set = store.set;
          /* eslint-enable no-self-assign -- prototype methods protection */
          set$1 = function set$1(it, metadata) {
            if (store.has(it)) throw TypeError$1(OBJECT_ALREADY_INITIALIZED);
            metadata.facade = it;
            store.set(it, metadata);
            return metadata;
          };
          get = function get(it) {
            return store.get(it) || {};
          };
          has$4 = function has$4(it) {
            return store.has(it);
          };
        } else {
          var STATE = sharedKey('state');
          hiddenKeys$2[STATE] = true;
          set$1 = function set$1(it, metadata) {
            if (hasOwn$6(it, STATE)) throw TypeError$1(OBJECT_ALREADY_INITIALIZED);
            metadata.facade = it;
            createNonEnumerableProperty$1(it, STATE, metadata);
            return metadata;
          };
          get = function get(it) {
            return hasOwn$6(it, STATE) ? it[STATE] : {};
          };
          has$4 = function has$4(it) {
            return hasOwn$6(it, STATE);
          };
        }
        var internalState = {
          set: set$1,
          get: get,
          has: has$4,
          enforce: enforce,
          getterFor: getterFor
        };
        var fails$2 = fails$9;
        var isCallable$3 = isCallable$b;
        var hasOwn$5 = hasOwnProperty_1;
        var DESCRIPTORS = descriptors;
        var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
        var inspectSource = inspectSource$1;
        var InternalStateModule = internalState;
        var enforceInternalState = InternalStateModule.enforce;
        var getInternalState = InternalStateModule.get;
        // eslint-disable-next-line es/no-object-defineproperty -- safe
        var defineProperty = Object.defineProperty;
        var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails$2(function () {
          return defineProperty(function () {/* empty */}, 'length', {
            value: 8
          }).length !== 8;
        });
        var TEMPLATE = String(String).split('String');
        var makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {
          if (String(name).slice(0, 7) === 'Symbol(') {
            name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
          }
          if (options && options.getter) name = 'get ' + name;
          if (options && options.setter) name = 'set ' + name;
          if (!hasOwn$5(value, 'name') || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
            if (DESCRIPTORS) defineProperty(value, 'name', {
              value: name,
              configurable: true
            });else value.name = name;
          }
          if (CONFIGURABLE_LENGTH && options && hasOwn$5(options, 'arity') && value.length !== options.arity) {
            defineProperty(value, 'length', {
              value: options.arity
            });
          }
          try {
            if (options && hasOwn$5(options, 'constructor') && options.constructor) {
              if (DESCRIPTORS) defineProperty(value, 'prototype', {
                writable: false
              });
              // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
            } else if (value.prototype) value.prototype = undefined;
          } catch (error) {/* empty */}
          var state = enforceInternalState(value);
          if (!hasOwn$5(state, 'source')) {
            state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
          }
          return value;
        };

        // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
        // eslint-disable-next-line no-extend-native -- required
        Function.prototype.toString = makeBuiltIn$1(function toString() {
          return isCallable$3(this) && getInternalState(this).source || inspectSource(this);
        }, 'toString');
        var isCallable$2 = isCallable$b;
        var definePropertyModule$1 = objectDefineProperty;
        var makeBuiltIn = makeBuiltIn$2.exports;
        var defineGlobalProperty$1 = defineGlobalProperty$3;
        var defineBuiltIn$1 = function defineBuiltIn$1(O, key, value, options) {
          if (!options) options = {};
          var simple = options.enumerable;
          var name = options.name !== undefined ? options.name : key;
          if (isCallable$2(value)) makeBuiltIn(value, name, options);
          if (options.global) {
            if (simple) O[key] = value;else defineGlobalProperty$1(key, value);
          } else {
            try {
              if (!options.unsafe) delete O[key];else if (O[key]) simple = true;
            } catch (error) {/* empty */}
            if (simple) O[key] = value;else definePropertyModule$1.f(O, key, {
              value: value,
              enumerable: false,
              configurable: !options.nonConfigurable,
              writable: !options.nonWritable
            });
          }
          return O;
        };
        var objectGetOwnPropertyNames = {};
        var ceil = Math.ceil;
        var floor = Math.floor;

        // `Math.trunc` method
        // https://tc39.es/ecma262/#sec-math.trunc
        // eslint-disable-next-line es/no-math-trunc -- safe
        var mathTrunc = Math.trunc || function trunc(x) {
          var n = +x;
          return (n > 0 ? floor : ceil)(n);
        };
        var trunc = mathTrunc;

        // `ToIntegerOrInfinity` abstract operation
        // https://tc39.es/ecma262/#sec-tointegerorinfinity
        var toIntegerOrInfinity$2 = function toIntegerOrInfinity$2(argument) {
          var number = +argument;
          // eslint-disable-next-line no-self-compare -- NaN check
          return number !== number || number === 0 ? 0 : trunc(number);
        };
        var toIntegerOrInfinity$1 = toIntegerOrInfinity$2;
        var max$1 = Math.max;
        var min$2 = Math.min;

        // Helper for a popular repeating case of the spec:
        // Let integer be ? ToInteger(index).
        // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
        var toAbsoluteIndex$1 = function toAbsoluteIndex$1(index, length) {
          var integer = toIntegerOrInfinity$1(index);
          return integer < 0 ? max$1(integer + length, 0) : min$2(integer, length);
        };
        var toIntegerOrInfinity = toIntegerOrInfinity$2;
        var min$1 = Math.min;

        // `ToLength` abstract operation
        // https://tc39.es/ecma262/#sec-tolength
        var toLength$1 = function toLength$1(argument) {
          return argument > 0 ? min$1(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
        };

        var toLength = toLength$1;

        // `LengthOfArrayLike` abstract operation
        // https://tc39.es/ecma262/#sec-lengthofarraylike
        var lengthOfArrayLike$1 = function lengthOfArrayLike$1(obj) {
          return toLength(obj.length);
        };
        var toIndexedObject$1 = toIndexedObject$3;
        var toAbsoluteIndex = toAbsoluteIndex$1;
        var lengthOfArrayLike = lengthOfArrayLike$1;

        // `Array.prototype.{ indexOf, includes }` methods implementation
        var createMethod = function createMethod(IS_INCLUDES) {
          return function ($this, el, fromIndex) {
            var O = toIndexedObject$1($this);
            var length = lengthOfArrayLike(O);
            var index = toAbsoluteIndex(fromIndex, length);
            var value;
            // Array#includes uses SameValueZero equality algorithm
            // eslint-disable-next-line no-self-compare -- NaN check
            if (IS_INCLUDES && el != el) while (length > index) {
              value = O[index++];
              // eslint-disable-next-line no-self-compare -- NaN check
              if (value != value) return true;
              // Array#indexOf ignores holes, Array#includes - not
            } else for (; length > index; index++) {
              if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
            }
            return !IS_INCLUDES && -1;
          };
        };
        var arrayIncludes = {
          // `Array.prototype.includes` method
          // https://tc39.es/ecma262/#sec-array.prototype.includes
          includes: createMethod(true),
          // `Array.prototype.indexOf` method
          // https://tc39.es/ecma262/#sec-array.prototype.indexof
          indexOf: createMethod(false)
        };
        var uncurryThis$4 = functionUncurryThis;
        var hasOwn$4 = hasOwnProperty_1;
        var toIndexedObject = toIndexedObject$3;
        var indexOf$1 = arrayIncludes.indexOf;
        var hiddenKeys$1 = hiddenKeys$3;
        var push$1 = uncurryThis$4([].push);
        var objectKeysInternal = function objectKeysInternal(object, names) {
          var O = toIndexedObject(object);
          var i = 0;
          var result = [];
          var key;
          for (key in O) {
            !hasOwn$4(hiddenKeys$1, key) && hasOwn$4(O, key) && push$1(result, key);
          }
          // Don't enum bug & hidden keys
          while (names.length > i) {
            if (hasOwn$4(O, key = names[i++])) {
              ~indexOf$1(result, key) || push$1(result, key);
            }
          }
          return result;
        };

        // IE8- don't enum bug keys
        var enumBugKeys$1 = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];
        var internalObjectKeys = objectKeysInternal;
        var enumBugKeys = enumBugKeys$1;
        var hiddenKeys = enumBugKeys.concat('length', 'prototype');

        // `Object.getOwnPropertyNames` method
        // https://tc39.es/ecma262/#sec-object.getownpropertynames
        // eslint-disable-next-line es/no-object-getownpropertynames -- safe
        objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
          return internalObjectKeys(O, hiddenKeys);
        };
        var objectGetOwnPropertySymbols = {};

        // eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
        objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
        var getBuiltIn$1 = getBuiltIn$4;
        var uncurryThis$3 = functionUncurryThis;
        var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
        var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
        var anObject = anObject$2;
        var concat = uncurryThis$3([].concat);

        // all object keys, includes non-enumerable and symbols
        var ownKeys$1 = getBuiltIn$1('Reflect', 'ownKeys') || function ownKeys(it) {
          var keys = getOwnPropertyNamesModule.f(anObject(it));
          var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
        };
        var hasOwn$3 = hasOwnProperty_1;
        var ownKeys = ownKeys$1;
        var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
        var definePropertyModule = objectDefineProperty;
        var copyConstructorProperties$1 = function copyConstructorProperties$1(target, source, exceptions) {
          var keys = ownKeys(source);
          var defineProperty = definePropertyModule.f;
          var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!hasOwn$3(target, key) && !(exceptions && hasOwn$3(exceptions, key))) {
              defineProperty(target, key, getOwnPropertyDescriptor(source, key));
            }
          }
        };
        var fails$1 = fails$9;
        var isCallable$1 = isCallable$b;
        var replacement = /#|\.prototype\./;
        var isForced$1 = function isForced$1(feature, detection) {
          var value = data[normalize(feature)];
          return value == POLYFILL ? true : value == NATIVE ? false : isCallable$1(detection) ? fails$1(detection) : !!detection;
        };
        var normalize = isForced$1.normalize = function (string) {
          return String(string).replace(replacement, '.').toLowerCase();
        };
        var data = isForced$1.data = {};
        var NATIVE = isForced$1.NATIVE = 'N';
        var POLYFILL = isForced$1.POLYFILL = 'P';
        var isForced_1 = isForced$1;
        var global$6 = global$f;
        var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
        var createNonEnumerableProperty = createNonEnumerableProperty$2;
        var defineBuiltIn = defineBuiltIn$1;
        var defineGlobalProperty = defineGlobalProperty$3;
        var copyConstructorProperties = copyConstructorProperties$1;
        var isForced = isForced_1;

        /*
          options.target         - name of the target object
          options.global         - target is the global object
          options.stat           - export as static methods of target
          options.proto          - export as prototype methods of target
          options.real           - real prototype method for the `pure` version
          options.forced         - export even if the native feature is available
          options.bind           - bind methods to the target, required for the `pure` version
          options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
          options.unsafe         - use the simple assignment of property instead of delete + defineProperty
          options.sham           - add a flag to not completely full polyfills
          options.enumerable     - export as enumerable property
          options.dontCallGetSet - prevent calling a getter on target
          options.name           - the .name of the function if it does not match the key
        */
        var _export = function _export(options, source) {
          var TARGET = options.target;
          var GLOBAL = options.global;
          var STATIC = options.stat;
          var FORCED, target, key, targetProperty, sourceProperty, descriptor;
          if (GLOBAL) {
            target = global$6;
          } else if (STATIC) {
            target = global$6[TARGET] || defineGlobalProperty(TARGET, {});
          } else {
            target = (global$6[TARGET] || {}).prototype;
          }
          if (target) for (key in source) {
            sourceProperty = source[key];
            if (options.dontCallGetSet) {
              descriptor = getOwnPropertyDescriptor(target, key);
              targetProperty = descriptor && descriptor.value;
            } else targetProperty = target[key];
            FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
            // contained in target
            if (!FORCED && targetProperty !== undefined) {
              if (_typeof(sourceProperty) == _typeof(targetProperty)) continue;
              copyConstructorProperties(sourceProperty, targetProperty);
            }
            // add a flag to not completely full polyfills
            if (options.sham || targetProperty && targetProperty.sham) {
              createNonEnumerableProperty(sourceProperty, 'sham', true);
            }
            defineBuiltIn(target, key, sourceProperty, options);
          }
        };
        var NATIVE_BIND$1 = functionBindNative;
        var FunctionPrototype = Function.prototype;
        var apply$1 = FunctionPrototype.apply;
        var call = FunctionPrototype.call;

        // eslint-disable-next-line es/no-reflect -- safe
        var functionApply = (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) == 'object' && Reflect.apply || (NATIVE_BIND$1 ? call.bind(apply$1) : function () {
          return call.apply(apply$1, arguments);
        });
        var classofRaw = classofRaw$1;
        var uncurryThis$2 = functionUncurryThis;
        var functionUncurryThisClause = function functionUncurryThisClause(fn) {
          // Nashorn bug:
          //   https://github.com/zloirock/core-js/issues/1128
          //   https://github.com/zloirock/core-js/issues/1130
          if (classofRaw(fn) === 'Function') return uncurryThis$2(fn);
        };
        var uncurryThis$1 = functionUncurryThisClause;
        var aCallable = aCallable$2;
        var NATIVE_BIND = functionBindNative;
        var bind$3 = uncurryThis$1(uncurryThis$1.bind);

        // optional / simple context binding
        var functionBindContext = function functionBindContext(fn, that) {
          aCallable(fn);
          return that === undefined ? fn : NATIVE_BIND ? bind$3(fn, that) : function /* ...args */
          () {
            return fn.apply(that, arguments);
          };
        };
        var getBuiltIn = getBuiltIn$4;
        var html$1 = getBuiltIn('document', 'documentElement');
        var uncurryThis = functionUncurryThis;
        var arraySlice$1 = uncurryThis([].slice);
        var $TypeError$2 = TypeError;
        var validateArgumentsLength$1 = function validateArgumentsLength$1(passed, required) {
          if (passed < required) throw $TypeError$2('Not enough arguments');
          return passed;
        };
        var userAgent = engineUserAgent;
        var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
        var classof = classofRaw$1;
        var global$5 = global$f;
        var engineIsNode = classof(global$5.process) == 'process';
        var global$4 = global$f;
        var apply = functionApply;
        var bind$2 = functionBindContext;
        var isCallable = isCallable$b;
        var hasOwn$2 = hasOwnProperty_1;
        var fails = fails$9;
        var html = html$1;
        var arraySlice = arraySlice$1;
        var createElement = documentCreateElement;
        var validateArgumentsLength = validateArgumentsLength$1;
        var IS_IOS = engineIsIos;
        var IS_NODE = engineIsNode;
        var set = global$4.setImmediate;
        var clear = global$4.clearImmediate;
        var process$1 = global$4.process;
        var Dispatch = global$4.Dispatch;
        var Function$1 = global$4.Function;
        var MessageChannel = global$4.MessageChannel;
        var String$1 = global$4.String;
        var counter = 0;
        var queue = {};
        var ONREADYSTATECHANGE = 'onreadystatechange';
        var $location, defer, channel, port;
        try {
          // Deno throws a ReferenceError on `location` access without `--location` flag
          $location = global$4.location;
        } catch (error) {/* empty */}
        var run = function run(id) {
          if (hasOwn$2(queue, id)) {
            var fn = queue[id];
            delete queue[id];
            fn();
          }
        };
        var runner = function runner(id) {
          return function () {
            run(id);
          };
        };
        var listener = function listener(event) {
          run(event.data);
        };
        var post = function post(id) {
          // old engines have not location.origin
          global$4.postMessage(String$1(id), $location.protocol + '//' + $location.host);
        };

        // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
        if (!set || !clear) {
          set = function setImmediate(handler) {
            validateArgumentsLength(arguments.length, 1);
            var fn = isCallable(handler) ? handler : Function$1(handler);
            var args = arraySlice(arguments, 1);
            queue[++counter] = function () {
              apply(fn, undefined, args);
            };
            defer(counter);
            return counter;
          };
          clear = function clearImmediate(id) {
            delete queue[id];
          };
          // Node.js 0.8-
          if (IS_NODE) {
            defer = function defer(id) {
              process$1.nextTick(runner(id));
            };
            // Sphere (JS game engine) Dispatch API
          } else if (Dispatch && Dispatch.now) {
            defer = function defer(id) {
              Dispatch.now(runner(id));
            };
            // Browsers with MessageChannel, includes WebWorkers
            // except iOS - https://github.com/zloirock/core-js/issues/624
          } else if (MessageChannel && !IS_IOS) {
            channel = new MessageChannel();
            port = channel.port2;
            channel.port1.onmessage = listener;
            defer = bind$2(port.postMessage, port);
            // Browsers with postMessage, skip WebWorkers
            // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
          } else if (global$4.addEventListener && isCallable(global$4.postMessage) && !global$4.importScripts && $location && $location.protocol !== 'file:' && !fails(post)) {
            defer = post;
            global$4.addEventListener('message', listener, false);
            // IE8-
          } else if (ONREADYSTATECHANGE in createElement('script')) {
            defer = function defer(id) {
              html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
                html.removeChild(this);
                run(id);
              };
            };
            // Rest old browsers
          } else {
            defer = function defer(id) {
              setTimeout(runner(id), 0);
            };
          }
        }
        var task = {
          set: set,
          clear: clear
        };
        var $$1 = _export;
        var global$3 = global$f;
        var clearImmediate$1 = task.clear;

        // `clearImmediate` method
        // http://w3c.github.io/setImmediate/#si-clearImmediate
        $$1({
          global: true,
          bind: true,
          enumerable: true,
          forced: global$3.clearImmediate !== clearImmediate$1
        }, {
          clearImmediate: clearImmediate$1
        });
        var $ = _export;
        var global$2 = global$f;
        var setImmediate$1 = task.set;

        // `setImmediate` method
        // http://w3c.github.io/setImmediate/#si-setImmediate
        $({
          global: true,
          bind: true,
          enumerable: true,
          forced: global$2.setImmediate !== setImmediate$1
        }, {
          setImmediate: setImmediate$1
        });
        var global$1 = global$f;
        var path$2 = global$1;
        var path$1 = path$2;
        path$1.setImmediate;
        var path = path$2;
        path.clearImmediate;
        var SpectrumWaterfall = /*#__PURE__*/function () {
          function SpectrumWaterfall(endpoint, settings) {
            _classCallCheck(this, SpectrumWaterfall);
            this.endpoint = endpoint;
            this.spectrum = false;
            this.waterfall = false;
            this.waterfallQueue = new deque(10);
            this.drawnWaterfallQueue = new deque(1024);
            this.lagTime = 0;
            this.spectrumAlpha = 0.5;
            this.spectrumFiltered = [[-1, -1], [0]];
            this.waterfallColourShift = 80;
            // https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f
            this.colormap = [];
            this.setColormap('gqrx');
            this.clients = {};
            this.clientColormap = computeColormapArray(getColormap('rainbow'));
            this.updateTimeout = setTimeout(function () {}, 0);
            this.lineResets = 0;
          }
          _createClass(SpectrumWaterfall, [{
            key: "initCanvas",
            value: function initCanvas(settings) {
              this.canvasElem = settings.canvasElem;
              this.ctx = this.canvasElem.getContext('2d');
              this.canvasWidth = this.canvasElem.width;
              this.canvasHeight = this.canvasElem.height;
              this.backgroundColor = window.getComputedStyle(document.body, null).getPropertyValue('background-color');
              this.curLine = this.canvasHeight / 2;
              this.ctx.fillStyle = this.backgroundColor;
              this.ctx.fillRect(0, 0, this.canvasElem.width, this.canvasElem.height);
              this.graduationCanvasElem = settings.graduationCanvasElem;
              this.graduationCtx = this.graduationCanvasElem.getContext('2d');
              this.spectrumCanvasElem = settings.spectrumCanvasElem;
              this.spectrumCtx = this.spectrumCanvasElem.getContext('2d');
              this.spectrumCanvasElem.addEventListener('mousemove', this.spectrumMouseMove.bind(this));
              this.spectrumCanvasElem.addEventListener('mouseleave', this.spectrumMouseLeave.bind(this));
              this.tempCanvasElem = document.createElement('canvas');
              this.tempCtx = this.tempCanvasElem.getContext('2d');
              this.tempCanvasElem.width = this.canvasWidth;
              this.tempCanvasElem.height = 200;
              this.waterfall = true;
            }
          }, {
            key: "init",
            value: function () {
              var _init3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
                var _this26 = this;
                return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                  while (1) {
                    switch (_context12.prev = _context12.next) {
                      case 0:
                        if (!this.promise) {
                          _context12.next = 2;
                          break;
                        }
                        return _context12.abrupt("return", this.promise);
                      case 2:
                        this.waterfallSocket = new WebSocket(this.endpoint);
                        this.waterfallSocket.binaryType = 'arraybuffer';
                        this.firstWaterfallMessage = true;
                        this.waterfallSocket.onmessage = this.socketMessageInitial.bind(this);
                        this.promise = new Promise(function (resolve, reject) {
                          _this26.resolvePromise = resolve;
                          _this26.rejectPromise = reject;
                        });
                        return _context12.abrupt("return", this.promise);
                      case 8:
                      case "end":
                        return _context12.stop();
                    }
                  }
                }, _callee12, this);
              }));
              function init() {
                return _init3.apply(this, arguments);
              }
              return init;
            }()
          }, {
            key: "stop",
            value: function stop() {
              this.waterfallSocket.close();
            }
          }, {
            key: "socketMessageInitial",
            value: function socketMessageInitial(event) {
              var _this27 = this;
              // First message gives the parameters in json
              if (!(event.data instanceof ArrayBuffer)) {
                var _settings = JSON.parse(event.data);
                if (!_settings.fft_size) {
                  return;
                }
                this.waterfallMaxSize = _settings.fft_result_size;
                this.fftSize = _settings.fft_size;
                this.baseFreq = _settings.basefreq;
                this.sps = _settings.sps;
                this.totalBandwidth = _settings.total_bandwidth;
                this.overlap = _settings.overlap;
                this.canvasElem.width = _settings.waterfall_size;
                this.spectrumCanvasElem.width = _settings.waterfall_size;
                this.tempCanvasElem.width = _settings.waterfall_size;
                this.graduationCanvasElem.width = _settings.waterfall_size;
                this.canvasElem.height = this.canvasElem.parentElement.clientHeight * 2;
                this.canvasWidth = this.canvasElem.width;
                this.canvasHeight = this.canvasElem.height;
                this.ctx.fillStyle = this.backgroundColor;
                this.ctx.fillRect(0, 0, this.canvasElem.width, this.canvasElem.height);
                var skipNum = Math.max(1, Math.floor(this.sps / this.fftSize / 10.0) * 2);
                var waterfallFPS = this.sps / this.fftSize / (skipNum / 2);
                console.log('Waterfall FPS: ' + waterfallFPS);
                this.waterfallDrawInterval = setInterval(function () {
                  requestAnimationFrame(_this27.drawSpectrogram.bind(_this27));
                }, 1000 / waterfallFPS);
                this.waterfallL = 0;
                this.waterfallR = this.waterfallMaxSize;
                this.waterfallSocket.onmessage = this.socketMessage.bind(this);
                this.firstWaterfallMessage = false;
                if (_settings.waterfall_compression === 'av1') {
                  this.waterfallDecoder = new AV1WaterfallDecoder();
                } else if (_settings.waterfall_compression === 'zstd') {
                  this.waterfallDecoder = new ZstdWaterfallDecoder();
                }
                this.updateGraduation();
                this.resolvePromise(_settings);
              }
            }
          }, {
            key: "socketMessage",
            value: function socketMessage(event) {
              if (event.data instanceof ArrayBuffer) {
                this.enqueueSpectrogram(event.data);
              }
            }
          }, {
            key: "getMouseX",
            value: function getMouseX(canvas, evt) {
              var rect = canvas.getBoundingClientRect();
              var scaleX = canvas.width / rect.width;
              return (evt.clientX - rect.left) * scaleX;
            }
          }, {
            key: "enqueueSpectrogram",
            value: function enqueueSpectrogram(array) {
              var _this28 = this;
              // Do not decode or draw if not requested
              if (!this.waterfall && !this.spectrum) {
                this.waterfallQueue.clear();
                return;
              }
              if (this.waterfallQueue.length > 20) {
                this.waterfallQueue.pop();
                this.waterfallQueue.pop();
              }

              // Decode and extract header
              this.waterfallDecoder.decode(array).forEach(function (element) {
                _this28.waterfallQueue.unshift(element);
              });
            }
          }, {
            key: "transformValue",
            value: function transformValue(x) {
              return Math.min(Math.max(x + this.waterfallColourShift, 0), 255);
            }

            // Helper functions
          }, {
            key: "idxToFreq",
            value: function idxToFreq(idx) {
              return idx / this.waterfallMaxSize * this.totalBandwidth + this.baseFreq;
            }
          }, {
            key: "idxToCanvasX",
            value: function idxToCanvasX(idx) {
              return (idx - this.waterfallL) / (this.waterfallR - this.waterfallL) * this.canvasWidth;
            }
          }, {
            key: "canvasXtoFreq",
            value: function canvasXtoFreq(x) {
              var idx = x / this.canvasWidth * (this.waterfallR - this.waterfallL) + this.waterfallL;
              return this.idxToFreq(idx);
            }
          }, {
            key: "freqToIdx",
            value: function freqToIdx(freq) {
              return (freq - this.baseFreq) / this.totalBandwidth * this.waterfallMaxSize;
            }

            // Drawing functions
          }, {
            key: "calculateOffsets",
            value: function calculateOffsets(waterfallArray, curL, curR) {
              // Correct for zooming or shifting
              var pxPerIdx = this.canvasWidth / (this.waterfallR - this.waterfallL);
              var pxL = (curL - this.waterfallL) * pxPerIdx;
              var pxR = (curR - this.waterfallL) * pxPerIdx;
              var arr = new Uint8Array(waterfallArray.length);
              for (var _i20 = 0; _i20 < arr.length; _i20++) {
                arr[_i20] = this.transformValue(waterfallArray[_i20]);
              }
              return [arr, pxL, pxR];
            }
          }, {
            key: "drawSpectrogram",
            value: function drawSpectrogram() {
              if (this.waterfallQueue.length === 0) {
                return;
              }
              var _this$waterfallQueue$ = this.waterfallQueue.pop(),
                _this$waterfallQueue$2 = _slicedToArray(_this$waterfallQueue$, 3),
                waterfallArray = _this$waterfallQueue$2[0],
                curL = _this$waterfallQueue$2[1],
                curR = _this$waterfallQueue$2[2];
              var _this$calculateOffset = this.calculateOffsets(waterfallArray, curL, curR),
                _this$calculateOffset2 = _slicedToArray(_this$calculateOffset, 3),
                arr = _this$calculateOffset2[0],
                pxL = _this$calculateOffset2[1],
                pxR = _this$calculateOffset2[2];
              if (this.waterfall) {
                this.drawWaterfall(arr, pxL, pxR, curL, curR);
              }
              if (this.spectrum) {
                this.drawSpectrum(arr, pxL, pxR, curL, curR);
              }
              this.drawnWaterfallQueue.unshift([waterfallArray, curL, curR]);
              if (this.drawnWaterfallQueue.length > this.canvasHeight) {
                this.drawnWaterfallQueue.pop();
              }
            }
          }, {
            key: "redrawWaterfall",
            value: function () {
              var _redrawWaterfall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
                var _this29 = this;
                var toDraw, curLineReset, curLine, drawLine;
                return _regeneratorRuntime().wrap(function _callee13$(_context13) {
                  while (1) {
                    switch (_context13.prev = _context13.next) {
                      case 0:
                        toDraw = this.drawnWaterfallQueue.toArray();
                        curLineReset = this.lineResets;
                        curLine = this.curLine;
                        drawLine = function drawLine(i) {
                          var toDrawLine = curLine + 1 + i + (_this29.lineResets - curLineReset) * _this29.canvasHeight / 2;
                          var _toDraw$i = _slicedToArray(toDraw[i], 3),
                            waterfallArray = _toDraw$i[0],
                            curL = _toDraw$i[1],
                            curR = _toDraw$i[2];
                          var _this29$calculateOffs = _this29.calculateOffsets(waterfallArray, curL, curR),
                            _this29$calculateOffs2 = _slicedToArray(_this29$calculateOffs, 3),
                            arr = _this29$calculateOffs2[0],
                            pxL = _this29$calculateOffs2[1],
                            pxR = _this29$calculateOffs2[2];
                          _this29.drawWaterfallLine(arr, pxL, pxR, toDrawLine);
                          if (i + 1 < toDraw.length) {
                            _this29.updateImmediate = setImmediate(function () {
                              return drawLine(i + 1);
                            });
                          }
                        };
                        clearImmediate(this.updateImmediate);
                        if (toDraw.length) {
                          drawLine(0);
                        }
                      case 6:
                      case "end":
                        return _context13.stop();
                    }
                  }
                }, _callee13, this);
              }));
              function redrawWaterfall() {
                return _redrawWaterfall.apply(this, arguments);
              }
              return redrawWaterfall;
            }()
          }, {
            key: "drawWaterfallLine",
            value: function drawWaterfallLine(arr, pxL, pxR, line) {
              // Draw the new line
              var colorarr = this.ctx.createImageData(arr.length, 1);
              var bmparr = new Uint8Array(arr.length * 4);
              for (var _i21 = 0; _i21 < arr.length; _i21++) {
                colorarr.data.set(this.colormap[arr[_i21]], _i21 * 4);
                bmparr[_i21 * 4 + 0] = 255;
                bmparr[_i21 * 4 + 1] = this.colormap[arr[_i21]][2];
                bmparr[_i21 * 4 + 2] = this.colormap[arr[_i21]][1];
                bmparr[_i21 * 4 + 3] = this.colormap[arr[_i21]][0];
              }
              this.ctx.putImageData(colorarr, 0, 0);
              // Resize the line into the correct width
              this.ctx.drawImage(this.canvasElem, 0, 0, arr.length, 1, pxL, line, pxR - pxL, 1);
            }
          }, {
            key: "drawWaterfall",
            value: function drawWaterfall(arr, pxL, pxR, curL, curR) {
              this.drawWaterfallLine(arr, pxL, pxR, this.curLine);

              // Shift the spectrogram down by 1 pixel
              this.canvasElem.style.transform = "translate3d(0, -".concat((this.curLine + 1) / this.canvasHeight * 100, "%, 0)");

              // Once we have reached the start of the canvas, reset to the middle
              if (this.curLine === 0) {
                this.ctx.drawImage(this.canvasElem, 0, this.canvasHeight / 2);
                this.curLine = this.canvasHeight / 2;
                this.lineResets++;
              }
              this.curLine -= 1;
            }
          }, {
            key: "drawSpectrum",
            value: function drawSpectrum(arr, pxL, pxR, curL, curR) {
              var _this30 = this;
              if (curL !== this.spectrumFiltered[0][0] || curR !== this.spectrumFiltered[0][1]) {
                this.spectrumFiltered[1] = arr;
                this.spectrumFiltered[0] = [curL, curR];
              }

              // Smooth the spectrogram with the previous values
              for (var _i22 = 0; _i22 < arr.length; _i22++) {
                this.spectrumFiltered[1][_i22] = this.spectrumAlpha * arr[_i22] + (1 - this.spectrumAlpha) * this.spectrumFiltered[1][_i22];
              }

              // Take the smoothed value
              arr = this.spectrumFiltered[1];
              var pixels = (pxR - pxL) / arr.length;
              arr = arr.map(function (x) {
                return 255 - x;
              });

              // Blank the screen
              this.spectrumCtx.clearRect(0, 0, this.spectrumCanvasElem.width, this.spectrumCanvasElem.height);
              this.spectrumCtx.strokeStyle = 'yellow';
              this.spectrumCtx.fillStyle = 'yellow';

              // Draw the line
              this.spectrumCtx.beginPath();
              this.spectrumCtx.moveTo(pxL, arr[0] / 2);
              arr.forEach(function (x, i) {
                _this30.spectrumCtx.lineTo(pxL + pixels / 2 + i * pixels, x / 2);
              });
              this.spectrumCtx.lineTo(pxR, arr[arr.length - 1] / 2);
              this.spectrumCtx.stroke();
              if (this.spectrumFreq) {
                this.spectrumCtx.fillText((this.spectrumFreq / 1e6).toFixed(8) + ' MHz', 10, 10);
                this.spectrumCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                this.spectrumCtx.beginPath();
                this.spectrumCtx.moveTo(this.spectrumX, 0);
                this.spectrumCtx.lineTo(this.spectrumX, 128);
                this.spectrumCtx.stroke();
              }
            }
          }, {
            key: "updateGraduation",
            value: function updateGraduation() {
              var freqL = this.idxToFreq(this.waterfallL);
              var freqR = this.idxToFreq(this.waterfallR);
              var graduationSpacing = 1;

              // Calculate the scale where at least 20 graduation spacings will be drawn
              while ((freqR - freqL) / graduationSpacing > 5) {
                graduationSpacing *= 10;
              }
              graduationSpacing /= 10;
              this.graduationCtx.fillStyle = 'white';
              this.graduationCtx.strokeStyle = 'white';
              this.graduationCtx.clearRect(0, 0, this.graduationCanvasElem.width, this.graduationCanvasElem.height);

              // Find the first graduation frequency
              var freqLStart = freqL;
              if (freqL % graduationSpacing !== 0) {
                freqLStart = freqL + (graduationSpacing - freqL % graduationSpacing);
              }

              // Find the least amount of trailing zeros
              var minimumTrailingZeros = 5;
              for (var freqStart = freqLStart; freqStart <= freqR; freqStart += graduationSpacing) {
                var trailingZeros = freqStart.toString().match(/0*$/g)[0].length;
                minimumTrailingZeros = Math.min(minimumTrailingZeros, trailingZeros);
              }
              this.graduationCtx.font = '15px Arial';
              for (; freqLStart <= freqR; freqLStart += graduationSpacing) {
                // find the middle pixel
                var middlePixel = (freqLStart - freqL) / (freqR - freqL) * this.canvasWidth;
                var lineHeight = 5;
                var printFreq = false;
                if (freqLStart % (graduationSpacing * 10) === 0) {
                  lineHeight = 10;
                  printFreq = true;
                } else if (freqLStart % (graduationSpacing * 5) === 0) {
                  lineHeight = 7;
                  printFreq = true;
                }
                if (printFreq) {
                  this.graduationCtx.textAlign = 'center';
                  this.graduationCtx.fillText((freqLStart / 1000000).toFixed(6 - minimumTrailingZeros) + ' MHz', middlePixel, 10);
                }
                // draw a line in the middle of it
                this.graduationCtx.beginPath();
                this.graduationCtx.moveTo(middlePixel, 10 + 0);
                this.graduationCtx.lineTo(middlePixel, 10 + lineHeight);
                this.graduationCtx.stroke();
              }
              this.drawClients();
            }
          }, {
            key: "setClients",
            value: function setClients(clients) {
              this.clients = clients;
            }
          }, {
            key: "drawClients",
            value: function drawClients() {
              var _this31 = this;
              Object.entries(this.clients).filter(function (_ref46) {
                var _ref47 = _slicedToArray(_ref46, 2),
                  _ = _ref47[0],
                  x = _ref47[1];
                return x[1] < _this31.waterfallR && x[1] >= _this31.waterfallL;
              }).forEach(function (_ref48) {
                var _ref49 = _slicedToArray(_ref48, 2),
                  id = _ref49[0],
                  range = _ref49[1];
                var midOffset = _this31.idxToCanvasX(range[1]);
                var _this31$clientColorma = _slicedToArray(_this31.clientColormap[parseInt(id.substring(0, 2), 16)], 4),
                  r = _this31$clientColorma[0],
                  g = _this31$clientColorma[1],
                  b = _this31$clientColorma[2],
                  a = _this31$clientColorma[3];
                _this31.graduationCtx.fillStyle = "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(a, ")");
                _this31.graduationCtx.strokeStyle = "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(a, ")");
                _this31.graduationCtx.beginPath();
                _this31.graduationCtx.moveTo(midOffset, 0);
                _this31.graduationCtx.lineTo(midOffset + 2, 5);
                _this31.graduationCtx.stroke();
                _this31.graduationCtx.beginPath();
                _this31.graduationCtx.moveTo(midOffset, 0);
                _this31.graduationCtx.lineTo(midOffset - 2, 5);
                _this31.graduationCtx.stroke();
                // this.graduationCtx.arc(midOffset, 2, 2, 0, 2 * Math.PI, 0)
                // this.graduationCtx.fill()
              });
            }
          }, {
            key: "setWaterfallRange",
            value: function setWaterfallRange(waterfallL, waterfallR) {
              if (waterfallL >= waterfallR) {
                return;
              }
              var width = waterfallR - waterfallL;
              // If there is out of bounds, fix the bounds
              if (waterfallL < 0 && waterfallR > this.waterfallMaxSize) {
                waterfallL = 0;
                waterfallR = this.waterfallMaxSize;
              } else if (waterfallL < 0) {
                waterfallL = 0;
                waterfallR = width;
              } else if (waterfallR > this.waterfallMaxSize) {
                waterfallR = this.waterfallMaxSize;
                waterfallL = waterfallR - width;
              }
              var prevL = this.waterfallL;
              var prevR = this.waterfallR;
              this.waterfallL = waterfallL;
              this.waterfallR = waterfallR;
              this.waterfallSocket.send(JSON.stringify({
                cmd: 'window',
                l: this.waterfallL,
                r: this.waterfallR
              }));
              var newCanvasX1 = this.idxToCanvasX(prevL);
              var newCanvasX2 = this.idxToCanvasX(prevR);
              var newCanvasWidth = newCanvasX2 - newCanvasX1;
              this.ctx.drawImage(this.canvasElem, 0, 0, this.canvasWidth, this.canvasHeight, newCanvasX1, 0, newCanvasWidth, this.canvasHeight);

              // Special case for zoom out or panning, blank the borders
              if (prevR - prevL <= waterfallR - waterfallL) {
                this.ctx.fillStyle = this.backgroundColor;
                this.ctx.fillRect(0, 0, newCanvasX1, this.canvasHeight);
                this.ctx.fillRect(newCanvasX2, 0, this.canvasWidth - newCanvasX2, this.canvasHeight);
              }
              this.updateGraduation();
              this.resetRedrawTimeout(500);
            }
          }, {
            key: "getWaterfallRange",
            value: function getWaterfallRange() {
              return [this.waterfallL, this.waterfallR];
            }
          }, {
            key: "setWaterfallLagTime",
            value: function setWaterfallLagTime(lagTime) {
              this.lagTime = Math.max(0, lagTime);
            }
          }, {
            key: "setOffset",
            value: function setOffset(offset) {
              this.waterfallColourShift = offset;
              this.resetRedrawTimeout(100);
            }
          }, {
            key: "setAlpha",
            value: function setAlpha(alpha) {
              this.spectrumAlpha = alpha;
            }
          }, {
            key: "setColormapArray",
            value: function setColormapArray(colormap) {
              this.colormap = computeColormapArray(colormap);
            }
          }, {
            key: "setColormap",
            value: function setColormap(name) {
              this.setColormapArray(getColormap(name));
              this.resetRedrawTimeout(50);
            }
          }, {
            key: "setUserID",
            value: function setUserID(userID) {
              this.waterfallSocket.send(JSON.stringify({
                cmd: 'userid',
                userid: userID
              }));
            }
          }, {
            key: "setSpectrum",
            value: function setSpectrum(spectrum) {
              this.spectrum = spectrum;
            }
          }, {
            key: "setWaterfall",
            value: function setWaterfall(waterfall) {
              this.waterfall = waterfall;
            }
          }, {
            key: "resetRedrawTimeout",
            value: function resetRedrawTimeout(timeout) {
              if (this.updateTimeout !== undefined) {
                clearTimeout(this.updateTimeout);
              }
              this.updateTimeout = setTimeout(this.redrawWaterfall.bind(this), timeout);
            }
          }, {
            key: "canvasWheel",
            value: function canvasWheel(e) {
              // For UI to pass custom zoom range
              var x = (e.coords || {
                x: this.getMouseX(this.spectrumCanvasElem, e)
              }).x;
              e.preventDefault();
              var zoomAmount = e.deltaY || e.scale;
              var l = this.waterfallL;
              var r = this.waterfallR;
              // For UI to pass in a custom scale amount
              var scale = e.scaleAmount || 0.85;

              // Prevent zooming beyond a certain point
              if (r - l <= 128 && zoomAmount < 0) {
                return false;
              }
              var centerfreq = (r - l) * x / this.canvasWidth + l;
              var widthL = centerfreq - l;
              var widthR = r - centerfreq;
              if (zoomAmount < 0) {
                widthL *= scale;
                widthR *= scale;
              } else if (zoomAmount > 0) {
                widthL *= 1 / scale;
                widthR *= 1 / scale;
              }
              var waterfallL = Math.round(centerfreq - widthL);
              var waterfallR = Math.round(centerfreq + widthR);
              this.setWaterfallRange(waterfallL, waterfallR);
              return false;
            }
          }, {
            key: "mouseMove",
            value: function mouseMove(e) {
              // Figure out how much is dragged
              var mouseMovement = e.movementX;
              var frequencyMovement = Math.round(mouseMovement / this.canvasElem.getBoundingClientRect().width * (this.waterfallR - this.waterfallL));
              if (!frequencyMovement) {
                return;
              }
              var newL = this.waterfallL - frequencyMovement;
              var newR = this.waterfallR - frequencyMovement;
              this.setWaterfallRange(newL, newR);
            }
          }, {
            key: "spectrumMouseMove",
            value: function spectrumMouseMove(e) {
              var x = this.getMouseX(this.spectrumCanvasElem, e);
              var freq = this.canvasXtoFreq(x);
              this.spectrumFreq = freq;
              this.spectrumX = x;
            }
          }, {
            key: "spectrumMouseLeave",
            value: function spectrumMouseLeave(e) {
              this.spectrumFreq = undefined;
              this.spectrumX = undefined;
            }
          }]);
          return SpectrumWaterfall;
        }();
        var SpectrumEvent = /*#__PURE__*/function () {
          function SpectrumEvent(endpoint) {
            _classCallCheck(this, SpectrumEvent);
            this.endpoint = endpoint;
            this.signalClients = {};
            this.lastModified = performance.now();
          }
          _createClass(SpectrumEvent, [{
            key: "init",
            value: function init() {
              var _this32 = this;
              if (this.promise) {
                return this.promise;
              }
              this.eventSocket = new WebSocket(this.endpoint);
              this.eventSocket.binaryType = 'arraybuffer';
              this.eventSocket.onmessage = this.socketMessage.bind(this);
              this.promise = new Promise(function (resolve, reject) {
                _this32.eventSocket.onopen = resolve;
                _this32.resolvePromise = resolve;
                _this32.rejectPromise = reject;
              });
              return this.promise;
            }
          }, {
            key: "socketMessage",
            value: function socketMessage(event) {
              var data = JSON.parse(event.data);
              this.data = data;
              if ('signal_list' in data) {
                this.signalClients = data.signal_list;
              }
              if ('signal_changes' in data) {
                var signalChanges = data.signal_changes;
                for (var _i23 = 0, _Object$entries = Object.entries(signalChanges); _i23 < _Object$entries.length; _i23++) {
                  var _Object$entries$_i = _slicedToArray(_Object$entries[_i23], 2),
                    user = _Object$entries$_i[0],
                    range = _Object$entries$_i[1];
                  if (range[0] === -1 && range[1] === -1) {
                    delete this.signalClients[user];
                  } else {
                    this.signalClients[user] = range;
                  }
                }
              }
              this.lastModified = performance.now();
            }
          }, {
            key: "setUserID",
            value: function setUserID(userID) {
              this.eventSocket.send(JSON.stringify({
                cmd: 'userid',
                userid: userID
              }));
            }
          }, {
            key: "getSignalClients",
            value: function getSignalClients() {
              return this.signalClients;
            }
          }, {
            key: "getLastModified",
            value: function getLastModified() {
              return this.lastModified;
            }
          }]);
          return SpectrumEvent;
        }();
        var nanoid = function nanoid() {
          var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 21;
          return crypto.getRandomValues(new Uint8Array(size)).reduce(function (id, byte) {
            byte &= 63;
            if (byte < 36) {
              id += byte.toString(36);
            } else if (byte < 62) {
              id += (byte - 26).toString(36).toUpperCase();
            } else if (byte > 62) {
              id += '-';
            } else {
              id += '_';
            }
            return id;
          }, '');
        };
        var settings;
        var location$1 = window.location;
        var baseUri = "".concat(location$1.protocol.replace('http', 'ws'), "//").concat(location$1.host);
        var waterfall = new SpectrumWaterfall(baseUri + '/waterfall');
        var audio = new SpectrumAudio(baseUri + '/audio');
        var events = new SpectrumEvent(baseUri + '/events');
        function init() {
          return _init4.apply(this, arguments);
        }
        function _init4() {
          _init4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
            var id;
            return _regeneratorRuntime().wrap(function _callee18$(_context18) {
              while (1) {
                switch (_context18.prev = _context18.next) {
                  case 0:
                    _context18.next = 2;
                    return initWrappers();
                  case 2:
                    _context18.next = 4;
                    return Promise.all([waterfall.init(), audio.init(), events.init()]);
                  case 4:
                    settings = audio.settings;
                    id = nanoid();
                    [waterfall, audio, events].forEach(function (s) {
                      s.setUserID(id);
                    });
                  case 7:
                  case "end":
                    return _context18.stop();
                }
              }
            }, _callee18);
          }));
          return _init4.apply(this, arguments);
        }
        function frequencyToWaterfallOffset(frequency) {
          var _waterfall$getWaterfa = waterfall.getWaterfallRange(),
            _waterfall$getWaterfa2 = _slicedToArray(_waterfall$getWaterfa, 2),
            waterfallL = _waterfall$getWaterfa2[0],
            waterfallR = _waterfall$getWaterfa2[1];
          var frequencyOffset = frequency - FFTOffsetToFrequency(waterfallL);
          return frequencyOffset / ((waterfallR - waterfallL) / settings.fft_result_size * settings.total_bandwidth);
        }
        function waterfallOffsetToFrequency(offset) {
          var _waterfall$getWaterfa3 = waterfall.getWaterfallRange(),
            _waterfall$getWaterfa4 = _slicedToArray(_waterfall$getWaterfa3, 2),
            waterfallL = _waterfall$getWaterfa4[0],
            waterfallR = _waterfall$getWaterfa4[1];
          var frequencyOffset = offset * ((waterfallR - waterfallL) / settings.fft_result_size) * settings.total_bandwidth;
          return frequencyOffset + FFTOffsetToFrequency(waterfallL);
        }
        function frequencyToFFTOffset(frequency) {
          var offset = (frequency - settings.basefreq) / settings.total_bandwidth;
          return offset * settings.fft_result_size;
        }
        function FFTOffsetToFrequency(offset) {
          var frequency = offset / settings.fft_result_size * settings.total_bandwidth;
          return frequency + settings.basefreq;
        }
        function bandwidthToWaterfallOffset(bandwidth) {
          var _waterfall$getWaterfa5 = waterfall.getWaterfallRange(),
            _waterfall$getWaterfa6 = _slicedToArray(_waterfall$getWaterfa5, 2),
            waterfallL = _waterfall$getWaterfa6[0],
            waterfallR = _waterfall$getWaterfa6[1];
          return bandwidth / settings.total_bandwidth * settings.fft_result_size / (waterfallR - waterfallL);
        }
        function getMaximumBandwidth() {
          return audio.trueAudioSps;
        }
        function getFrequencyView() {
          return waterfall.getWaterfallRange().map(FFTOffsetToFrequency);
        }

        /* src/lib/PassbandTuner.svelte generated by Svelte v3.55.0 */

        function create_fragment$6(ctx) {
          var div4;
          var div3;
          var div1;
          var svg0;
          var line0;
          var line1;
          var t0;
          var div0;
          var t1;
          var svg1;
          var line2;
          var line3;
          var t2;
          var div2;
          var div4_resize_listener;
          var mounted;
          var dispose;
          return {
            c: function c() {
              div4 = element("div");
              div3 = element("div");
              div1 = element("div");
              svg0 = svg_element("svg");
              line0 = svg_element("line");
              line1 = svg_element("line");
              t0 = space();
              div0 = element("div");
              t1 = space();
              svg1 = svg_element("svg");
              line2 = svg_element("line");
              line3 = svg_element("line");
              t2 = space();
              div2 = element("div");
              attr(line0, "x1", "100%");
              attr(line0, "y1", "20%");
              attr(line0, "x2", "20%");
              attr(line0, "y2", "100%");
              attr(line0, "class", "stroke-current text-yellow-500 stroke-1 group-hover:stroke-2");
              attr(line1, "x1", "0%");
              attr(line1, "y1", "100%");
              attr(line1, "x2", "20%");
              attr(line1, "y2", "100%");
              attr(line1, "class", "stroke-current text-yellow-500 stroke-1 group-hover:stroke-2");
              attr(svg0, "class", "h-5 w-2 inline absolute group cursor-w-resize z-0");
              set_style(svg0, "right", "100%");
              attr(div0, "class", "w-full h-px bg-yellow-500 align-middle absolute z-10");
              set_style(div0, "top", "20%");
              attr(line2, "x1", "0%");
              attr(line2, "y1", "20%");
              attr(line2, "x2", "80%");
              attr(line2, "y2", "100%");
              attr(line2, "class", "stroke-current text-yellow-500 stroke-1 group-hover:stroke-2");
              attr(line3, "x1", "80%");
              attr(line3, "y1", "100%");
              attr(line3, "x2", "100%");
              attr(line3, "y2", "100%");
              attr(line3, "class", "stroke-current text-yellow-500 stroke-1 group-hover:stroke-2");
              attr(svg1, "class", "h-5 w-2 inline absolute group cursor-e-resize z-0");
              set_style(svg1, "left", "100%");
              attr(div1, "class", "h-full absolute cursor-ew-resize z-10");
              attr(div1, "style", /*cssPassband*/ctx[3]);
              attr(div2, "class", "h-full w-1 bg-transparent mx-auto cursor-ew-resize z-10");
              attr(div3, "class", "h-full w-px bg-yellow-500");
              attr(div3, "style", /*cssPassbandOffset*/ctx[2]);
              attr(div4, "class", "w-full h-5 bg-black");
              add_render_callback(function () {
                return (/*div4_elementresize_handler*/ctx[21].call(div4)
                );
              });
            },
            m: function m(target, anchor) {
              insert(target, div4, anchor);
              append(div4, div3);
              append(div3, div1);
              append(div1, svg0);
              append(svg0, line0);
              append(svg0, line1);
              append(div1, t0);
              append(div1, div0);
              append(div1, t1);
              append(div1, svg1);
              append(svg1, line2);
              append(svg1, line3);
              append(div3, t2);
              append(div3, div2);
              /*div4_binding*/
              ctx[20](div4);
              div4_resize_listener = add_resize_listener(div4, /*div4_elementresize_handler*/ctx[21].bind(div4));
              if (!mounted) {
                dispose = [listen(window, "mouseup", /*handleMoveEnd*/ctx[6]), listen(window, "mousemove", /*handleMove*/ctx[5]), listen(svg0, "mousedown", /*mousedown_handler*/ctx[16]), listen(svg1, "mousedown", /*mousedown_handler_1*/ctx[17]), listen(div1, "mousedown", self$1( /*mousedown_handler_2*/ctx[18])), listen(div2, "mousedown", self$1( /*mousedown_handler_3*/ctx[19])), listen(div4, "wheel", /*wheel_handler*/ctx[15]), listen(div4, "mousedown", self$1( /*mousedown_handler_4*/ctx[22]))];
                mounted = true;
              }
            },
            p: function p(ctx, _ref50) {
              var _ref51 = _slicedToArray(_ref50, 1),
                dirty = _ref51[0];
              if (dirty & /*cssPassband*/8) {
                attr(div1, "style", /*cssPassband*/ctx[3]);
              }
              if (dirty & /*cssPassbandOffset*/4) {
                attr(div3, "style", /*cssPassbandOffset*/ctx[2]);
              }
            },
            i: noop,
            o: noop,
            d: function d(detaching) {
              if (detaching) detach(div4);
              /*div4_binding*/
              ctx[20](null);
              div4_resize_listener();
              mounted = false;
              run_all(dispose);
            }
          };
        }
        var NoDrag = 0;
        var All = 1;
        var Left = 2;
        var Right = 3;
        var Click = 4;
        function instance$6($$self, $$props, $$invalidate) {
          var dispatch = createEventDispatcher();
          var draggingState = NoDrag;
          var draggingOffset;
          var draggingTotal;
          var passbandWidth;
          var passbandParent;
          var passbandOffset = -1000;
          var passbandLeftOffset;
          var passbandRightOffset;
          var maximumSideband;
          var maximumSidebandOffset;
          var cssPassbandOffset;
          var cssPassband;
          function handleMoveStart(e, state) {
            draggingState = state;
            draggingTotal = 0;
            if (draggingState === All) {
              draggingOffset = e.clientX - passbandOffset * passbandWidth;
            } else if (draggingState === Left) {
              draggingOffset = e.clientX - (passbandOffset + passbandLeftOffset) * passbandWidth;
            } else if (draggingState === Right) {
              draggingOffset = e.clientX - (passbandOffset + passbandRightOffset) * passbandWidth;
            }
          }
          function handleMove(e) {
            if (draggingState === Click) {
              draggingTotal += e.movementX;
            } else if (draggingState !== NoDrag) {
              var zero = passbandParent.getBoundingClientRect().x;
              var offsetX = e.clientX - zero - draggingOffset;
              if (draggingState === All) {
                $$invalidate(11, passbandOffset = Math.min(Math.max(-passbandLeftOffset * passbandWidth, offsetX), passbandWidth - passbandRightOffset * passbandWidth) / passbandWidth);
              } else if (draggingState === Left) {
                $$invalidate(12, passbandLeftOffset = Math.min(Math.max(-maximumSidebandOffset, offsetX - passbandOffset * passbandWidth), passbandRightOffset * passbandWidth) / passbandWidth);
              } else if (draggingState === Right) {
                $$invalidate(13, passbandRightOffset = Math.min(Math.max(passbandLeftOffset * passbandWidth, offsetX - passbandOffset * passbandWidth), maximumSidebandOffset) / passbandWidth);
              }
              dispatchPassbandChange();
            }
          }
          function handleMoveEnd(e) {
            if (draggingState === Click && draggingTotal < 5) {
              handlePassbandClick(e);
            }
            draggingState = NoDrag;
            $$invalidate(11, passbandOffset);
          }
          function handlePassbandClick(e) {
            var zero = passbandParent.getBoundingClientRect().x;
            var offsetX = e.clientX - zero;
            $$invalidate(11, passbandOffset = offsetX / passbandWidth);
            dispatchPassbandChange();
          }
          function getOffsetFromEvent(e) {
            var zero = passbandParent.getBoundingClientRect().x;
            var offsetX = e.clientX - zero;
            return offsetX / passbandWidth;
          }
          var dispatchTime = 0;
          function dispatchPassbandChange() {
            var message = [passbandOffset + passbandLeftOffset, passbandOffset, passbandOffset + passbandRightOffset];
            var currentTime = Date.now();
            if (currentTime - dispatchTime > 50) {
              dispatch('change', message);
              dispatchTime = currentTime;
            }
          }
          function changePassband(offsets) {
            var _offsets = _slicedToArray(offsets, 3),
              l = _offsets[0],
              m = _offsets[1],
              r = _offsets[2];
            $$invalidate(11, passbandOffset = m);
            $$invalidate(12, passbandLeftOffset = l - m);
            $$invalidate(13, passbandRightOffset = r - m);
          }
          function updatePassbandLimits() {
            $$invalidate(14, maximumSideband = bandwidthToWaterfallOffset(getMaximumBandwidth()));
          }
          onMount(function () {});
          function wheel_handler(event) {
            bubble.call(this, $$self, event);
          }
          var mousedown_handler = function mousedown_handler(e) {
            return handleMoveStart(e, Left);
          };
          var mousedown_handler_1 = function mousedown_handler_1(e) {
            return handleMoveStart(e, Right);
          };
          var mousedown_handler_2 = function mousedown_handler_2(e) {
            return handleMoveStart(e, All);
          };
          var mousedown_handler_3 = function mousedown_handler_3(e) {
            return handleMoveStart(e, All);
          };
          function div4_binding($$value) {
            binding_callbacks[$$value ? 'unshift' : 'push'](function () {
              passbandParent = $$value;
              $$invalidate(1, passbandParent);
            });
          }
          function div4_elementresize_handler() {
            passbandWidth = this.clientWidth;
            $$invalidate(0, passbandWidth);
          }
          var mousedown_handler_4 = function mousedown_handler_4(e) {
            return handleMoveStart(e, Click);
          };
          $$self.$$.update = function () {
            if ($$self.$$.dirty & /*maximumSideband, passbandWidth*/16385) {
              maximumSidebandOffset = Math.floor(maximumSideband * passbandWidth) / 2;
            }
            if ($$self.$$.dirty & /*passbandOffset, passbandWidth*/2049) {
              $$invalidate(2, cssPassbandOffset = "transform: translate3d(".concat(passbandOffset * passbandWidth - 0.5, "px, 0, 0)"));
            }
            if ($$self.$$.dirty & /*passbandLeftOffset, passbandWidth, passbandRightOffset*/12289) {
              $$invalidate(3, cssPassband = "transform: translate3d(".concat(passbandLeftOffset * passbandWidth + 0.5, "px, 0, 0); width: ").concat((passbandRightOffset - passbandLeftOffset) * passbandWidth, "px"));
            }
          };
          return [passbandWidth, passbandParent, cssPassbandOffset, cssPassband, handleMoveStart, handleMove, handleMoveEnd, handlePassbandClick, getOffsetFromEvent, changePassband, updatePassbandLimits, passbandOffset, passbandLeftOffset, passbandRightOffset, maximumSideband, wheel_handler, mousedown_handler, mousedown_handler_1, mousedown_handler_2, mousedown_handler_3, div4_binding, div4_elementresize_handler, mousedown_handler_4];
        }
        var PassbandTuner = /*#__PURE__*/function (_SvelteComponent3) {
          _inherits(PassbandTuner, _SvelteComponent3);
          var _super11 = _createSuper(PassbandTuner);
          function PassbandTuner(options) {
            var _this33;
            _classCallCheck(this, PassbandTuner);
            _this33 = _super11.call(this);
            init$1(_assertThisInitialized2(_this33), options, instance$6, create_fragment$6, safe_not_equal, {
              handlePassbandClick: 7,
              getOffsetFromEvent: 8,
              changePassband: 9,
              updatePassbandLimits: 10
            });
            return _this33;
          }
          _createClass(PassbandTuner, [{
            key: "handlePassbandClick",
            get: function get() {
              return this.$$.ctx[7];
            }
          }, {
            key: "getOffsetFromEvent",
            get: function get() {
              return this.$$.ctx[8];
            }
          }, {
            key: "changePassband",
            get: function get() {
              return this.$$.ctx[9];
            }
          }, {
            key: "updatePassbandLimits",
            get: function get() {
              return this.$$.ctx[10];
            }
          }]);
          return PassbandTuner;
        }(SvelteComponent);
        /*!
         * is-number <https://github.com/jonschlinkert/is-number>
         *
         * Copyright (c) 2014-present, Jon Schlinkert.
         * Released under the MIT License.
         */
        var isNumber$1 = function isNumber$1(num) {
          if (typeof num === 'number') {
            return num - num === 0;
          }
          if (typeof num === 'string' && num.trim() !== '') {
            return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
          }
          return false;
        };
        var FrequencyInput_svelte_svelte_type_style_lang = '';

        /* src/lib/FrequencyInput.svelte generated by Svelte v3.55.0 */

        function create_fragment$5(ctx) {
          var div;
          var input;
          var t0;
          var span;
          var mounted;
          var dispose;
          return {
            c: function c() {
              div = element("div");
              input = element("input");
              t0 = space();
              span = element("span");
              span.textContent = "".concat(frequencyUnit);
              attr(input, "type", "number");
              attr(input, "class", "text-2xl font-mono text-white bg-transparent text-center appearance-none svelte-1n8n5wk");
              attr(span, "class", "text-white m-2 text-2xl");
              attr(div, "class", "w-full md-2 items-center bg-black");
            },
            m: function m(target, anchor) {
              insert(target, div, anchor);
              append(div, input);
              set_input_value(input, /*frequencyDisplay*/ctx[0]);
              append(div, t0);
              append(div, span);
              if (!mounted) {
                dispose = [listen(input, "input", /*input_input_handler*/ctx[6]), listen(input, "change", /*handleFrequencyChange*/ctx[1])];
                mounted = true;
              }
            },
            p: function p(ctx, _ref52) {
              var _ref53 = _slicedToArray(_ref52, 1),
                dirty = _ref53[0];
              if (dirty & /*frequencyDisplay*/1 && to_number(input.value) !== /*frequencyDisplay*/ctx[0]) {
                set_input_value(input, /*frequencyDisplay*/ctx[0]);
              }
            },
            i: noop,
            o: noop,
            d: function d(detaching) {
              if (detaching) detach(div);
              mounted = false;
              run_all(dispose);
            }
          };
        }
        var frequencyUnit = 'MHz';
        function instance$5($$self, $$props, $$invalidate) {
          var dispatch = createEventDispatcher();
          var frequency = 0;
          var frequencyDecimals;
          var frequencyDisplay;
          var frequencyUnitMappings = {
            Hz: 0,
            kHz: 3,
            MHz: 6,
            GHz: 9
          };
          function handleFrequencyChange(e) {
            if (!isNumber$1(frequencyDisplay)) {
              updateDisplay();
              return;
            }
            var enteredFrequency = parseFloat(frequencyDisplay);
            enteredFrequency *= Math.pow(10, frequencyDecimals);
            if (checkFrequency(enteredFrequency)) {
              $$invalidate(5, frequency = enteredFrequency);
              dispatch('change', enteredFrequency);
            }
            updateDisplay();
          }
          function updateDisplay(f) {
            $$invalidate(0, frequencyDisplay = (frequency / Math.pow(10, frequencyDecimals)).toFixed(frequencyDecimals));
          }
          function checkFrequency(f) {
            var lo = audio.baseFreq;
            var hi = lo + audio.totalBandwidth;
            return f >= lo && f < hi;
          }
          function setFrequency(f) {
            if (checkFrequency(f)) {
              $$invalidate(5, frequency = f);
            }
          }
          function getFrequency() {
            return frequency;
          }
          function updateFrequencyLimits(lo, hi) {}
          updateDisplay();
          function input_input_handler() {
            frequencyDisplay = to_number(this.value);
            $$invalidate(0, frequencyDisplay);
          }
          $$self.$$.update = function () {
            if ($$self.$$.dirty & /*frequency*/32) {
              updateDisplay();
            }
          };
          frequencyDecimals = frequencyUnitMappings[frequencyUnit];
          return [frequencyDisplay, handleFrequencyChange, setFrequency, getFrequency, updateFrequencyLimits, frequency, input_input_handler];
        }
        var FrequencyInput = /*#__PURE__*/function (_SvelteComponent4) {
          _inherits(FrequencyInput, _SvelteComponent4);
          var _super12 = _createSuper(FrequencyInput);
          function FrequencyInput(options) {
            var _this34;
            _classCallCheck(this, FrequencyInput);
            _this34 = _super12.call(this);
            init$1(_assertThisInitialized2(_this34), options, instance$5, create_fragment$5, safe_not_equal, {
              setFrequency: 2,
              getFrequency: 3,
              updateFrequencyLimits: 4
            });
            return _this34;
          }
          _createClass(FrequencyInput, [{
            key: "setFrequency",
            get: function get() {
              return this.$$.ctx[2];
            }
          }, {
            key: "getFrequency",
            get: function get() {
              return this.$$.ctx[3];
            }
          }, {
            key: "updateFrequencyLimits",
            get: function get() {
              return this.$$.ctx[4];
            }
          }]);
          return FrequencyInput;
        }(SvelteComponent); // (a, y, c, l, h) = (array, y[, cmp, lo, hi])
        function _ge(a, y, c, l, h) {
          var i = h + 1;
          while (l <= h) {
            var m = l + h >>> 1,
              x = a[m];
            var p = c !== undefined ? c(x, y) : x - y;
            if (p >= 0) {
              i = m;
              h = m - 1;
            } else {
              l = m + 1;
            }
          }
          return i;
        }
        function _gt(a, y, c, l, h) {
          var i = h + 1;
          while (l <= h) {
            var m = l + h >>> 1,
              x = a[m];
            var p = c !== undefined ? c(x, y) : x - y;
            if (p > 0) {
              i = m;
              h = m - 1;
            } else {
              l = m + 1;
            }
          }
          return i;
        }
        function _lt(a, y, c, l, h) {
          var i = l - 1;
          while (l <= h) {
            var m = l + h >>> 1,
              x = a[m];
            var p = c !== undefined ? c(x, y) : x - y;
            if (p < 0) {
              i = m;
              l = m + 1;
            } else {
              h = m - 1;
            }
          }
          return i;
        }
        function _le(a, y, c, l, h) {
          var i = l - 1;
          while (l <= h) {
            var m = l + h >>> 1,
              x = a[m];
            var p = c !== undefined ? c(x, y) : x - y;
            if (p <= 0) {
              i = m;
              l = m + 1;
            } else {
              h = m - 1;
            }
          }
          return i;
        }
        function _eq(a, y, c, l, h) {
          while (l <= h) {
            var m = l + h >>> 1,
              x = a[m];
            var p = c !== undefined ? c(x, y) : x - y;
            if (p === 0) {
              return m;
            }
            if (p <= 0) {
              l = m + 1;
            } else {
              h = m - 1;
            }
          }
          return -1;
        }
        function norm(a, y, c, l, h, f) {
          if (typeof c === 'function') {
            return f(a, y, c, l === undefined ? 0 : l | 0, h === undefined ? a.length - 1 : h | 0);
          }
          return f(a, y, undefined, c === undefined ? 0 : c | 0, l === undefined ? a.length - 1 : l | 0);
        }
        var searchBounds = {
          ge: function ge(a, y, c, l, h) {
            return norm(a, y, c, l, h, _ge);
          },
          gt: function gt(a, y, c, l, h) {
            return norm(a, y, c, l, h, _gt);
          },
          lt: function lt(a, y, c, l, h) {
            return norm(a, y, c, l, h, _lt);
          },
          le: function le(a, y, c, l, h) {
            return norm(a, y, c, l, h, _le);
          },
          eq: function eq(a, y, c, l, h) {
            return norm(a, y, c, l, h, _eq);
          }
        };
        var builtinShortwave = [{
          f: 2485000,
          d: "Vanuatu Broadcasting and Television Corporation",
          m: "AM"
        }, {
          f: 3185000,
          d: "Blue Ridge Communications, Inc.",
          m: "AM"
        }, {
          f: 3195000,
          d: "Blue Ridge Communications, Inc.\nWNQM, Inc.",
          m: "AM"
        }, {
          f: 3215000,
          d: "Blue Ridge Communications, Inc.\nWNQM, Inc.",
          m: "AM"
        }, {
          f: 3265000,
          d: "Allan H. Weiner",
          m: "AM"
        }, {
          f: 3325000,
          d: "Radio Republic of Indonesia",
          m: "AM"
        }, {
          f: 3900000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 3915000,
          d: "BBC Worldservice",
          m: "AM"
        }, {
          f: 3930000,
          d: "The Overcomer Ministry",
          m: "AM"
        }, {
          f: 3945000,
          d: "Vanuatu Broadcasting and Television Corporation",
          m: "AM"
        }, {
          f: 3950000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 3955000,
          d: "BBC Worldservice\nChannel 292 (Germany)\nKorean Broadcasting System",
          m: "AM"
        }, {
          f: 3960000,
          d: "BBC Worldservice",
          m: "AM"
        }, {
          f: 3965000,
          d: "TDF (France)",
          m: "AM"
        }, {
          f: 3975000,
          d: "Shortwave Radio Services (Germany)",
          m: "AM"
        }, {
          f: 3985000,
          d: "China National Radio\nRadio 700",
          m: "AM"
        }, {
          f: 3990000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 3995000,
          d: "Media Broadcast GmbH\nVoice of the Andes",
          m: "AM"
        }, {
          f: 4500000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 4750000,
          d: "China National Radio\nRadio Republic of Indonesia",
          m: "AM"
        }, {
          f: 4760000,
          d: "All India Radio\nTrans World Radio",
          m: "AM"
        }, {
          f: 4800000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 4820000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 4830000,
          d: "Mongol Radio & Television",
          m: "AM"
        }, {
          f: 4835000,
          d: "All India Radio",
          m: "AM"
        }, {
          f: 4840000,
          d: "WNQM, Inc.",
          m: "AM"
        }, {
          f: 4850000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 4870000,
          d: "All India Radio",
          m: "AM"
        }, {
          f: 4895000,
          d: "Mongol Radio & Television",
          m: "AM"
        }, {
          f: 4905000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 4920000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 4930000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 4950000,
          d: "All India Radio",
          m: "AM"
        }, {
          f: 4960000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 4965000,
          d: "Voice of Hope",
          m: "AM"
        }, {
          f: 4980000,
          d: "China National Radio\nRadio Miami International",
          m: "AM"
        }, {
          f: 4990000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 5010000,
          d: "Radio Miami International",
          m: "AM"
        }, {
          f: 5020000,
          d: "Solomon Islands Broadcasting",
          m: "AM"
        }, {
          f: 5040000,
          d: "All India Radio\nVanuatu Broadcasting and Television Corporation",
          m: "AM"
        }, {
          f: 5050000,
          d: "All India Radio\nBlue Ridge Communications, Inc.\nChina National Radio",
          m: "AM"
        }, {
          f: 5060000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 5085000,
          d: "Leap of Faith, Inc.",
          m: "AM"
        }, {
          f: 5130000,
          d: "Allan H. Weiner",
          m: "AM"
        }, {
          f: 5800000,
          d: "Radio Miami International",
          m: "AM"
        }, {
          f: 5820000,
          d: "Encompass Digital Media Services\nFor new organization",
          m: "AM"
        }, {
          f: 5830000,
          d: "Leap of Faith, Inc.",
          m: "AM"
        }, {
          f: 5835000,
          d: "Pakistan Broadcasting Corporation",
          m: "AM"
        }, {
          f: 5845000,
          d: "BBC Worldservice",
          m: "AM"
        }, {
          f: 5850000,
          d: "Radio Miami International",
          m: "AM"
        }, {
          f: 5860000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 5875000,
          d: "BBC Worldservice\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 5880000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 5885000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 5890000,
          d: "BBC Worldservice\nPakistan Broadcasting Corporation\nUnited States Agency for Global Media (USAGM)\nWNQM, Inc.",
          m: "AM"
        }, {
          f: 5895000,
          d: "BBC Worldservice\nFor new organization\nIBRA Radio\nNippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 5900000,
          d: "For new organization",
          m: "AM"
        }, {
          f: 5905000,
          d: "China Radio International\nDeutscher Wetterdienst",
          m: "AM"
        }, {
          f: 5910000,
          d: "China Radio International\nHFCC, Intl. Radio for Disaster Relief project\nRadio Romania International",
          m: "AM"
        }, {
          f: 5915000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 5920000,
          d: "Korean Broadcasting System\nLeSea Broadcasting Corporation\nRadio Romania International\nVoice of Russia\nVoice of the Andes",
          m: "AM"
        }, {
          f: 5925000,
          d: "China National Radio\nDeutsche Welle\nIslamic Republic of Iran Broadcasting\nRadio France Internationale\nRadio Romania International\nUnited States Agency for Global Media (USAGM)\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 5930000,
          d: "BBC Worldservice\nIslamic Republic of Iran Broadcasting\nJapan International Communications\nMedia Broadcast GmbH\nRadio Romania International\nWorld Music Radio",
          m: "AM"
        }, {
          f: 5935000,
          d: "BBC Worldservice\nChina National Radio\nIslamic Republic of Iran Broadcasting\nJapan International Communications\nMedia Broadcast GmbH\nVoice of Russia\nWNQM, Inc.",
          m: "AM"
        }, {
          f: 5940000,
          d: "IBRA Radio\nIslamic Republic of Iran Broadcasting\nRadio Romania International\nTelediffusion d'Algerie",
          m: "AM"
        }, {
          f: 5945000,
          d: "BBC Worldservice\nChina National Radio\nEncompass Digital Media Services\nMedia Broadcast GmbH\nTurkish Radio-TV Corp\nVoice of Russia",
          m: "AM"
        }, {
          f: 5950000,
          d: "Korean Broadcasting System\nMedia Broadcast GmbH\nRadio Miami International\nVoice of Russia",
          m: "AM"
        }, {
          f: 5955000,
          d: "Abu Dhabi Media Company\nBroccoli Trash Metal & Grunge, Netherlands\nChina Radio International\nJapan International Communications\nRadio Romania International",
          m: "AM"
        }, {
          f: 5960000,
          d: "BBC Worldservice\nChina National Radio\nChina Radio International\nMedia Broadcast GmbH\nMinistry of Information - State of Kuwait\nRadio France Internationale\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 5965000,
          d: "China National Radio\nChina Radio International\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 5970000,
          d: "China National Radio\nChina Radio International\nEternal Word Television Network, Inc.\nIslamic Republic of Iran Broadcasting\nRadio208\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 5975000,
          d: "BBC Worldservice\nChina National Radio\nChina Radio International\nKorean Broadcasting System\nRadio New Zealand\nRadio Republic of Indonesia\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 5980000,
          d: "BBC Worldservice\nChina Radio International\nMedia Broadcast GmbH\nRadio OZ-Viola\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)\nVatican Radio",
          m: "AM"
        }, {
          f: 5985000,
          d: "Abu Dhabi Media Company\nChina National Radio\nChina Radio International\nJapan International Communications\nNippon Hoso Kyokai\nRadio Miami International\nRadio Republic of Indonesia\nTelediffusion d'Algerie\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 5990000,
          d: "China National Radio\nChina Radio International\nJapan International Communications\nMedia Broadcast GmbH\nRadio Republic of Indonesia\nRadio Romania International\nStudio Denakker",
          m: "AM"
        }, {
          f: 5995000,
          d: "China National Radio\nMedia Broadcast GmbH\nTelediffusion d'Algerie",
          m: "AM"
        }, {
          f: 6000000,
          d: "All India Radio\nChina National Radio\nFor new organization\nIslamic Republic of Iran Broadcasting\nJapan International Communications\nNippon Hoso Kyokai\nTurkish Radio-TV Corp\nVoice of Russia",
          m: "AM"
        }, {
          f: 6005000,
          d: "BBC Worldservice\nFor new organization\nRadio 700\nRadio Delta International\nTelediffusion d'Algerie",
          m: "AM"
        }, {
          f: 6010000,
          d: "BBC Worldservice\nChina National Radio\nChina Radio International\nFor new organization\nVatican Radio",
          m: "AM"
        }, {
          f: 6015000,
          d: "China National Radio\nKorean Broadcasting System\nThe Overcomer Ministry\nVoice of Russia",
          m: "AM"
        }, {
          f: 6020000,
          d: "China Radio International\nJapan International Communications\nKorean Broadcasting System\nRadio Delta International\nRadio Romania International\nUnited States Agency for Global Media (USAGM)\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 6025000,
          d: "China National Radio\nChina Radio International\nRadio Republic of Indonesia\nRadio Romania International\nVoice of Russia",
          m: "AM"
        }, {
          f: 6030000,
          d: "All India Radio\nChina National Radio\nMedia Broadcast GmbH\nRadio Romania International\nRadio SWS (Germany)\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 6035000,
          d: "China National Radio\nFar East Broadcasting Company",
          m: "AM"
        }, {
          f: 6040000,
          d: "China National Radio\nChina Radio International\nIslamic Republic of Iran Broadcasting\nKorean Broadcasting System\nRadio France Internationale\nRadio Romania International\nTelediffusion d'Algerie\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 6045000,
          d: "Encompass Digital Media Services\nJapan International Communications\nMedia Broadcast GmbH\nRadio 700",
          m: "AM"
        }, {
          f: 6050000,
          d: "China National Radio\nMinistry of Information - State of Kuwait\nRadio Television Malaysia\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 6055000,
          d: "Adventist World Radio\nChina Radio International\nKorean Broadcasting System\nMedia Broadcast GmbH\nNihon Short-wave Broadc. Co.\nRadio OZ-Viola",
          m: "AM"
        }, {
          f: 6060000,
          d: "China National Radio\nChina Radio International\nFor new organization\nIslamic Republic of Iran Broadcasting\nMedia Broadcast GmbH\nTelediffusion d'Algerie\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 6065000,
          d: "Adventist World Radio\nChina National Radio\nChina Radio International\nKorean Broadcasting System\nVoice of Hope",
          m: "AM"
        }, {
          f: 6070000,
          d: "Abu Dhabi Media Company\nChannel 292 (Germany)\nChina Radio International\nIslamic Republic of Iran Broadcasting\nJapan International Communications\nMedia Broadcast GmbH\nOesterreichischer Rundfunk\nRadio Republic of Indonesia\nTurkish Radio-TV Corp\nVoice of Russia",
          m: "AM"
        }, {
          f: 6075000,
          d: "China National Radio\nChina Radio International\nIslamic Republic of Iran Broadcasting\nJapan International Communications\nWorld Christian Broadcasting Corporation",
          m: "AM"
        }, {
          f: 6080000,
          d: "China National Radio\nChina Radio International\nMedia Broadcast GmbH\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 6085000,
          d: "All India Radio\nJapan International Communications\nRadio 700",
          m: "AM"
        }, {
          f: 6090000,
          d: "Abu Dhabi Media Company\nBBC Worldservice\nChina National Radio\nChina Radio International\nKorean Broadcasting System\nNippon Hoso Kyokai\nPlummer Applications\nVoice of Russia",
          m: "AM"
        }, {
          f: 6095000,
          d: "BBC Worldservice\nChina Radio International\nJapan International Communications\nKorean Broadcasting System\nMedia Broadcast GmbH\nTelediffusion d'Algerie",
          m: "AM"
        }, {
          f: 6100000,
          d: "All India Radio\nChina Radio International\nKorean Broadcasting System\nRadio Television Malaysia\nTrans World Radio\nVoice of Russia",
          m: "AM"
        }, {
          f: 6105000,
          d: "China National Radio\nChina Radio International\nNippon Hoso Kyokai\nTelediffusion d'Algerie",
          m: "AM"
        }, {
          f: 6110000,
          d: "All India Radio\nChina National Radio\nChina Radio International\nIslamic Republic of Iran Broadcasting\nJapan International Communications\nVoice of Russia\nWorld Christian Broadcasting Corporation",
          m: "AM"
        }, {
          f: 6115000,
          d: "China Radio International\nJapan International Communications\nNihon Short-wave Broadc. Co.\nRadio New Zealand\nSE-TA 2 (Germany)\nWNQM, Inc.",
          m: "AM"
        }, {
          f: 6120000,
          d: "Adventist World Radio\nChina National Radio\nMedia Broadcast GmbH\nTurkish Radio-TV Corp\nVoice of Russia",
          m: "AM"
        }, {
          f: 6125000,
          d: "China National Radio\nRadio Europe Netherlands\nRadio Republic of Indonesia\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 6130000,
          d: "Adventist World Radio\nChina National Radio\nJapan International Communications",
          m: "AM"
        }, {
          f: 6135000,
          d: "BBC Worldservice\nChina Radio International\nJapan International Communications\nKorean Broadcasting System\nRadio Republic of Indonesia",
          m: "AM"
        }, {
          f: 6140000,
          d: "BBC Worldservice\nChina Radio International\nMedia Broadcast GmbH\nRadio Onda ASBL\nTelediffusion d'Algerie\nVatican Radio",
          m: "AM"
        }, {
          f: 6145000,
          d: "Abu Dhabi Media Company\nChina National Radio\nChina Radio International\nJapan International Communications\nMedia Broadcast GmbH\nRadio Romania International\nTelediffusion d'Algerie\nVoice of Russia",
          m: "AM"
        }, {
          f: 6150000,
          d: "Abu Dhabi Media Company\nBBC Worldservice\nChina Radio International\nEuropa 24 (Germany)\nIslamic Republic of Iran Broadcasting\nKorean Broadcasting System\nRadio Romania International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 6155000,
          d: "Abu Dhabi Media Company\nChina National Radio\nChina Radio International\nEncompass Digital Media Services\nFor new organization\nKorean Broadcasting System\nMedia Broadcast GmbH\nNippon Hoso Kyokai\nOesterreichischer Rundfunk",
          m: "AM"
        }, {
          f: 6160000,
          d: "Allan H. Weiner\nChina Radio International\nShortwave Radio Services (Germany)",
          m: "AM"
        }, {
          f: 6165000,
          d: "China National Radio\nChina Radio International\nJapan International Communications\nNippon Hoso Kyokai\nTrans World Radio\nVoice of Russia\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 6170000,
          d: "Far East Broadcasting Company\nKorean Broadcasting System\nRadio Romania International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 6175000,
          d: "China National Radio\nChina Radio International\nJapan International Communications\nRadio Romania International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 6180000,
          d: "Abu Dhabi Media Company\nChina National Radio\nChina Radio International\nDeutscher Wetterdienst\nEncompass Digital Media Services\nJapan International Communications\nKoode Radio International\nRadio Romania International\nWorld Christian Broadcasting (USA)",
          m: "AM"
        }, {
          f: 6185000,
          d: "Adventist World Radio\nChina Radio International\nRadio Piepzender\nRadio Republic of Indonesia\nVatican Radio",
          m: "AM"
        }, {
          f: 6190000,
          d: "China National Radio\nChina Radio International\nNippon Hoso Kyokai\nRadio Republic of Indonesia",
          m: "AM"
        }, {
          f: 6195000,
          d: "BBC Worldservice\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 6200000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 6240000,
          d: "For new organization",
          m: "AM"
        }, {
          f: 7205000,
          d: "China National Radio\nChina Radio International\nRadio France Internationale\nRadio Republic of Indonesia",
          m: "AM"
        }, {
          f: 7210000,
          d: "China National Radio\nChina Radio International\nVoice of Russia\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 7215000,
          d: "China National Radio\nChina Radio International\nFor new organization\nKorean Broadcasting System",
          m: "AM"
        }, {
          f: 7220000,
          d: "China National Radio\nChina Radio International\nDeutsche Welle\nMedia Broadcast GmbH\nRadio Romania International\nRockpower\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 7225000,
          d: "Abu Dhabi Media Company\nAdventist World Radio\nChina National Radio\nChina Radio International\nFor new organization\nIslamic Republic of Iran Broadcasting\nJapan International Communications\nMedia Broadcast GmbH\nNippon Hoso Kyokai\nRadio Miami International\nVatican Radio",
          m: "AM"
        }, {
          f: 7230000,
          d: "China National Radio\nDeutsche Welle\nMedia Broadcast GmbH\nRadio Republic of Indonesia\nVatican Radio",
          m: "AM"
        }, {
          f: 7235000,
          d: "China Radio International\nDeutsche Welle\nKorean Broadcasting System\nRadio Republic of Indonesia\nRadio Romania International\nVatican Radio",
          m: "AM"
        }, {
          f: 7240000,
          d: "China National Radio\nChina Radio International\nJapan International Communications\nKorean Broadcasting System\nRadio Republic of Indonesia\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 7245000,
          d: "China National Radio\nChina Radio International\nFor new organization\nJapan International Communications\nNippon Hoso Kyokai\nRadio France Internationale\nRadio Russia\nTrans World Radio\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 7250000,
          d: "China Radio International\nJapan International Communications\nKorean Broadcasting System\nMinistry of Information - State of Kuwait\nTelediffusion d'Algerie\nVatican Radio",
          m: "AM"
        }, {
          f: 7255000,
          d: "China National Radio\nChina Radio International\nKorean Broadcasting System\nMedia Broadcast GmbH\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7260000,
          d: "China National Radio\nChina Radio International\nJapan International Communications\nMongol Radio & Television\nVanuatu Broadcasting and Television Corporation",
          m: "AM"
        }, {
          f: 7265000,
          d: "BBC Worldservice\nChina National Radio\nChina Radio International\nNippon Hoso Kyokai\nTDF (France)\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 7270000,
          d: "Adventist World Radio\nChina National Radio\nJapan International Communications\nRadio Republic of Indonesia",
          m: "AM"
        }, {
          f: 7275000,
          d: "China National Radio\nChina Radio International\nIslamic Republic of Iran Broadcasting\nKorean Broadcasting System\nRadio Republic of Indonesia\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7280000,
          d: "Japan International Communications\nTrans World Radio\nTurkish Radio-TV Corp\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 7285000,
          d: "BBC Worldservice\nChina Radio International\nJapan International Communications\nRadio New Zealand\nTurkish Radio-TV Corp\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 7290000,
          d: "ANTI, Milano\nAbu Dhabi Media Company\nChina National Radio\nChina Radio International\nEncompass Digital Media Services\nIslamic Republic of Iran Broadcasting\nRadio Romania International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7295000,
          d: "All India Radio\nBBC Worldservice\nChina National Radio\nChina Radio International\nEncompass Digital Media Services\nJapan International Communications\nMedia Broadcast GmbH\nRadio France Internationale\nRadio Republic of Indonesia\nRadio Television Malaysia\nTelediffusion d'Algerie\nVoice of Russia",
          m: "AM"
        }, {
          f: 7300000,
          d: "Adventist World Radio\nBBC Worldservice\nChina National Radio\nChina Radio International\nHCJB Australia\nIslamic Republic of Iran Broadcasting",
          m: "AM"
        }, {
          f: 7305000,
          d: "Abu Dhabi Media Company\nBBC Worldservice\nChina National Radio\nChina Radio International\nIslamic Republic of Iran Broadcasting\nJapan International Communications\nKorean Broadcasting System\nVatican Radio\nVoice of Russia",
          m: "AM"
        }, {
          f: 7310000,
          d: "China National Radio\nIslamic Republic of Iran Broadcasting\nJapan International Communications\nRadio 700\nRadio Romania International",
          m: "AM"
        }, {
          f: 7315000,
          d: "China National Radio\nChina Radio International\nEncompass Digital Media Services\nFree Press Unlimited (Amsterdam)\nLeSea Broadcasting Corporation\nMedia Broadcast GmbH\nTelediffusion d'Algerie\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 7320000,
          d: "China Radio International\nJapan International Communications\nRadio Romania International\nVatican Radio",
          m: "AM"
        }, {
          f: 7325000,
          d: "Adventist World Radio\nChina Radio International\nJapan International Communications\nMedia Broadcast GmbH\nRadio Romania International",
          m: "AM"
        }, {
          f: 7330000,
          d: "China Radio International\nJapan International Communications\nMedia Broadcast GmbH\nRadio New Zealand\nRadio Romania International",
          m: "AM"
        }, {
          f: 7335000,
          d: "BBC Worldservice\nChina National Radio\nChina Radio International\nJapan International Communications\nLeSea Broadcasting Corporation\nTelediffusion d'Algerie\nVoice of Russia",
          m: "AM"
        }, {
          f: 7340000,
          d: "China National Radio\nChina Radio International\nIslamic Republic of Iran Broadcasting\nJapan International Communications\nMedia Broadcast GmbH\nRadio Delta International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7345000,
          d: "China National Radio\nChina Radio International\nFor new organization\nJapan International Communications\nRadio Romania International\nVoice of Russia",
          m: "AM"
        }, {
          f: 7350000,
          d: "Adventist World Radio\nBroadcast Belgium\nChina National Radio\nChina Radio International\nMedia Broadcast GmbH\nRadio 700\nRadio Romania International",
          m: "AM"
        }, {
          f: 7355000,
          d: "BBC Worldservice\nChina Radio International\nIslamic Republic of Iran Broadcasting\nNippon Hoso Kyokai\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7360000,
          d: "Broadcast Belgium\nChina National Radio\nChina Radio International\nIslamic Republic of Iran Broadcasting\nRadio Romania International\nVatican Radio\nVoice of Russia",
          m: "AM"
        }, {
          f: 7365000,
          d: "China National Radio\nChina Radio International\nMedia Broadcast GmbH\nUnited States Agency for Global Media (USAGM)\nVatican Radio\nVoice of the Andes",
          m: "AM"
        }, {
          f: 7370000,
          d: "China National Radio\nChina Radio International\nJapan International Communications\nRadio Romania International\nWorld Christian Broadcasting Corporation",
          m: "AM"
        }, {
          f: 7375000,
          d: "China National Radio\nJapan International Communications\nMedia Broadcast GmbH\nRadio Romania International\nTelediffusion d'Algerie\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 7380000,
          d: "China Radio International\nIslamic Republic of Iran Broadcasting\nMedia Broadcast GmbH\nRadio France Internationale\nWorld International Broadcasters, Inc.",
          m: "AM"
        }, {
          f: 7385000,
          d: "China National Radio\nChina Radio International\nJapan International Communications\nLeSea Broadcasting Corporation\nVoice of Russia",
          m: "AM"
        }, {
          f: 7390000,
          d: "China Radio International\nRadio France Internationale\nRadio New Zealand\nWNQM, Inc.",
          m: "AM"
        }, {
          f: 7395000,
          d: "China Radio International\nWorld Christian Broadcasting Corporation",
          m: "AM"
        }, {
          f: 7400000,
          d: "HFCC, Intl. Radio for Disaster Relief project",
          m: "AM"
        }, {
          f: 7410000,
          d: "Adventist World Radio\nChina National Radio\nChina Radio International\nJapan International Communications\nMedia Broadcast GmbH\nRadio Romania International\nTrans World Radio\nVatican Radio",
          m: "AM"
        }, {
          f: 7415000,
          d: "China Radio International\nSPW Radio Warsaw - Transatlantic Radio Station Cultural Park Association (Poland)",
          m: "AM"
        }, {
          f: 7420000,
          d: "China National Radio\nChina Radio International\nRadio Romania International\nVatican Radio\nVoice of Russia",
          m: "AM"
        }, {
          f: 7425000,
          d: "BBC Worldservice\nChina National Radio\nChina Radio International\nEncompass Digital Media Services\nRadio Piepzender\nVoice of Russia",
          m: "AM"
        }, {
          f: 7430000,
          d: "China National Radio\nChina Radio International\nIslamic Republic of Iran Broadcasting\nSPW Radio Warsaw - Transatlantic Radio Station Cultural Park Association (Poland)\nVoice of Greece",
          m: "AM"
        }, {
          f: 7435000,
          d: "China Radio International\nJapan International Communications\nUnited States Agency for Global Media (USAGM)\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 7440000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 7445000,
          d: "BBC Worldservice\nChina Radio International\nKorean Broadcasting System\nNippon Hoso Kyokai\nRadio Piepzender\nVoice of Russia",
          m: "AM"
        }, {
          f: 7450000,
          d: "China National Radio\nNippon Hoso Kyokai\nVoice of Greece",
          m: "AM"
        }, {
          f: 7455000,
          d: "Broadcast Belgium\nMedia Broadcast GmbH\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7460000,
          d: "Pakistan Broadcasting Corporation\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7465000,
          d: "BBC Worldservice\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7470000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7475000,
          d: "NBS of Thailand\nPakistan Broadcasting Corporation\nUnited States Agency for Global Media (USAGM)\nVoice of Greece",
          m: "AM"
        }, {
          f: 7480000,
          d: "For new organization\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7485000,
          d: "BBC Worldservice\nVatican Radio",
          m: "AM"
        }, {
          f: 7490000,
          d: "Allan H. Weiner\nWNQM, Inc.",
          m: "AM"
        }, {
          f: 7495000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7500000,
          d: "Trans World Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7505000,
          d: "For new organization\nLeSea Broadcasting Corporation\nWRNO Worldwide, Inc.",
          m: "AM"
        }, {
          f: 7510000,
          d: "IBRA Radio\nTrans World Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7515000,
          d: "Broadcast Belgium\nTrans World Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7520000,
          d: "LeSea Broadcasting Corporation\nUnited States Agency for Global Media (USAGM)\nWNQM, Inc.",
          m: "AM"
        }, {
          f: 7525000,
          d: "Encompass Digital Media Services\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7530000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7535000,
          d: "For new organization",
          m: "AM"
        }, {
          f: 7540000,
          d: "Pakistan Broadcasting Corporation\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7545000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7550000,
          d: "BBC Worldservice\nEncompass Digital Media Services\nFor new organization",
          m: "AM"
        }, {
          f: 7555000,
          d: "For new organization",
          m: "AM"
        }, {
          f: 7560000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7565000,
          d: "Nippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 7570000,
          d: "Radio Miami International",
          m: "AM"
        }, {
          f: 7580000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7585000,
          d: "Encompass Digital Media Services\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 7590000,
          d: "For new organization\nTrans World Radio",
          m: "AM"
        }, {
          f: 7730000,
          d: "Radio Miami International",
          m: "AM"
        }, {
          f: 7780000,
          d: "Radio Miami International",
          m: "AM"
        }, {
          f: 9265000,
          d: "World International Broadcasters, Inc.",
          m: "AM"
        }, {
          f: 9275000,
          d: "Assemblies of Yahweh\nFar East Broadcasting Company",
          m: "AM"
        }, {
          f: 9300000,
          d: "For new organization",
          m: "AM"
        }, {
          f: 9305000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9315000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9325000,
          d: "For new organization",
          m: "AM"
        }, {
          f: 9330000,
          d: "Allan H. Weiner",
          m: "AM"
        }, {
          f: 9335000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9345000,
          d: "Far East Broadcasting Company",
          m: "AM"
        }, {
          f: 9350000,
          d: "WNQM, Inc.",
          m: "AM"
        }, {
          f: 9355000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9370000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9380000,
          d: "Trans World Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9385000,
          d: "Eternal Word Television Network, Inc.\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9390000,
          d: "Islamic Republic of Iran Broadcasting\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9395000,
          d: "Radio Miami International",
          m: "AM"
        }, {
          f: 9400000,
          d: "Far East Broadcasting Company\nFor new organization",
          m: "AM"
        }, {
          f: 9405000,
          d: "Far East Broadcasting Company",
          m: "AM"
        }, {
          f: 9410000,
          d: "Abu Dhabi Media Company\nBBC Worldservice\nChina National Radio\nChina Radio International\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9415000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 9420000,
          d: "China National Radio\nIslamic Republic of Iran Broadcasting\nVoice of Greece\nVoice of Russia",
          m: "AM"
        }, {
          f: 9430000,
          d: "HFCC, Intl. Radio for Disaster Relief project",
          m: "AM"
        }, {
          f: 9440000,
          d: "BBC Worldservice\nChina Radio International\nEgypt Radio & TV Union\nFar East Broadcasting Company\nMedia Broadcast GmbH\nVoice of Russia",
          m: "AM"
        }, {
          f: 9445000,
          d: "Nippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 9450000,
          d: "Adventist World Radio\nChina Radio International\nMedia Broadcast GmbH\nNippon Hoso Kyokai\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9455000,
          d: "China Radio International\nJapan International Communications\nRadio Miami International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9460000,
          d: "Adventist World Radio\nChina Radio International\nJapan International Communications\nVoice of Russia",
          m: "AM"
        }, {
          f: 9465000,
          d: "BBC Worldservice\nFor new organization\nMedia Broadcast GmbH\nWorld Christian Broadcasting Corporation",
          m: "AM"
        }, {
          f: 9470000,
          d: "Adventist Broadcasting Service, Inc.\nChina National Radio\nChina Radio International\nEternal Word Television Network, Inc.\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9475000,
          d: "Islamic Republic of Iran Broadcasting\nLeap of Faith, Inc.\nMedia Broadcast GmbH\nPhilippines Broadcasting Service",
          m: "AM"
        }, {
          f: 9480000,
          d: "Abu Dhabi Media Company\nChina National Radio\nFor new organization\nNippon Hoso Kyokai\nVoice of Russia",
          m: "AM"
        }, {
          f: 9485000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9490000,
          d: "Abu Dhabi Media Company\nChina National Radio\nChina Radio International\nFor new organization\nMedia Broadcast GmbH\nRadio Miami International\nRadio Romania International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9495000,
          d: "Adventist World Radio\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 9500000,
          d: "China National Radio\nTelediffusion d'Algerie\nTrans World Radio\nVoice of Russia\nVoice of the Andes",
          m: "AM"
        }, {
          f: 9505000,
          d: "LeSea Broadcasting Corporation\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 9510000,
          d: "ANTI, Milano\nAdventist World Radio\nBBC Worldservice\nChina National Radio\nEgypt Radio & TV Union\nIslamic Republic of Iran Broadcasting\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9515000,
          d: "Adventist World Radio\nChina National Radio\nChina Radio International\nKorean Broadcasting System",
          m: "AM"
        }, {
          f: 9520000,
          d: "China National Radio\nChina Radio International",
          m: "AM"
        }, {
          f: 9525000,
          d: "Broadcast Belgium\nChina Radio International\nKorean Broadcasting System\nRadio Republic of Indonesia",
          m: "AM"
        }, {
          f: 9530000,
          d: "China National Radio\nIslamic Republic of Iran Broadcasting\nRadio Onda ASBL\nTelediffusion d'Algerie",
          m: "AM"
        }, {
          f: 9535000,
          d: "China Radio International\nEncompass Digital Media Services\nWorld Christian Broadcasting Corporation",
          m: "AM"
        }, {
          f: 9540000,
          d: "BBC Worldservice\nChina Radio International\nFar East Broadcasting Company\nIBRA Radio\nMedia Broadcast GmbH\nPakistan Broadcasting Corporation\nVoice of Russia\nWorld Christian Broadcasting Corporation",
          m: "AM"
        }, {
          f: 9545000,
          d: "BBC Worldservice\nChina National Radio\nEgypt Radio & TV Union\nRadio Republic of Indonesia\nSolomon Islands Broadcasting",
          m: "AM"
        }, {
          f: 9550000,
          d: "Broadcast Belgium\nChina Radio International\nIslamic Republic of Iran Broadcasting\nMedia Broadcast GmbH\nRadio Republic of Indonesia\nUnited States Agency for Global Media (USAGM)\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 9555000,
          d: "Abu Dhabi Media Company\nChina National Radio\nChina Radio International\nDeutsche Welle",
          m: "AM"
        }, {
          f: 9560000,
          d: "BBC Worldservice\nChina National Radio\nChina Radio International\nEncompass Digital Media Services\nMedia Broadcast GmbH\nNippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 9565000,
          d: "China Radio International\nRadio Republic of Indonesia\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 9570000,
          d: "China National Radio\nChina Radio International\nDeutsche Welle\nKorean Broadcasting System\nMedia Broadcast GmbH\nWorld Christian Broadcasting Corporation",
          m: "AM"
        }, {
          f: 9575000,
          d: "Pakistan Broadcasting Corporation\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9580000,
          d: "BBC Worldservice\nChina National Radio\nKorean Broadcasting System\nNippon Hoso Kyokai\nVatican Radio\nWorld Christian Broadcasting Corporation",
          m: "AM"
        }, {
          f: 9585000,
          d: "Abu Dhabi Media Company\nBBC Worldservice\nChina Radio International\nTrans World Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9590000,
          d: "China Radio International\nMedia Broadcast GmbH\nVoice of Russia",
          m: "AM"
        }, {
          f: 9595000,
          d: "Nihon Short-wave Broadc. Co.\nTurkish Radio-TV Corp\nVatican Radio",
          m: "AM"
        }, {
          f: 9600000,
          d: "BBC Worldservice\nChina National Radio\nChina Radio International\nRadio Romania International",
          m: "AM"
        }, {
          f: 9605000,
          d: "LeSea Broadcasting Corporation\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9610000,
          d: "Adventist Broadcasting Service, Inc.\nAdventist World Radio\nChina National Radio\nChina Radio International\nMedia Broadcast GmbH\nRadio Republic of Indonesia\nRadio Romania International\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 9615000,
          d: "Abu Dhabi Media Company\nChina Radio International\nRadio Republic of Indonesia",
          m: "AM"
        }, {
          f: 9620000,
          d: "All India Radio\nChina National Radio\nChina Radio International\nIslamic Republic of Iran Broadcasting\nMedia Broadcast GmbH\nRadio Romania International\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9625000,
          d: "Nippon Hoso Kyokai\nTurkish Radio-TV Corp\nVoice of Russia\nWorld Christian Broadcasting Corporation",
          m: "AM"
        }, {
          f: 9630000,
          d: "Abu Dhabi Media Company\nAdventist World Radio\nChina National Radio\nChina Radio International\nKorean Broadcasting System",
          m: "AM"
        }, {
          f: 9635000,
          d: "Encompass Digital Media Services\nRadio France Internationale\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 9640000,
          d: "China Radio International\nKorean Broadcasting System\nVoice of Russia",
          m: "AM"
        }, {
          f: 9645000,
          d: "Adventist Broadcasting Service, Inc.\nChina National Radio\nChina Radio International\nKorean Broadcasting System\nVatican Radio",
          m: "AM"
        }, {
          f: 9650000,
          d: "Voice of Russia",
          m: "AM"
        }, {
          f: 9655000,
          d: "Abu Dhabi Media Company\nChina National Radio\nChina Radio International\nNippon Hoso Kyokai\nVoice of Russia",
          m: "AM"
        }, {
          f: 9660000,
          d: "China National Radio\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 9665000,
          d: "China National Radio\nChina Radio International\nRadio France Internationale\nTelediffusion d'Algerie\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9670000,
          d: "Channel 292 (Germany)\nNippon Hoso Kyokai\nPakistan Broadcasting Corporation\nRadio France Internationale\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9675000,
          d: "Broadcast Belgium\nChina National Radio\nChina Radio International\nMedia Broadcast GmbH",
          m: "AM"
        }, {
          f: 9680000,
          d: "China National Radio\nNippon Hoso Kyokai\nRadio France Internationale\nRadio Republic of Indonesia\nVoice of Hope\nWorld Christian Broadcasting Corporation",
          m: "AM"
        }, {
          f: 9685000,
          d: "Abu Dhabi Media Company\nChina National Radio\nChina Radio International",
          m: "AM"
        }, {
          f: 9690000,
          d: "China Radio International\nEncompass Digital Media Services\nJapan International Communications\nKorean Broadcasting System\nRadio Exterior de Espana\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9695000,
          d: "China Radio International\nJapan International Communications\nMedia Broadcast GmbH",
          m: "AM"
        }, {
          f: 9700000,
          d: "For new organization\nNippon Hoso Kyokai\nRadio New Zealand\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 9705000,
          d: "BBC Worldservice\nChina National Radio\nChina Radio International\nEncompass Digital Media Services\nVatican Radio",
          m: "AM"
        }, {
          f: 9710000,
          d: "China National Radio\nChina Radio International\nRadio France Internationale\nTelediffusion d'Algerie",
          m: "AM"
        }, {
          f: 9715000,
          d: "Media Broadcast GmbH\nWorld Christian Broadcasting Corporation",
          m: "AM"
        }, {
          f: 9720000,
          d: "Abu Dhabi Media Company\nAdventist Broadcasting Service, Inc.\nChina National Radio\nChina Radio International\nUnited States Agency for Global Media (USAGM)\nVatican Radio\nWorld Christian Broadcasting Corporation",
          m: "AM"
        }, {
          f: 9725000,
          d: "Islamic Republic of Iran Broadcasting",
          m: "AM"
        }, {
          f: 9730000,
          d: "China National Radio\nChina Radio International\nEgypt Radio & TV Union\nMinistry of Information - State of Kuwait\nVoice of Russia\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 9735000,
          d: "China National Radio\nRadio France Internationale",
          m: "AM"
        }, {
          f: 9740000,
          d: "Adventist Broadcasting Service, Inc.\nBBC Worldservice\nDeutsche Welle\nKorean Broadcasting System\nMedia Broadcast GmbH\nNippon Hoso Kyokai\nRadio Romania International\nTelediffusion d'Algerie\nVoice of Russia",
          m: "AM"
        }, {
          f: 9745000,
          d: "BBC Worldservice\nChina National Radio\nChina Radio International\nPakistan Broadcasting Corporation\nRadio Republic of Indonesia",
          m: "AM"
        }, {
          f: 9750000,
          d: "Abu Dhabi Media Company\nBBC Worldservice\nChina National Radio\nKorean Broadcasting System\nMinistry of Information - State of Kuwait\nNippon Hoso Kyokai\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9755000,
          d: "China National Radio\nKorean Broadcasting System\nMedia Broadcast GmbH",
          m: "AM"
        }, {
          f: 9760000,
          d: "China Radio International\nNihon Short-wave Broadc. Co.\nNippon Hoso Kyokai\nRadio France Internationale\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9765000,
          d: "Adventist World Radio\nChina Radio International\nMedia Broadcast GmbH\nRadio New Zealand\nRadio Republic of Indonesia\nUnited States Agency for Global Media (USAGM)\nWorld Christian Broadcasting (USA)",
          m: "AM"
        }, {
          f: 9770000,
          d: "Adventist World Radio\nChina Radio International\nKorean Broadcasting System",
          m: "AM"
        }, {
          f: 9775000,
          d: "China National Radio\nIBRA Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9780000,
          d: "China National Radio\nRadio New Zealand\nRadio Republic of Indonesia",
          m: "AM"
        }, {
          f: 9785000,
          d: "China National Radio\nChina Radio International\nKorean Broadcasting System",
          m: "AM"
        }, {
          f: 9790000,
          d: "Radio France Internationale\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9795000,
          d: "China Radio International\nFar East Broadcasting Company\nNippon Hoso Kyokai\nPakistan Broadcasting Corporation\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9800000,
          d: "Adventist Broadcasting Service, Inc.\nAdventist World Radio\nBBC Worldservice\nChina Radio International\nEncompass Digital Media Services\nIslamic Republic of Iran Broadcasting\nMedia Broadcast GmbH\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 9805000,
          d: "Adventist World Radio\nKorean Broadcasting System\nRadio France Internationale",
          m: "AM"
        }, {
          f: 9810000,
          d: "China National Radio\nEgypt Radio & TV Union\nIslamic Republic of Iran Broadcasting\nKorean Broadcasting System\nMedia Broadcast GmbH\nRadio France Internationale\nRadio Romania International\nVatican Radio",
          m: "AM"
        }, {
          f: 9820000,
          d: "BBC Worldservice\nChina National Radio\nMedia Broadcast GmbH\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 9825000,
          d: "China Radio International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9830000,
          d: "China National Radio\nDeutsche Welle\nLeSea Broadcasting Corporation\nMedia Broadcast GmbH\nVoice of Russia",
          m: "AM"
        }, {
          f: 9835000,
          d: "Islamic Republic of Iran Broadcasting\nNippon Hoso Kyokai\nRadio Television Malaysia\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9840000,
          d: "Abu Dhabi Media Company\nLeSea Broadcasting Corporation\nTurkish Radio-TV Corp\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 9845000,
          d: "China National Radio\nVoice of Russia\nWorld Christian Broadcasting (USA)",
          m: "AM"
        }, {
          f: 9850000,
          d: "China National Radio\nMedia Broadcast GmbH\nVoice of Russia\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 9855000,
          d: "China Radio International\nNippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 9860000,
          d: "Adventist Broadcasting Service, Inc.\nAdventist World Radio\nChina National Radio\nChina Radio International\nHCJB Australia\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 9865000,
          d: "China Radio International\nNippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 9870000,
          d: "China Radio International\nIslamic Republic of Iran Broadcasting\nKorean Broadcasting System\nVoice of Russia",
          m: "AM"
        }, {
          f: 9875000,
          d: "Adventist World Radio\nChina Radio International\nFar East Broadcasting Company\nJapan International Communications\nVoice of Russia",
          m: "AM"
        }, {
          f: 9880000,
          d: "China Radio International\nKorean Broadcasting System\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9885000,
          d: "Adventist World Radio\nChina National Radio\nEgypt Radio & TV Union\nUnited States Agency for Global Media (USAGM)\nWorld Christian Broadcasting (USA)",
          m: "AM"
        }, {
          f: 9890000,
          d: "China National Radio\nVoice of Russia",
          m: "AM"
        }, {
          f: 9895000,
          d: "Abu Dhabi Media Company\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 9900000,
          d: "BBC Worldservice\nBroadcast Belgium\nChina National Radio\nEgypt Radio & TV Union\nFor new organization\nPakistan Broadcasting Corporation\nTrans World Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9910000,
          d: "BBC Worldservice\nFor new organization\nTrans World Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9915000,
          d: "BBC Worldservice\nFor new organization\nVoice of Greece",
          m: "AM"
        }, {
          f: 9920000,
          d: "Far East Broadcasting Company\nFor new organization",
          m: "AM"
        }, {
          f: 9925000,
          d: "Media Broadcast GmbH\nPhilippines Broadcasting Service",
          m: "AM"
        }, {
          f: 9930000,
          d: "Leap of Faith, Inc.\nRepublic of Palau\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9935000,
          d: "Voice of Greece",
          m: "AM"
        }, {
          f: 9940000,
          d: "Egypt Radio & TV Union\nFar East Broadcasting Company\nLeap of Faith, Inc.\nNBS of Thailand\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9950000,
          d: "All India Radio\nFor new organization\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9955000,
          d: "Radio Miami International",
          m: "AM"
        }, {
          f: 9965000,
          d: "Republic of Palau\nTrans World Radio",
          m: "AM"
        }, {
          f: 9975000,
          d: "Broadcast Belgium\nTrans World Radio\nUnited States Agency for Global Media (USAGM)\nVoice of Hope",
          m: "AM"
        }, {
          f: 9980000,
          d: "WNQM, Inc.",
          m: "AM"
        }, {
          f: 9985000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 9990000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11510000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11520000,
          d: "For new organization",
          m: "AM"
        }, {
          f: 11525000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11530000,
          d: "Broadcast Belgium\nPakistan Broadcasting Corporation\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11540000,
          d: "Broadcast Belgium",
          m: "AM"
        }, {
          f: 11550000,
          d: "Pakistan Broadcasting Corporation\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11560000,
          d: "All India Radio",
          m: "AM"
        }, {
          f: 11570000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11590000,
          d: "Trans World Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11600000,
          d: "China National Radio\nFar East Broadcasting Company\nThe Overcomer Ministry",
          m: "AM"
        }, {
          f: 11610000,
          d: "China National Radio\nChina Radio International\nMedia Broadcast GmbH\nUnited States Agency for Global Media (USAGM)\nWorld Christian Broadcasting (USA)",
          m: "AM"
        }, {
          f: 11620000,
          d: "Adventist Broadcasting Service, Inc.\nAdventist World Radio\nChina National Radio\nMedia Broadcast GmbH\nNippon Hoso Kyokai\nVatican Radio",
          m: "AM"
        }, {
          f: 11630000,
          d: "China National Radio\nFor new organization\nMinistry of Information - State of Kuwait\nNippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 11635000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 11640000,
          d: "Adventist World Radio\nChina Radio International\nFree Press Unlimited (Amsterdam)",
          m: "AM"
        }, {
          f: 11645000,
          d: "Voice of Greece",
          m: "AM"
        }, {
          f: 11650000,
          d: "China Radio International\nFree Press Unlimited (Amsterdam)\nMedia Broadcast GmbH\nNippon Hoso Kyokai\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 11655000,
          d: "Abu Dhabi Media Company\nFor new organization\nIBRA Radio",
          m: "AM"
        }, {
          f: 11660000,
          d: "BBC Worldservice\nChina National Radio\nEncompass Digital Media Services\nRadio Romania International\nTrans World Radio\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11665000,
          d: "Radio Television Malaysia",
          m: "AM"
        }, {
          f: 11670000,
          d: "China National Radio\nMedia Broadcast GmbH\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11675000,
          d: "Radio Republic of Indonesia\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11680000,
          d: "China National Radio\nChina Radio International\nVoice of Hope",
          m: "AM"
        }, {
          f: 11685000,
          d: "China National Radio\nRadio Exterior de Espana\nVoice of Russia",
          m: "AM"
        }, {
          f: 11690000,
          d: "Adventist Broadcasting Service, Inc.\nChina Radio International\nMalagasy Glabal Business S.A.\nRadio New Zealand",
          m: "AM"
        }, {
          f: 11695000,
          d: "China National Radio\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 11700000,
          d: "China Radio International\nFor new organization\nIslamic Republic of Iran Broadcasting\nMedia Broadcast GmbH\nRadio France Internationale",
          m: "AM"
        }, {
          f: 11705000,
          d: "Malagasy Glabal Business S.A.",
          m: "AM"
        }, {
          f: 11710000,
          d: "China National Radio\nChina Radio International\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 11715000,
          d: "Korean Broadcasting System",
          m: "AM"
        }, {
          f: 11720000,
          d: "Adventist World Radio\nChina National Radio\nChina Radio International\nUnited States Agency for Global Media (USAGM)\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 11725000,
          d: "Abu Dhabi Media Company\nBBC Worldservice\nChina Radio International\nKorean Broadcasting System\nNippon Hoso Kyokai\nRadio New Zealand\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11730000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 11735000,
          d: "Nippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 11740000,
          d: "China National Radio\nChina Radio International\nVoice of Russia",
          m: "AM"
        }, {
          f: 11750000,
          d: "BBC Worldservice\nChina National Radio\nChina Radio International\nFar East Broadcasting Company\nPakistan Broadcasting Corporation\nRadio Republic of Indonesia\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11755000,
          d: "Adventist World Radio",
          m: "AM"
        }, {
          f: 11760000,
          d: "China National Radio\nChina Radio International\nRadio France Internationale\nRadio Republic of Indonesia\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11765000,
          d: "Radio France Internationale\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11770000,
          d: "China National Radio\nChina Radio International",
          m: "AM"
        }, {
          f: 11775000,
          d: "Abu Dhabi Media Company\nChina National Radio\nPlummer Applications\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11780000,
          d: "China Radio International\nIslamic Republic of Iran Broadcasting\nRadio France Internationale\nRadio Romania International\nTrans World Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11785000,
          d: "China Radio International\nKorean Broadcasting System\nRadio Republic of Indonesia",
          m: "AM"
        }, {
          f: 11790000,
          d: "China Radio International\nMedia Broadcast GmbH\nNippon Hoso Kyokai\nRadio Romania International",
          m: "AM"
        }, {
          f: 11795000,
          d: "China Radio International\nKorean Broadcasting System\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11800000,
          d: "China National Radio\nDeutsche Welle\nMedia Broadcast GmbH\nRadio Republic of Indonesia\nRadio Romania International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11805000,
          d: "China Radio International\nPakistan Broadcasting Corporation\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11810000,
          d: "BBC Worldservice\nChina National Radio\nKorean Broadcasting System",
          m: "AM"
        }, {
          f: 11815000,
          d: "Nippon Hoso Kyokai\nTurkish Radio-TV Corp\nVatican Radio",
          m: "AM"
        }, {
          f: 11820000,
          d: "China Radio International\nRadio Romania International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11825000,
          d: "BBC Worldservice\nHCJB Australia\nLeSea Broadcasting Corporation\nNippon Hoso Kyokai\nRadio Romania International\nWorld Christian Broadcasting (USA)",
          m: "AM"
        }, {
          f: 11830000,
          d: "Deutsche Welle\nEncompass Digital Media Services",
          m: "AM"
        }, {
          f: 11840000,
          d: "HFCC, Intl. Radio for Disaster Relief project",
          m: "AM"
        }, {
          f: 11850000,
          d: "Abu Dhabi Media Company\nBBC Worldservice\nChina National Radio\nKorean Broadcasting System\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 11855000,
          d: "China Radio International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11860000,
          d: "China National Radio\nChina Radio International\nRadio Republic of Indonesia\nTrans World Radio\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 11865000,
          d: "HCJB Australia\nPakistan Broadcasting Corporation",
          m: "AM"
        }, {
          f: 11870000,
          d: "Adventist Broadcasting Service, Inc.\nAdventist World Radio\nBBC Worldservice\nChina Radio International\nKorean Broadcasting System\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11875000,
          d: "China Radio International\nHCJB Australia\nIslamic Republic of Iran Broadcasting\nMedia Broadcast GmbH\nNippon Hoso Kyokai\nRadio France Internationale\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11880000,
          d: "Adventist World Radio\nChina Radio International\nIslamic Republic of Iran Broadcasting\nKorean Broadcasting System",
          m: "AM"
        }, {
          f: 11885000,
          d: "China National Radio\nChina Radio International\nRadio Republic of Indonesia\nRadio Television Malaysia\nUnited States Agency for Global Media (USAGM)\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 11890000,
          d: "United States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 11895000,
          d: "China Radio International\nKorean Broadcasting System\nNippon Hoso Kyokai\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 11900000,
          d: "China Radio International\nMedia Broadcast GmbH\nUnited States Agency for Global Media (USAGM)\nVoice of the Andes",
          m: "AM"
        }, {
          f: 11905000,
          d: "BBC Worldservice\nChina National Radio\nHCJB Australia\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11910000,
          d: "Abu Dhabi Media Company\nChina Radio International\nNippon Hoso Kyokai\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11915000,
          d: "China National Radio\nMedia Broadcast GmbH\nVoice of Russia",
          m: "AM"
        }, {
          f: 11920000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 11925000,
          d: "All India Radio\nChina National Radio\nChina Radio International\nNippon Hoso Kyokai\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 11930000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11935000,
          d: "China National Radio\nUnited States Agency for Global Media (USAGM)\nVatican Radio\nVoice of Russia",
          m: "AM"
        }, {
          f: 11940000,
          d: "Radio Exterior de Espana\nVoice of Russia",
          m: "AM"
        }, {
          f: 11945000,
          d: "BBC Worldservice\nChina Radio International\nHCJB Australia\nMedia Broadcast GmbH\nNippon Hoso Kyokai\nRadio Romania International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11950000,
          d: "China National Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11955000,
          d: "Adventist Broadcasting Service, Inc.\nAdventist World Radio\nChina Radio International\nMedia Broadcast GmbH\nRadio Russia\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 11960000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 11965000,
          d: "IBRA Radio\nTrans World Radio\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)\nWorld Christian Broadcasting (USA)",
          m: "AM"
        }, {
          f: 11970000,
          d: "China National Radio\nMinistry of Information - State of Kuwait",
          m: "AM"
        }, {
          f: 11975000,
          d: "China Radio International\nRadio Romania International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11980000,
          d: "Adventist Broadcasting Service, Inc.\nAdventist World Radio\nChina Radio International\nDeutsche Welle\nMedia Broadcast GmbH\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 11985000,
          d: "Adventist World Radio",
          m: "AM"
        }, {
          f: 11990000,
          d: "China National Radio\nChina Radio International\nDeutsche Welle",
          m: "AM"
        }, {
          f: 11995000,
          d: "Abu Dhabi Media Company\nBBC Worldservice\nChina Radio International\nDeutsche Welle\nRadio France Internationale\nTelediffusion d'Algerie\nTrans World Radio",
          m: "AM"
        }, {
          f: 12000000,
          d: "Voice of Vietnam",
          m: "AM"
        }, {
          f: 12005000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 12010000,
          d: "China National Radio\nEncompass Digital Media Services\nNippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 12015000,
          d: "China Radio International\nMongol Radio & Television\nRadio Russia",
          m: "AM"
        }, {
          f: 12020000,
          d: "Adventist World Radio\nFor new organization\nNippon Hoso Kyokai\nVoice of Vietnam",
          m: "AM"
        }, {
          f: 12030000,
          d: "China Radio International\nRadio Exterior de Espana\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 12035000,
          d: "China Radio International\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 12040000,
          d: "Adventist Broadcasting Service, Inc.\nAdventist World Radio\nTrans World Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 12045000,
          d: "China National Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 12050000,
          d: "Encompass Digital Media Services\nEternal Word Television Network, Inc.\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 12055000,
          d: "China National Radio\nFar East Broadcasting Company\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 12060000,
          d: "Voice of Russia",
          m: "AM"
        }, {
          f: 12065000,
          d: "BBC Worldservice\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 12070000,
          d: "China Radio International\nFar East Broadcasting Company\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 12075000,
          d: "Trans World Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 12080000,
          d: "Adventist Broadcasting Service, Inc.\nChina National Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 12085000,
          d: "Adventist Broadcasting Service, Inc.\nFor new organization\nMongol Radio & Television",
          m: "AM"
        }, {
          f: 12095000,
          d: "Abu Dhabi Media Company\nBBC Worldservice\nFar East Broadcasting Company",
          m: "AM"
        }, {
          f: 12100000,
          d: "The Overcomer Ministry",
          m: "AM"
        }, {
          f: 12110000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 12120000,
          d: "Far East Broadcasting Company\nPhilippines Broadcasting Service\nTrans World Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 12125000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 12140000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 12160000,
          d: "For new organization\nWNQM, Inc.",
          m: "AM"
        }, {
          f: 12180000,
          d: "WNQM, Inc.",
          m: "AM"
        }, {
          f: 13570000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 13580000,
          d: "Abu Dhabi Media Company\nChina Radio International\nTrans World Radio\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 13590000,
          d: "Abu Dhabi Media Company\nChina Radio International\nMedia Broadcast GmbH\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 13600000,
          d: "China Radio International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 13605000,
          d: "Telediffusion d'Algerie",
          m: "AM"
        }, {
          f: 13610000,
          d: "China National Radio\nChina Radio International",
          m: "AM"
        }, {
          f: 13620000,
          d: "HFCC, Intl. Radio for Disaster Relief project",
          m: "AM"
        }, {
          f: 13630000,
          d: "Abu Dhabi Media Company\nChina National Radio\nChina Radio International\nPakistan Broadcasting Corporation\nRadio Romania International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 13640000,
          d: "China Radio International\nTelediffusion d'Algerie",
          m: "AM"
        }, {
          f: 13645000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 13650000,
          d: "China Radio International\nMinistry of Information - State of Kuwait\nNippon Hoso Kyokai\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 13655000,
          d: "China Radio International\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 13660000,
          d: "Abu Dhabi Media Company\nChina Radio International\nMedia Broadcast GmbH\nRadio Miami International",
          m: "AM"
        }, {
          f: 13665000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 13670000,
          d: "China National Radio\nChina Radio International\nKorean Broadcasting System\nWorld Christian Broadcasting (USA)",
          m: "AM"
        }, {
          f: 13675000,
          d: "Media Broadcast GmbH",
          m: "AM"
        }, {
          f: 13685000,
          d: "China Radio International\nRadio France Internationale\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 13690000,
          d: "Islamic Republic of Iran Broadcasting",
          m: "AM"
        }, {
          f: 13695000,
          d: "Radio France Internationale",
          m: "AM"
        }, {
          f: 13700000,
          d: "China National Radio\nFor new organization",
          m: "AM"
        }, {
          f: 13705000,
          d: "Korean Broadcasting System",
          m: "AM"
        }, {
          f: 13710000,
          d: "All India Radio\nBroadcast Belgium\nChina National Radio\nIslamic Republic of Iran Broadcasting\nMedia Broadcast GmbH\nRadio Miami International\nWorld Christian Broadcasting (USA)",
          m: "AM"
        }, {
          f: 13715000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 13720000,
          d: "China Radio International\nRadio Romania International",
          m: "AM"
        }, {
          f: 13725000,
          d: "Nippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 13730000,
          d: "Broadcast Belgium\nChina Radio International\nNippon Hoso Kyokai\nRadio New Zealand\nRadio Romania International",
          m: "AM"
        }, {
          f: 13740000,
          d: "BBC Worldservice\nChina Radio International\nPakistan Broadcasting Corporation\nRadio France Internationale\nVoice of the Andes",
          m: "AM"
        }, {
          f: 13750000,
          d: "Abu Dhabi Media Company\nBBC Worldservice\nChina Radio International\nNBS of Thailand\nRadio Romania International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 13755000,
          d: "Radio Republic of Indonesia",
          m: "AM"
        }, {
          f: 13760000,
          d: "World Christian Broadcasting (USA)",
          m: "AM"
        }, {
          f: 13765000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 13770000,
          d: "Abu Dhabi Media Company\nChina National Radio\nChina Radio International",
          m: "AM"
        }, {
          f: 13775000,
          d: "Deutsche Welle",
          m: "AM"
        }, {
          f: 13780000,
          d: "China Radio International\nMedia Broadcast GmbH\nVoice of Russia",
          m: "AM"
        }, {
          f: 13790000,
          d: "BBC Worldservice\nChina Radio International\nIslamic Republic of Iran Broadcasting",
          m: "AM"
        }, {
          f: 13795000,
          d: "All India Radio",
          m: "AM"
        }, {
          f: 13800000,
          d: "China Radio International\nMedia Broadcast GmbH\nThe Overcomer Ministry\nVoice of Russia",
          m: "AM"
        }, {
          f: 13810000,
          d: "China Radio International\nDeutsche Welle\nTrans World Radio",
          m: "AM"
        }, {
          f: 13820000,
          d: "Islamic Republic of Iran Broadcasting\nMedia Broadcast GmbH\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 13825000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 13830000,
          d: "United States Agency for Global Media (USAGM)\nVatican Radio",
          m: "AM"
        }, {
          f: 13840000,
          d: "Allan H. Weiner\nNippon Hoso Kyokai\nRadio New Zealand\nTDF (France)",
          m: "AM"
        }, {
          f: 13845000,
          d: "WNQM, Inc.",
          m: "AM"
        }, {
          f: 13850000,
          d: "BBC Worldservice\nChina National Radio\nChina Radio International",
          m: "AM"
        }, {
          f: 13855000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 13860000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 13865000,
          d: "BBC Worldservice\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 13870000,
          d: "Far East Broadcasting Company",
          m: "AM"
        }, {
          f: 15030000,
          d: "All India Radio",
          m: "AM"
        }, {
          f: 15100000,
          d: "Media Broadcast GmbH",
          m: "AM"
        }, {
          f: 15105000,
          d: "Trans World Radio",
          m: "AM"
        }, {
          f: 15110000,
          d: "China Radio International\nMinistry of Information - State of Kuwait\nRadio Exterior de Espana\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15115000,
          d: "The Overcomer Ministry",
          m: "AM"
        }, {
          f: 15120000,
          d: "China Radio International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15125000,
          d: "China Radio International\nRadio Republic of Indonesia",
          m: "AM"
        }, {
          f: 15130000,
          d: "China Radio International\nNippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 15135000,
          d: "China Radio International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15140000,
          d: "Islamic Republic of Iran Broadcasting",
          m: "AM"
        }, {
          f: 15145000,
          d: "Adventist World Radio\nChina Radio International",
          m: "AM"
        }, {
          f: 15150000,
          d: "Free Press Unlimited (Amsterdam)\nMedia Broadcast GmbH\nRadio Republic of Indonesia\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15155000,
          d: "Korean Broadcasting System\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15160000,
          d: "China Radio International\nKorean Broadcasting System",
          m: "AM"
        }, {
          f: 15170000,
          d: "ANTI, Milano\nBroadcast Belgium\nChina Radio International",
          m: "AM"
        }, {
          f: 15175000,
          d: "Broadcast Belgium",
          m: "AM"
        }, {
          f: 15180000,
          d: "China National Radio\nChina Radio International\nMedia Broadcast GmbH\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15185000,
          d: "All India Radio\nChina Radio International",
          m: "AM"
        }, {
          f: 15190000,
          d: "China Radio International\nPhilippines Broadcasting Service",
          m: "AM"
        }, {
          f: 15195000,
          d: "Deutsche Welle\nNippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 15200000,
          d: "Radio Romania International\nTrans World Radio",
          m: "AM"
        }, {
          f: 15205000,
          d: "Media Broadcast GmbH",
          m: "AM"
        }, {
          f: 15210000,
          d: "Adventist Broadcasting Service, Inc.\nAdventist World Radio\nChina Radio International\nKorean Broadcasting System\nMedia Broadcast GmbH",
          m: "AM"
        }, {
          f: 15215000,
          d: "Abu Dhabi Media Company\nAdventist Broadcasting Service, Inc.\nDeutsche Welle\nFar East Broadcasting Company\nMedia Broadcast GmbH",
          m: "AM"
        }, {
          f: 15220000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 15225000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 15230000,
          d: "Deutsche Welle",
          m: "AM"
        }, {
          f: 15235000,
          d: "Media Broadcast GmbH\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15240000,
          d: "Islamic Republic of Iran Broadcasting",
          m: "AM"
        }, {
          f: 15245000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 15250000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 15255000,
          d: "Adventist Broadcasting Service, Inc.\nRadio Romania International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15260000,
          d: "China Radio International\nIBRA Radio\nMedia Broadcast GmbH\nRadio Romania International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15265000,
          d: "Radio Miami International",
          m: "AM"
        }, {
          f: 15270000,
          d: "China National Radio\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15275000,
          d: "Deutsche Welle",
          m: "AM"
        }, {
          f: 15280000,
          d: "Nippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 15285000,
          d: "Media Broadcast GmbH\nRadio Miami International",
          m: "AM"
        }, {
          f: 15290000,
          d: "Nippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 15295000,
          d: "Radio Television Malaysia",
          m: "AM"
        }, {
          f: 15300000,
          d: "Media Broadcast GmbH\nRadio France Internationale",
          m: "AM"
        }, {
          f: 15310000,
          d: "Adventist World Radio\nBBC Worldservice",
          m: "AM"
        }, {
          f: 15320000,
          d: "China National Radio\nMedia Broadcast GmbH",
          m: "AM"
        }, {
          f: 15325000,
          d: "Adventist Broadcasting Service, Inc.\nNippon Hoso Kyokai\nVoice of Russia",
          m: "AM"
        }, {
          f: 15330000,
          d: "Far East Broadcasting Company\nRadio Miami International",
          m: "AM"
        }, {
          f: 15335000,
          d: "BBC Worldservice\nChina Radio International\nThe Overcomer Ministry",
          m: "AM"
        }, {
          f: 15340000,
          d: "China Radio International\nRadio Miami International",
          m: "AM"
        }, {
          f: 15350000,
          d: "China Radio International\nDeutsche Welle\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 15355000,
          d: "Adventist World Radio",
          m: "AM"
        }, {
          f: 15360000,
          d: "Abu Dhabi Media Company\nAdventist World Radio\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 15365000,
          d: "Adventist Broadcasting Service, Inc.",
          m: "AM"
        }, {
          f: 15370000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 15375000,
          d: "Telediffusion d'Algerie",
          m: "AM"
        }, {
          f: 15380000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 15390000,
          d: "China National Radio\nDeutsche Welle\nRadio Exterior de Espana\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 15400000,
          d: "Abu Dhabi Media Company\nBBC Worldservice",
          m: "AM"
        }, {
          f: 15410000,
          d: "Adventist World Radio\nHCJB Australia",
          m: "AM"
        }, {
          f: 15415000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 15420000,
          d: "Abu Dhabi Media Company\nAdventist Broadcasting Service, Inc.\nAdventist World Radio\nBBC Worldservice\nFar East Broadcasting Company\nMedia Broadcast GmbH",
          m: "AM"
        }, {
          f: 15425000,
          d: "China Radio International\nMedia Broadcast GmbH\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15430000,
          d: "Adventist World Radio\nChina Radio International\nRadio Romania International",
          m: "AM"
        }, {
          f: 15435000,
          d: "China Radio International\nFar East Broadcasting Company",
          m: "AM"
        }, {
          f: 15440000,
          d: "Adventist World Radio\nChina Radio International\nIslamic Republic of Iran Broadcasting",
          m: "AM"
        }, {
          f: 15445000,
          d: "Adventist World Radio\nChina Radio International",
          m: "AM"
        }, {
          f: 15450000,
          d: "Adventist Broadcasting Service, Inc.\nFar East Broadcasting Company\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15455000,
          d: "Radio France Internationale\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15460000,
          d: "Radio Romania International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15465000,
          d: "China National Radio\nChina Radio International",
          m: "AM"
        }, {
          f: 15470000,
          d: "Media Broadcast GmbH",
          m: "AM"
        }, {
          f: 15480000,
          d: "China National Radio\nEncompass Digital Media Services\nTurkish Radio-TV Corp",
          m: "AM"
        }, {
          f: 15485000,
          d: "TDF (France)",
          m: "AM"
        }, {
          f: 15490000,
          d: "Abu Dhabi Media Company\nAdventist World Radio\nBBC Worldservice\nIBRA Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15500000,
          d: "Adventist Broadcasting Service, Inc.\nChina National Radio\nRadio Exterior de Espana",
          m: "AM"
        }, {
          f: 15505000,
          d: "TDF (France)",
          m: "AM"
        }, {
          f: 15515000,
          d: "Adventist World Radio\nFor new organization\nMinistry of Information - State of Kuwait",
          m: "AM"
        }, {
          f: 15520000,
          d: "Adventist World Radio\nVoice of Russia",
          m: "AM"
        }, {
          f: 15525000,
          d: "China Radio International\nMedia Broadcast GmbH",
          m: "AM"
        }, {
          f: 15530000,
          d: "Adventist Broadcasting Service, Inc.\nAdventist World Radio\nLeSea Broadcasting Corporation\nMinistry of Information - State of Kuwait",
          m: "AM"
        }, {
          f: 15540000,
          d: "China National Radio\nMinistry of Information - State of Kuwait",
          m: "AM"
        }, {
          f: 15550000,
          d: "Adventist Broadcasting Service, Inc.\nAdventist World Radio\nChina National Radio\nChina Radio International\nFree Press Unlimited (Amsterdam)",
          m: "AM"
        }, {
          f: 15555000,
          d: "Hill Radio International",
          m: "AM"
        }, {
          f: 15560000,
          d: "China Radio International\nFar East Broadcasting Company\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15565000,
          d: "Encompass Digital Media Services\nNippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 15570000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 15575000,
          d: "Korean Broadcasting System\nVatican Radio",
          m: "AM"
        }, {
          f: 15580000,
          d: "Adventist Broadcasting Service, Inc.\nFar East Broadcasting Company\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15590000,
          d: "Nippon Hoso Kyokai\nWRNO Worldwide, Inc.",
          m: "AM"
        }, {
          f: 15595000,
          d: "Vatican Radio",
          m: "AM"
        }, {
          f: 15600000,
          d: "For new organization\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15605000,
          d: "Adventist World Radio\nVatican Radio",
          m: "AM"
        }, {
          f: 15610000,
          d: "Adventist Broadcasting Service, Inc.\nAdventist World Radio\nEternal Word Television Network, Inc.\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15615000,
          d: "Adventist Broadcasting Service, Inc.",
          m: "AM"
        }, {
          f: 15620000,
          d: "BBC Worldservice\nChina Radio International\nFar East Broadcasting Company\nMedia Broadcast GmbH\nMinistry of Information - State of Kuwait",
          m: "AM"
        }, {
          f: 15625000,
          d: "Adventist Broadcasting Service, Inc.\nAdventist World Radio",
          m: "AM"
        }, {
          f: 15630000,
          d: "Pakistan Broadcasting Corporation",
          m: "AM"
        }, {
          f: 15640000,
          d: "Far East Broadcasting Company\nPhilippines Broadcasting Service\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15650000,
          d: "HFCC, Intl. Radio for Disaster Relief project",
          m: "AM"
        }, {
          f: 15665000,
          d: "Adventist Broadcasting Service, Inc.\nChina Radio International\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 15680000,
          d: "Adventist World Radio\nRepublic of Palau",
          m: "AM"
        }, {
          f: 15685000,
          d: "BBC Worldservice",
          m: "AM"
        }, {
          f: 15690000,
          d: "Encompass Digital Media Services\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15700000,
          d: "The Overcomer Ministry",
          m: "AM"
        }, {
          f: 15705000,
          d: "Adventist World Radio",
          m: "AM"
        }, {
          f: 15710000,
          d: "China National Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15715000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15720000,
          d: "Nippon Hoso Kyokai\nRadio New Zealand",
          m: "AM"
        }, {
          f: 15730000,
          d: "Pakistan Broadcasting Corporation\nTelediffusion d'Algerie\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15735000,
          d: "For new organization",
          m: "AM"
        }, {
          f: 15745000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15750000,
          d: "World International Broadcasters, Inc.",
          m: "AM"
        }, {
          f: 15755000,
          d: "For new organization\nNippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 15765000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 15770000,
          d: "Media Broadcast GmbH\nRadio Miami International",
          m: "AM"
        }, {
          f: 15780000,
          d: "Allan H. Weiner",
          m: "AM"
        }, {
          f: 15785000,
          d: "BitExpress (Germany)",
          m: "AM"
        }, {
          f: 15790000,
          d: "World Music Radio",
          m: "AM"
        }, {
          f: 15795000,
          d: "WNQM, Inc.",
          m: "AM"
        }, {
          f: 15810000,
          d: "Leap of Faith, Inc.",
          m: "AM"
        }, {
          f: 15825000,
          d: "WNQM, Inc.",
          m: "AM"
        }, {
          f: 17485000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 17490000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 17500000,
          d: "HFCC, Intl. Radio for Disaster Relief project",
          m: "AM"
        }, {
          f: 17510000,
          d: "China Radio International\nThe Overcomer Ministry",
          m: "AM"
        }, {
          f: 17520000,
          d: "Allan H. Weiner\nChina Radio International\nVatican Radio",
          m: "AM"
        }, {
          f: 17525000,
          d: "Adventist Broadcasting Service, Inc.\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17530000,
          d: "Media Broadcast GmbH\nTelediffusion d'Algerie\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)\nWorld Christian Broadcasting (USA)",
          m: "AM"
        }, {
          f: 17540000,
          d: "China Radio International\nVatican Radio",
          m: "AM"
        }, {
          f: 17545000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17550000,
          d: "China National Radio\nMinistry of Information - State of Kuwait",
          m: "AM"
        }, {
          f: 17560000,
          d: "Nippon Hoso Kyokai",
          m: "AM"
        }, {
          f: 17565000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 17570000,
          d: "Adventist World Radio\nChina Radio International",
          m: "AM"
        }, {
          f: 17580000,
          d: "China National Radio\nMedia Broadcast GmbH\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17585000,
          d: "Nippon Hoso Kyokai\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17595000,
          d: "China National Radio\nIslamic Republic of Iran Broadcasting",
          m: "AM"
        }, {
          f: 17600000,
          d: "Media Broadcast GmbH",
          m: "AM"
        }, {
          f: 17605000,
          d: "China National Radio\nMedia Broadcast GmbH",
          m: "AM"
        }, {
          f: 17615000,
          d: "China Radio International\nVoice of Russia",
          m: "AM"
        }, {
          f: 17620000,
          d: "Radio France Internationale",
          m: "AM"
        }, {
          f: 17625000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 17630000,
          d: "China Radio International\nMedia Broadcast GmbH\nNBS of Thailand",
          m: "AM"
        }, {
          f: 17640000,
          d: "BBC Worldservice\nChina Radio International\nNBS of Thailand\nRadio Romania International",
          m: "AM"
        }, {
          f: 17645000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17650000,
          d: "Adventist Broadcasting Service, Inc.\nChina Radio International\nMedia Broadcast GmbH",
          m: "AM"
        }, {
          f: 17655000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17660000,
          d: "Radio France Internationale\nTDF (France)\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17670000,
          d: "China Radio International\nVoice of Russia",
          m: "AM"
        }, {
          f: 17675000,
          d: "Radio New Zealand\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17680000,
          d: "Abu Dhabi Media Company\nChina Radio International\nTrans World Radio\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17690000,
          d: "China Radio International\nRadio France Internationale\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17700000,
          d: "For new organization\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17710000,
          d: "All India Radio\nChina Radio International",
          m: "AM"
        }, {
          f: 17715000,
          d: "Radio Exterior de Espana",
          m: "AM"
        }, {
          f: 17720000,
          d: "China Radio International\nTurkish Radio-TV Corp\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17730000,
          d: "Adventist World Radio\nChina Radio International\nEncompass Digital Media Services\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17735000,
          d: "China Radio International",
          m: "AM"
        }, {
          f: 17740000,
          d: "China Radio International\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17745000,
          d: "Abu Dhabi Media Company\nBBC Worldservice",
          m: "AM"
        }, {
          f: 17750000,
          d: "China Radio International\nRadio Romania International",
          m: "AM"
        }, {
          f: 17755000,
          d: "Radio Exterior de Espana",
          m: "AM"
        }, {
          f: 17760000,
          d: "Ministry of Information - State of Kuwait",
          m: "AM"
        }, {
          f: 17770000,
          d: "Adventist World Radio\nChina National Radio\nPakistan Broadcasting Corporation",
          m: "AM"
        }, {
          f: 17775000,
          d: "Voice of Hope",
          m: "AM"
        }, {
          f: 17780000,
          d: "BBC Worldservice\nRadio Romania International",
          m: "AM"
        }, {
          f: 17790000,
          d: "Vatican Radio",
          m: "AM"
        }, {
          f: 17800000,
          d: "Abu Dhabi Media Company\nBBC Worldservice\nChina National Radio\nDeutsche Welle\nEncompass Digital Media Services\nRadio Republic of Indonesia\nRadio Romania International\nTDF (France)",
          m: "AM"
        }, {
          f: 17810000,
          d: "Nippon Hoso Kyokai\nRadio Romania International",
          m: "AM"
        }, {
          f: 17815000,
          d: "BBC Worldservice\nChina Radio International\nRadio France Internationale\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17820000,
          d: "Adventist Broadcasting Service, Inc.\nPakistan Broadcasting Corporation\nPhilippines Broadcasting Service\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17830000,
          d: "BBC Worldservice\nChina National Radio\nNippon Hoso Kyokai\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17840000,
          d: "Deutsche Welle\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17845000,
          d: "Abu Dhabi Media Company\nEncompass Digital Media Services",
          m: "AM"
        }, {
          f: 17850000,
          d: "Radio France Internationale\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17855000,
          d: "China Radio International\nRadio Exterior de Espana",
          m: "AM"
        }, {
          f: 17860000,
          d: "Broadcast Belgium",
          m: "AM"
        }, {
          f: 17865000,
          d: "Telediffusion d'Algerie\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17870000,
          d: "Broadcast Belgium\nMedia Broadcast GmbH",
          m: "AM"
        }, {
          f: 17880000,
          d: "China Radio International\nUnited States Agency for Global Media (USAGM)\nVoice of Russia",
          m: "AM"
        }, {
          f: 17885000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17890000,
          d: "China National Radio",
          m: "AM"
        }, {
          f: 17895000,
          d: "Pakistan Broadcasting Corporation\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 17900000,
          d: "For new organization",
          m: "AM"
        }, {
          f: 18950000,
          d: "HFCC, Intl. Radio for Disaster Relief project",
          m: "AM"
        }, {
          f: 21455000,
          d: "Media Broadcast GmbH",
          m: "AM"
        }, {
          f: 21470000,
          d: "Abu Dhabi Media Company\nBBC Worldservice\nRadio Romania International",
          m: "AM"
        }, {
          f: 21480000,
          d: "Media Broadcast GmbH\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 21485000,
          d: "Radio France Internationale",
          m: "AM"
        }, {
          f: 21490000,
          d: "BBC Worldservice",
          m: "AM"
        }, {
          f: 21525000,
          d: "Radio Miami International",
          m: "AM"
        }, {
          f: 21580000,
          d: "Radio France Internationale",
          m: "AM"
        }, {
          f: 21600000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 21610000,
          d: "LeSea Broadcasting Corporation",
          m: "AM"
        }, {
          f: 21620000,
          d: "Radio Exterior de Espana\nUnited States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 21630000,
          d: "Abu Dhabi Media Company\nBBC Worldservice\nTrans World Radio",
          m: "AM"
        }, {
          f: 21690000,
          d: "Abu Dhabi Media Company\nRadio France Internationale",
          m: "AM"
        }, {
          f: 21700000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 21760000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 21785000,
          d: "United States Agency for Global Media (USAGM)",
          m: "AM"
        }, {
          f: 21800000,
          d: "For new organization",
          m: "AM"
        }, {
          f: 21840000,
          d: "HFCC, Intl. Radio for Disaster Relief project",
          m: "AM"
        }, {
          f: 25795000,
          d: "World Music Radio",
          m: "AM"
        }, {
          f: 25800000,
          d: "World Music Radio",
          m: "AM"
        }, {
          f: 25805000,
          d: "World Music Radio",
          m: "AM"
        }, {
          f: 26000000,
          d: "For new organization",
          m: "AM"
        }, {
          f: 26010000,
          d: "HFCC, Intl. Radio for Disaster Relief project",
          m: "AM"
        }, {
          f: 26040000,
          d: "For new organization",
          m: "AM"
        }];
        var builtinAmateur = [];

        /* src/lib/FrequencyMarkers.svelte generated by Svelte v3.55.0 */

        function get_each_context$2(ctx, list, i) {
          var child_ctx = ctx.slice();
          child_ctx[13] = list[i];
          return child_ctx;
        }

        // (65:4) {#each frequencyMarkers as frequencyMarker (frequencyMarker.frequency)}
        function create_each_block$2(key_1, ctx) {
          var div2;
          var div0;
          var t0;
          var div1;
          var t1_value = /*frequencyMarker*/ctx[13].description + "";
          var t1;
          var t2;
          var mounted;
          var dispose;
          function click_handler_1() {
            return (/*click_handler_1*/ctx[5]( /*frequencyMarker*/ctx[13])
            );
          }
          return {
            key: key_1,
            first: null,
            c: function c() {
              div2 = element("div");
              div0 = element("div");
              t0 = space();
              div1 = element("div");
              t1 = text(t1_value);
              t2 = space();
              attr(div0, "class", "top-0 w-px h-8 z-0 peer bg-yellow-600 absolute");
              attr(div1, "class", "outline-1 outline-black outline-offset-0 outline p-px bg-yellow-400 absolute bottom-0 z-10 group-hover:z-20 hover:z-20 peer-hover:z-20 text-left whitespace-pre whitespace-nowrap text-black text-xs align-middle border border-yellow-600 transform origin-bottom-left overflow-hidden h-auto max-h-full hover:max-h-screen peer-hover:max-h-screen transition-all ease-linear duration-1000");
              attr(div2, "class", "h-4 absolute p-0 group");
              set_style(div2, "left", /*frequencyMarker*/ctx[13].left * 100 + "%");
              this.first = div2;
            },
            m: function m(target, anchor) {
              insert(target, div2, anchor);
              append(div2, div0);
              append(div2, t0);
              append(div2, div1);
              append(div1, t1);
              append(div2, t2);
              if (!mounted) {
                dispose = listen(div2, "click", click_handler_1);
                mounted = true;
              }
            },
            p: function p(new_ctx, dirty) {
              ctx = new_ctx;
              if (dirty & /*frequencyMarkers*/1 && t1_value !== (t1_value = /*frequencyMarker*/ctx[13].description + "")) set_data(t1, t1_value);
              if (dirty & /*frequencyMarkers*/1) {
                set_style(div2, "left", /*frequencyMarker*/ctx[13].left * 100 + "%");
              }
            },
            d: function d(detaching) {
              if (detaching) detach(div2);
              mounted = false;
              dispose();
            }
          };
        }
        function create_fragment$4(ctx) {
          var div;
          var each_blocks = [];
          var each_1_lookup = new Map();
          var mounted;
          var dispose;
          var each_value = /*frequencyMarkers*/ctx[0];
          var get_key = function get_key(ctx) {
            return (/*frequencyMarker*/ctx[13].frequency
            );
          };
          for (var _i24 = 0; _i24 < each_value.length; _i24 += 1) {
            var child_ctx = get_each_context$2(ctx, each_value, _i24);
            var key = get_key(child_ctx);
            each_1_lookup.set(key, each_blocks[_i24] = create_each_block$2(key, child_ctx));
          }
          return {
            c: function c() {
              div = element("div");
              for (var _i25 = 0; _i25 < each_blocks.length; _i25 += 1) {
                each_blocks[_i25].c();
              }
              attr(div, "class", "w-full h-4 bg-black relative");
            },
            m: function m(target, anchor) {
              insert(target, div, anchor);
              for (var _i26 = 0; _i26 < each_blocks.length; _i26 += 1) {
                each_blocks[_i26].m(div, null);
              }
              if (!mounted) {
                dispose = [listen(div, "click", self$1( /*click_handler*/ctx[3])), listen(div, "wheel", self$1( /*wheel_handler*/ctx[4]))];
                mounted = true;
              }
            },
            p: function p(ctx, _ref54) {
              var _ref55 = _slicedToArray(_ref54, 1),
                dirty = _ref55[0];
              if (dirty & /*frequencyMarkers, dispatch*/3) {
                each_value = /*frequencyMarkers*/ctx[0];
                each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, destroy_block, create_each_block$2, null, get_each_context$2);
              }
            },
            i: noop,
            o: noop,
            d: function d(detaching) {
              if (detaching) detach(div);
              for (var _i27 = 0; _i27 < each_blocks.length; _i27 += 1) {
                each_blocks[_i27].d();
              }
              mounted = false;
              run_all(dispose);
            }
          };
        }
        function frequencyListComparator(a, b) {
          return a[0] - b[0];
        }
        function instance$4($$self, $$props, $$invalidate) {
          var dispatch = createEventDispatcher();
          var frequencyList = [];
          function insertAll(frequencies) {
            var _iterator19 = _createForOfIteratorHelper(frequencies),
              _step19;
            try {
              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                var frequency = _step19.value;
                frequencyList.push([frequency.f || frequency.frequency, frequency.d || frequency.description, frequency.m || frequency.modulation]);
              }
            } catch (err) {
              _iterator19.e(err);
            } finally {
              _iterator19.f();
            }
          }
          function finalizeList() {
            frequencyList.sort(frequencyListComparator);
          }
          insertAll(builtinShortwave);
          insertAll(builtinAmateur);
          finalizeList();
          function getFrequencyBoundsInRange(lo, hi) {
            return [searchBounds.ge(frequencyList, [lo], frequencyListComparator), searchBounds.ge(frequencyList, [hi], frequencyListComparator)];
          }
          function getFrequencyInRange(from, to) {
            return frequencyList.slice(from, to).map(function (x) {
              return {
                frequency: x[0],
                description: x[1],
                modulation: x[2],
                left: 0
              };
            });
          }
          var frequencyMarkers = [];
          var frequencyBoundsLo = -1;
          var frequencyBoundsHi = -1;
          function updateFrequencyMarkerPositions() {
            var _getFrequencyView = getFrequencyView(),
              _getFrequencyView2 = _slicedToArray(_getFrequencyView, 2),
              frequencyFrom = _getFrequencyView2[0],
              frequencyTo = _getFrequencyView2[1];
            var _getFrequencyBoundsIn = getFrequencyBoundsInRange(frequencyFrom, frequencyTo),
              _getFrequencyBoundsIn2 = _slicedToArray(_getFrequencyBoundsIn, 2),
              from = _getFrequencyBoundsIn2[0],
              to = _getFrequencyBoundsIn2[1];
            if (frequencyTo - frequencyFrom <= 200000) {
              if (from !== frequencyBoundsLo || to !== frequencyBoundsHi) {
                frequencyBoundsLo = from;
                frequencyBoundsHi = to;
                $$invalidate(0, frequencyMarkers = getFrequencyInRange(frequencyBoundsLo, frequencyBoundsHi));
              }
            } else {
              $$invalidate(0, frequencyMarkers = []);
            }
            for (var _i28 = 0; _i28 < frequencyMarkers.length; _i28++) {
              $$invalidate(0, frequencyMarkers[_i28].left = frequencyToWaterfallOffset(frequencyMarkers[_i28].frequency), frequencyMarkers);
            }
          }
          function click_handler(event) {
            bubble.call(this, $$self, event);
          }
          function wheel_handler(event) {
            bubble.call(this, $$self, event);
          }
          var click_handler_1 = function click_handler_1(frequencyMarker) {
            return dispatch('markerclick', frequencyMarker);
          };
          return [frequencyMarkers, dispatch, updateFrequencyMarkerPositions, click_handler, wheel_handler, click_handler_1];
        }
        var FrequencyMarkers = /*#__PURE__*/function (_SvelteComponent5) {
          _inherits(FrequencyMarkers, _SvelteComponent5);
          var _super13 = _createSuper(FrequencyMarkers);
          function FrequencyMarkers(options) {
            var _this35;
            _classCallCheck(this, FrequencyMarkers);
            _this35 = _super13.call(this);
            init$1(_assertThisInitialized2(_this35), options, instance$4, create_fragment$4, safe_not_equal, {
              updateFrequencyMarkerPositions: 2
            });
            return _this35;
          }
          _createClass(FrequencyMarkers, [{
            key: "updateFrequencyMarkerPositions",
            get: function get() {
              return this.$$.ctx[2];
            }
          }]);
          return FrequencyMarkers;
        }(SvelteComponent);
        var top = 'top';
        var bottom = 'bottom';
        var right = 'right';
        var left = 'left';
        var auto = 'auto';
        var basePlacements = [top, bottom, right, left];
        var start = 'start';
        var end = 'end';
        var clippingParents = 'clippingParents';
        var viewport = 'viewport';
        var popper = 'popper';
        var reference = 'reference';
        var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
          return acc.concat([placement + "-" + start, placement + "-" + end]);
        }, []);
        var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
          return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
        }, []); // modifiers that need to read the DOM

        var beforeRead = 'beforeRead';
        var read = 'read';
        var afterRead = 'afterRead'; // pure-logic modifiers

        var beforeMain = 'beforeMain';
        var main = 'main';
        var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

        var beforeWrite = 'beforeWrite';
        var write = 'write';
        var afterWrite = 'afterWrite';
        var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
        function getNodeName(element) {
          return element ? (element.nodeName || '').toLowerCase() : null;
        }
        function getWindow(node) {
          if (node == null) {
            return window;
          }
          if (node.toString() !== '[object Window]') {
            var ownerDocument = node.ownerDocument;
            return ownerDocument ? ownerDocument.defaultView || window : window;
          }
          return node;
        }
        function isElement$1(node) {
          var OwnElement = getWindow(node).Element;
          return node instanceof OwnElement || node instanceof Element;
        }
        function isHTMLElement(node) {
          var OwnElement = getWindow(node).HTMLElement;
          return node instanceof OwnElement || node instanceof HTMLElement;
        }
        function isShadowRoot(node) {
          // IE 11 has no ShadowRoot
          if (typeof ShadowRoot === 'undefined') {
            return false;
          }
          var OwnElement = getWindow(node).ShadowRoot;
          return node instanceof OwnElement || node instanceof ShadowRoot;
        }

        // and applies them to the HTMLElements such as popper and arrow

        function applyStyles(_ref) {
          var state = _ref.state;
          Object.keys(state.elements).forEach(function (name) {
            var style = state.styles[name] || {};
            var attributes = state.attributes[name] || {};
            var element = state.elements[name]; // arrow is optional + virtual elements

            if (!isHTMLElement(element) || !getNodeName(element)) {
              return;
            } // Flow doesn't support to extend this property, but it's the most
            // effective way to apply styles to an HTMLElement
            // $FlowFixMe[cannot-write]

            Object.assign(element.style, style);
            Object.keys(attributes).forEach(function (name) {
              var value = attributes[name];
              if (value === false) {
                element.removeAttribute(name);
              } else {
                element.setAttribute(name, value === true ? '' : value);
              }
            });
          });
        }
        function effect$2(_ref2) {
          var state = _ref2.state;
          var initialStyles = {
            popper: {
              position: state.options.strategy,
              left: '0',
              top: '0',
              margin: '0'
            },
            arrow: {
              position: 'absolute'
            },
            reference: {}
          };
          Object.assign(state.elements.popper.style, initialStyles.popper);
          state.styles = initialStyles;
          if (state.elements.arrow) {
            Object.assign(state.elements.arrow.style, initialStyles.arrow);
          }
          return function () {
            Object.keys(state.elements).forEach(function (name) {
              var element = state.elements[name];
              var attributes = state.attributes[name] || {};
              var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

              var style = styleProperties.reduce(function (style, property) {
                style[property] = '';
                return style;
              }, {}); // arrow is optional + virtual elements

              if (!isHTMLElement(element) || !getNodeName(element)) {
                return;
              }
              Object.assign(element.style, style);
              Object.keys(attributes).forEach(function (attribute) {
                element.removeAttribute(attribute);
              });
            });
          };
        } // eslint-disable-next-line import/no-unused-modules

        var applyStyles$1 = {
          name: 'applyStyles',
          enabled: true,
          phase: 'write',
          fn: applyStyles,
          effect: effect$2,
          requires: ['computeStyles']
        };
        function getBasePlacement(placement) {
          return placement.split('-')[0];
        }
        var max = Math.max;
        var min = Math.min;
        var round$1 = Math.round;
        function getUAString() {
          var uaData = navigator.userAgentData;
          if (uaData != null && uaData.brands) {
            return uaData.brands.map(function (item) {
              return item.brand + "/" + item.version;
            }).join(' ');
          }
          return navigator.userAgent;
        }
        function isLayoutViewport() {
          return !/^((?!chrome|android).)*safari/i.test(getUAString());
        }
        function getBoundingClientRect(element, includeScale, isFixedStrategy) {
          if (includeScale === void 0) {
            includeScale = false;
          }
          if (isFixedStrategy === void 0) {
            isFixedStrategy = false;
          }
          var clientRect = element.getBoundingClientRect();
          var scaleX = 1;
          var scaleY = 1;
          if (includeScale && isHTMLElement(element)) {
            scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
            scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
          }
          var _ref = isElement$1(element) ? getWindow(element) : window,
            visualViewport = _ref.visualViewport;
          var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
          var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
          var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
          var width = clientRect.width / scaleX;
          var height = clientRect.height / scaleY;
          return {
            width: width,
            height: height,
            top: y,
            right: x + width,
            bottom: y + height,
            left: x,
            x: x,
            y: y
          };
        }

        // means it doesn't take into account transforms.

        function getLayoutRect(element) {
          var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
          // Fixes https://github.com/popperjs/popper-core/issues/1223

          var width = element.offsetWidth;
          var height = element.offsetHeight;
          if (Math.abs(clientRect.width - width) <= 1) {
            width = clientRect.width;
          }
          if (Math.abs(clientRect.height - height) <= 1) {
            height = clientRect.height;
          }
          return {
            x: element.offsetLeft,
            y: element.offsetTop,
            width: width,
            height: height
          };
        }
        function contains(parent, child) {
          var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

          if (parent.contains(child)) {
            return true;
          } // then fallback to custom implementation with Shadow DOM support
          else if (rootNode && isShadowRoot(rootNode)) {
            var next = child;
            do {
              if (next && parent.isSameNode(next)) {
                return true;
              } // $FlowFixMe[prop-missing]: need a better way to handle this...

              next = next.parentNode || next.host;
            } while (next);
          } // Give up, the result is false

          return false;
        }
        function getComputedStyle$1(element) {
          return getWindow(element).getComputedStyle(element);
        }
        function isTableElement(element) {
          return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
        }
        function getDocumentElement(element) {
          // $FlowFixMe[incompatible-return]: assume body is always available
          return ((isElement$1(element) ? element.ownerDocument :
          // $FlowFixMe[prop-missing]
          element.document) || window.document).documentElement;
        }
        function getParentNode(element) {
          if (getNodeName(element) === 'html') {
            return element;
          }
          return (
            // this is a quicker (but less type safe) way to save quite some bytes from the bundle
            // $FlowFixMe[incompatible-return]
            // $FlowFixMe[prop-missing]
            element.assignedSlot ||
            // step into the shadow DOM of the parent of a slotted node
            element.parentNode || (
            // DOM Element detected
            isShadowRoot(element) ? element.host : null) ||
            // ShadowRoot detected
            // $FlowFixMe[incompatible-call]: HTMLElement is a Node
            getDocumentElement(element) // fallback
          );
        }

        function getTrueOffsetParent(element) {
          if (!isHTMLElement(element) ||
          // https://github.com/popperjs/popper-core/issues/837
          getComputedStyle$1(element).position === 'fixed') {
            return null;
          }
          return element.offsetParent;
        } // `.offsetParent` reports `null` for fixed elements, while absolute elements
        // return the containing block

        function getContainingBlock(element) {
          var isFirefox = /firefox/i.test(getUAString());
          var isIE = /Trident/i.test(getUAString());
          if (isIE && isHTMLElement(element)) {
            // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
            var elementCss = getComputedStyle$1(element);
            if (elementCss.position === 'fixed') {
              return null;
            }
          }
          var currentNode = getParentNode(element);
          if (isShadowRoot(currentNode)) {
            currentNode = currentNode.host;
          }
          while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
            var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
            // create a containing block.
            // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

            if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
              return currentNode;
            } else {
              currentNode = currentNode.parentNode;
            }
          }
          return null;
        } // Gets the closest ancestor positioned element. Handles some edge cases,
        // such as table ancestors and cross browser bugs.

        function getOffsetParent(element) {
          var window = getWindow(element);
          var offsetParent = getTrueOffsetParent(element);
          while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
            offsetParent = getTrueOffsetParent(offsetParent);
          }
          if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
            return window;
          }
          return offsetParent || getContainingBlock(element) || window;
        }
        function getMainAxisFromPlacement(placement) {
          return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
        }
        function within(min$1, value, max$1) {
          return max(min$1, min(value, max$1));
        }
        function withinMaxClamp(min, value, max) {
          var v = within(min, value, max);
          return v > max ? max : v;
        }
        function getFreshSideObject() {
          return {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          };
        }
        function mergePaddingObject(paddingObject) {
          return Object.assign({}, getFreshSideObject(), paddingObject);
        }
        function expandToHashMap(value, keys) {
          return keys.reduce(function (hashMap, key) {
            hashMap[key] = value;
            return hashMap;
          }, {});
        }
        var toPaddingObject = function toPaddingObject(padding, state) {
          padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
            placement: state.placement
          })) : padding;
          return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
        };
        function arrow(_ref) {
          var _state$modifiersData$;
          var state = _ref.state,
            name = _ref.name,
            options = _ref.options;
          var arrowElement = state.elements.arrow;
          var popperOffsets = state.modifiersData.popperOffsets;
          var basePlacement = getBasePlacement(state.placement);
          var axis = getMainAxisFromPlacement(basePlacement);
          var isVertical = [left, right].indexOf(basePlacement) >= 0;
          var len = isVertical ? 'height' : 'width';
          if (!arrowElement || !popperOffsets) {
            return;
          }
          var paddingObject = toPaddingObject(options.padding, state);
          var arrowRect = getLayoutRect(arrowElement);
          var minProp = axis === 'y' ? top : left;
          var maxProp = axis === 'y' ? bottom : right;
          var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
          var startDiff = popperOffsets[axis] - state.rects.reference[axis];
          var arrowOffsetParent = getOffsetParent(arrowElement);
          var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
          var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
          // outside of the popper bounds

          var min = paddingObject[minProp];
          var max = clientSize - arrowRect[len] - paddingObject[maxProp];
          var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
          var offset = within(min, center, max); // Prevents breaking syntax highlighting...

          var axisProp = axis;
          state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
        }
        function effect$1(_ref2) {
          var state = _ref2.state,
            options = _ref2.options;
          var _options$element = options.element,
            arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;
          if (arrowElement == null) {
            return;
          } // CSS selector

          if (typeof arrowElement === 'string') {
            arrowElement = state.elements.popper.querySelector(arrowElement);
            if (!arrowElement) {
              return;
            }
          }
          if (!contains(state.elements.popper, arrowElement)) {
            return;
          }
          state.elements.arrow = arrowElement;
        } // eslint-disable-next-line import/no-unused-modules

        var arrow$1 = {
          name: 'arrow',
          enabled: true,
          phase: 'main',
          fn: arrow,
          effect: effect$1,
          requires: ['popperOffsets'],
          requiresIfExists: ['preventOverflow']
        };
        function getVariation(placement) {
          return placement.split('-')[1];
        }
        var unsetSides = {
          top: 'auto',
          right: 'auto',
          bottom: 'auto',
          left: 'auto'
        }; // Round the offsets to the nearest suitable subpixel based on the DPR.
        // Zooming can change the DPR, but it seems to report a value that will
        // cleanly divide the values into the appropriate subpixels.

        function roundOffsetsByDPR(_ref) {
          var x = _ref.x,
            y = _ref.y;
          var win = window;
          var dpr = win.devicePixelRatio || 1;
          return {
            x: round$1(x * dpr) / dpr || 0,
            y: round$1(y * dpr) / dpr || 0
          };
        }
        function mapToStyles(_ref2) {
          var _Object$assign2;
          var popper = _ref2.popper,
            popperRect = _ref2.popperRect,
            placement = _ref2.placement,
            variation = _ref2.variation,
            offsets = _ref2.offsets,
            position = _ref2.position,
            gpuAcceleration = _ref2.gpuAcceleration,
            adaptive = _ref2.adaptive,
            roundOffsets = _ref2.roundOffsets,
            isFixed = _ref2.isFixed;
          var _offsets$x = offsets.x,
            x = _offsets$x === void 0 ? 0 : _offsets$x,
            _offsets$y = offsets.y,
            y = _offsets$y === void 0 ? 0 : _offsets$y;
          var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
            x: x,
            y: y
          }) : {
            x: x,
            y: y
          };
          x = _ref3.x;
          y = _ref3.y;
          var hasX = offsets.hasOwnProperty('x');
          var hasY = offsets.hasOwnProperty('y');
          var sideX = left;
          var sideY = top;
          var win = window;
          if (adaptive) {
            var offsetParent = getOffsetParent(popper);
            var heightProp = 'clientHeight';
            var widthProp = 'clientWidth';
            if (offsetParent === getWindow(popper)) {
              offsetParent = getDocumentElement(popper);
              if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {
                heightProp = 'scrollHeight';
                widthProp = 'scrollWidth';
              }
            } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

            offsetParent = offsetParent;
            if (placement === top || (placement === left || placement === right) && variation === end) {
              sideY = bottom;
              var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :
              // $FlowFixMe[prop-missing]
              offsetParent[heightProp];
              y -= offsetY - popperRect.height;
              y *= gpuAcceleration ? 1 : -1;
            }
            if (placement === left || (placement === top || placement === bottom) && variation === end) {
              sideX = right;
              var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :
              // $FlowFixMe[prop-missing]
              offsetParent[widthProp];
              x -= offsetX - popperRect.width;
              x *= gpuAcceleration ? 1 : -1;
            }
          }
          var commonStyles = Object.assign({
            position: position
          }, adaptive && unsetSides);
          var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
            x: x,
            y: y
          }) : {
            x: x,
            y: y
          };
          x = _ref4.x;
          y = _ref4.y;
          if (gpuAcceleration) {
            var _Object$assign;
            return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
          }
          return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
        }
        function computeStyles(_ref5) {
          var state = _ref5.state,
            options = _ref5.options;
          var _options$gpuAccelerat = options.gpuAcceleration,
            gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
            _options$adaptive = options.adaptive,
            adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
            _options$roundOffsets = options.roundOffsets,
            roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
          var commonStyles = {
            placement: getBasePlacement(state.placement),
            variation: getVariation(state.placement),
            popper: state.elements.popper,
            popperRect: state.rects.popper,
            gpuAcceleration: gpuAcceleration,
            isFixed: state.options.strategy === 'fixed'
          };
          if (state.modifiersData.popperOffsets != null) {
            state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
              offsets: state.modifiersData.popperOffsets,
              position: state.options.strategy,
              adaptive: adaptive,
              roundOffsets: roundOffsets
            })));
          }
          if (state.modifiersData.arrow != null) {
            state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
              offsets: state.modifiersData.arrow,
              position: 'absolute',
              adaptive: false,
              roundOffsets: roundOffsets
            })));
          }
          state.attributes.popper = Object.assign({}, state.attributes.popper, {
            'data-popper-placement': state.placement
          });
        } // eslint-disable-next-line import/no-unused-modules

        var computeStyles$1 = {
          name: 'computeStyles',
          enabled: true,
          phase: 'beforeWrite',
          fn: computeStyles,
          data: {}
        };
        var passive = {
          passive: true
        };
        function effect(_ref) {
          var state = _ref.state,
            instance = _ref.instance,
            options = _ref.options;
          var _options$scroll = options.scroll,
            scroll = _options$scroll === void 0 ? true : _options$scroll,
            _options$resize = options.resize,
            resize = _options$resize === void 0 ? true : _options$resize;
          var window = getWindow(state.elements.popper);
          var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
          if (scroll) {
            scrollParents.forEach(function (scrollParent) {
              scrollParent.addEventListener('scroll', instance.update, passive);
            });
          }
          if (resize) {
            window.addEventListener('resize', instance.update, passive);
          }
          return function () {
            if (scroll) {
              scrollParents.forEach(function (scrollParent) {
                scrollParent.removeEventListener('scroll', instance.update, passive);
              });
            }
            if (resize) {
              window.removeEventListener('resize', instance.update, passive);
            }
          };
        } // eslint-disable-next-line import/no-unused-modules

        var eventListeners = {
          name: 'eventListeners',
          enabled: true,
          phase: 'write',
          fn: function fn() {},
          effect: effect,
          data: {}
        };
        var hash$1 = {
          left: 'right',
          right: 'left',
          bottom: 'top',
          top: 'bottom'
        };
        function getOppositePlacement(placement) {
          return placement.replace(/left|right|bottom|top/g, function (matched) {
            return hash$1[matched];
          });
        }
        var hash = {
          start: 'end',
          end: 'start'
        };
        function getOppositeVariationPlacement(placement) {
          return placement.replace(/start|end/g, function (matched) {
            return hash[matched];
          });
        }
        function getWindowScroll(node) {
          var win = getWindow(node);
          var scrollLeft = win.pageXOffset;
          var scrollTop = win.pageYOffset;
          return {
            scrollLeft: scrollLeft,
            scrollTop: scrollTop
          };
        }
        function getWindowScrollBarX(element) {
          // If <html> has a CSS width greater than the viewport, then this will be
          // incorrect for RTL.
          // Popper 1 is broken in this case and never had a bug report so let's assume
          // it's not an issue. I don't think anyone ever specifies width on <html>
          // anyway.
          // Browsers where the left scrollbar doesn't cause an issue report `0` for
          // this (e.g. Edge 2019, IE11, Safari)
          return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
        }
        function getViewportRect(element, strategy) {
          var win = getWindow(element);
          var html = getDocumentElement(element);
          var visualViewport = win.visualViewport;
          var width = html.clientWidth;
          var height = html.clientHeight;
          var x = 0;
          var y = 0;
          if (visualViewport) {
            width = visualViewport.width;
            height = visualViewport.height;
            var layoutViewport = isLayoutViewport();
            if (layoutViewport || !layoutViewport && strategy === 'fixed') {
              x = visualViewport.offsetLeft;
              y = visualViewport.offsetTop;
            }
          }
          return {
            width: width,
            height: height,
            x: x + getWindowScrollBarX(element),
            y: y
          };
        }

        // of the `<html>` and `<body>` rect bounds if horizontally scrollable

        function getDocumentRect(element) {
          var _element$ownerDocumen;
          var html = getDocumentElement(element);
          var winScroll = getWindowScroll(element);
          var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
          var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
          var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
          var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
          var y = -winScroll.scrollTop;
          if (getComputedStyle$1(body || html).direction === 'rtl') {
            x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
          }
          return {
            width: width,
            height: height,
            x: x,
            y: y
          };
        }
        function isScrollParent(element) {
          // Firefox wants us to check `-x` and `-y` variations as well
          var _getComputedStyle = getComputedStyle$1(element),
            overflow = _getComputedStyle.overflow,
            overflowX = _getComputedStyle.overflowX,
            overflowY = _getComputedStyle.overflowY;
          return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
        }
        function getScrollParent(node) {
          if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
            // $FlowFixMe[incompatible-return]: assume body is always available
            return node.ownerDocument.body;
          }
          if (isHTMLElement(node) && isScrollParent(node)) {
            return node;
          }
          return getScrollParent(getParentNode(node));
        }

        /*
        given a DOM element, return the list of all scroll parents, up the list of ancesors
        until we get to the top window object. This list is what we attach scroll listeners
        to, because if any of these parent elements scroll, we'll need to re-calculate the
        reference element's position.
        */

        function listScrollParents(element, list) {
          var _element$ownerDocumen;
          if (list === void 0) {
            list = [];
          }
          var scrollParent = getScrollParent(element);
          var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
          var win = getWindow(scrollParent);
          var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
          var updatedList = list.concat(target);
          return isBody ? updatedList :
          // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
          updatedList.concat(listScrollParents(getParentNode(target)));
        }
        function rectToClientRect(rect) {
          return Object.assign({}, rect, {
            left: rect.x,
            top: rect.y,
            right: rect.x + rect.width,
            bottom: rect.y + rect.height
          });
        }
        function getInnerBoundingClientRect(element, strategy) {
          var rect = getBoundingClientRect(element, false, strategy === 'fixed');
          rect.top = rect.top + element.clientTop;
          rect.left = rect.left + element.clientLeft;
          rect.bottom = rect.top + element.clientHeight;
          rect.right = rect.left + element.clientWidth;
          rect.width = element.clientWidth;
          rect.height = element.clientHeight;
          rect.x = rect.left;
          rect.y = rect.top;
          return rect;
        }
        function getClientRectFromMixedType(element, clippingParent, strategy) {
          return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
        } // A "clipping parent" is an overflowable container with the characteristic of
        // clipping (or hiding) overflowing elements with a position different from
        // `initial`

        function getClippingParents(element) {
          var clippingParents = listScrollParents(getParentNode(element));
          var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
          var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
          if (!isElement$1(clipperElement)) {
            return [];
          } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414

          return clippingParents.filter(function (clippingParent) {
            return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
          });
        } // Gets the maximum area that the element is visible in due to any number of
        // clipping parents

        function getClippingRect(element, boundary, rootBoundary, strategy) {
          var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
          var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
          var firstClippingParent = clippingParents[0];
          var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
            var rect = getClientRectFromMixedType(element, clippingParent, strategy);
            accRect.top = max(rect.top, accRect.top);
            accRect.right = min(rect.right, accRect.right);
            accRect.bottom = min(rect.bottom, accRect.bottom);
            accRect.left = max(rect.left, accRect.left);
            return accRect;
          }, getClientRectFromMixedType(element, firstClippingParent, strategy));
          clippingRect.width = clippingRect.right - clippingRect.left;
          clippingRect.height = clippingRect.bottom - clippingRect.top;
          clippingRect.x = clippingRect.left;
          clippingRect.y = clippingRect.top;
          return clippingRect;
        }
        function computeOffsets(_ref) {
          var reference = _ref.reference,
            element = _ref.element,
            placement = _ref.placement;
          var basePlacement = placement ? getBasePlacement(placement) : null;
          var variation = placement ? getVariation(placement) : null;
          var commonX = reference.x + reference.width / 2 - element.width / 2;
          var commonY = reference.y + reference.height / 2 - element.height / 2;
          var offsets;
          switch (basePlacement) {
            case top:
              offsets = {
                x: commonX,
                y: reference.y - element.height
              };
              break;
            case bottom:
              offsets = {
                x: commonX,
                y: reference.y + reference.height
              };
              break;
            case right:
              offsets = {
                x: reference.x + reference.width,
                y: commonY
              };
              break;
            case left:
              offsets = {
                x: reference.x - element.width,
                y: commonY
              };
              break;
            default:
              offsets = {
                x: reference.x,
                y: reference.y
              };
          }
          var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
          if (mainAxis != null) {
            var len = mainAxis === 'y' ? 'height' : 'width';
            switch (variation) {
              case start:
                offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
                break;
              case end:
                offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
                break;
            }
          }
          return offsets;
        }
        function detectOverflow(state, options) {
          if (options === void 0) {
            options = {};
          }
          var _options = options,
            _options$placement = _options.placement,
            placement = _options$placement === void 0 ? state.placement : _options$placement,
            _options$strategy = _options.strategy,
            strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
            _options$boundary = _options.boundary,
            boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
            _options$rootBoundary = _options.rootBoundary,
            rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
            _options$elementConte = _options.elementContext,
            elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
            _options$altBoundary = _options.altBoundary,
            altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
            _options$padding = _options.padding,
            padding = _options$padding === void 0 ? 0 : _options$padding;
          var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
          var altContext = elementContext === popper ? reference : popper;
          var popperRect = state.rects.popper;
          var element = state.elements[altBoundary ? altContext : elementContext];
          var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
          var referenceClientRect = getBoundingClientRect(state.elements.reference);
          var popperOffsets = computeOffsets({
            reference: referenceClientRect,
            element: popperRect,
            strategy: 'absolute',
            placement: placement
          });
          var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
          var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
          // 0 or negative = within the clipping rect

          var overflowOffsets = {
            top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
            bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
            left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
            right: elementClientRect.right - clippingClientRect.right + paddingObject.right
          };
          var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

          if (elementContext === popper && offsetData) {
            var offset = offsetData[placement];
            Object.keys(overflowOffsets).forEach(function (key) {
              var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
              var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
              overflowOffsets[key] += offset[axis] * multiply;
            });
          }
          return overflowOffsets;
        }
        function computeAutoPlacement(state, options) {
          if (options === void 0) {
            options = {};
          }
          var _options = options,
            placement = _options.placement,
            boundary = _options.boundary,
            rootBoundary = _options.rootBoundary,
            padding = _options.padding,
            flipVariations = _options.flipVariations,
            _options$allowedAutoP = _options.allowedAutoPlacements,
            allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
          var variation = getVariation(placement);
          var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
            return getVariation(placement) === variation;
          }) : basePlacements;
          var allowedPlacements = placements$1.filter(function (placement) {
            return allowedAutoPlacements.indexOf(placement) >= 0;
          });
          if (allowedPlacements.length === 0) {
            allowedPlacements = placements$1;
          } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...

          var overflows = allowedPlacements.reduce(function (acc, placement) {
            acc[placement] = detectOverflow(state, {
              placement: placement,
              boundary: boundary,
              rootBoundary: rootBoundary,
              padding: padding
            })[getBasePlacement(placement)];
            return acc;
          }, {});
          return Object.keys(overflows).sort(function (a, b) {
            return overflows[a] - overflows[b];
          });
        }
        function getExpandedFallbackPlacements(placement) {
          if (getBasePlacement(placement) === auto) {
            return [];
          }
          var oppositePlacement = getOppositePlacement(placement);
          return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
        }
        function flip(_ref) {
          var state = _ref.state,
            options = _ref.options,
            name = _ref.name;
          if (state.modifiersData[name]._skip) {
            return;
          }
          var _options$mainAxis = options.mainAxis,
            checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
            _options$altAxis = options.altAxis,
            checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
            specifiedFallbackPlacements = options.fallbackPlacements,
            padding = options.padding,
            boundary = options.boundary,
            rootBoundary = options.rootBoundary,
            altBoundary = options.altBoundary,
            _options$flipVariatio = options.flipVariations,
            flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
            allowedAutoPlacements = options.allowedAutoPlacements;
          var preferredPlacement = state.options.placement;
          var basePlacement = getBasePlacement(preferredPlacement);
          var isBasePlacement = basePlacement === preferredPlacement;
          var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
          var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
            return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
              placement: placement,
              boundary: boundary,
              rootBoundary: rootBoundary,
              padding: padding,
              flipVariations: flipVariations,
              allowedAutoPlacements: allowedAutoPlacements
            }) : placement);
          }, []);
          var referenceRect = state.rects.reference;
          var popperRect = state.rects.popper;
          var checksMap = new Map();
          var makeFallbackChecks = true;
          var firstFittingPlacement = placements[0];
          for (var i = 0; i < placements.length; i++) {
            var placement = placements[i];
            var _basePlacement = getBasePlacement(placement);
            var isStartVariation = getVariation(placement) === start;
            var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
            var len = isVertical ? 'width' : 'height';
            var overflow = detectOverflow(state, {
              placement: placement,
              boundary: boundary,
              rootBoundary: rootBoundary,
              altBoundary: altBoundary,
              padding: padding
            });
            var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
            if (referenceRect[len] > popperRect[len]) {
              mainVariationSide = getOppositePlacement(mainVariationSide);
            }
            var altVariationSide = getOppositePlacement(mainVariationSide);
            var checks = [];
            if (checkMainAxis) {
              checks.push(overflow[_basePlacement] <= 0);
            }
            if (checkAltAxis) {
              checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
            }
            if (checks.every(function (check) {
              return check;
            })) {
              firstFittingPlacement = placement;
              makeFallbackChecks = false;
              break;
            }
            checksMap.set(placement, checks);
          }
          if (makeFallbackChecks) {
            // `2` may be desired in some cases – research later
            var numberOfChecks = flipVariations ? 3 : 1;
            var _loop = function _loop(_i) {
              var fittingPlacement = placements.find(function (placement) {
                var checks = checksMap.get(placement);
                if (checks) {
                  return checks.slice(0, _i).every(function (check) {
                    return check;
                  });
                }
              });
              if (fittingPlacement) {
                firstFittingPlacement = fittingPlacement;
                return "break";
              }
            };
            for (var _i = numberOfChecks; _i > 0; _i--) {
              var _ret = _loop(_i);
              if (_ret === "break") break;
            }
          }
          if (state.placement !== firstFittingPlacement) {
            state.modifiersData[name]._skip = true;
            state.placement = firstFittingPlacement;
            state.reset = true;
          }
        } // eslint-disable-next-line import/no-unused-modules

        var flip$1 = {
          name: 'flip',
          enabled: true,
          phase: 'main',
          fn: flip,
          requiresIfExists: ['offset'],
          data: {
            _skip: false
          }
        };
        function getSideOffsets(overflow, rect, preventedOffsets) {
          if (preventedOffsets === void 0) {
            preventedOffsets = {
              x: 0,
              y: 0
            };
          }
          return {
            top: overflow.top - rect.height - preventedOffsets.y,
            right: overflow.right - rect.width + preventedOffsets.x,
            bottom: overflow.bottom - rect.height + preventedOffsets.y,
            left: overflow.left - rect.width - preventedOffsets.x
          };
        }
        function isAnySideFullyClipped(overflow) {
          return [top, right, bottom, left].some(function (side) {
            return overflow[side] >= 0;
          });
        }
        function hide(_ref) {
          var state = _ref.state,
            name = _ref.name;
          var referenceRect = state.rects.reference;
          var popperRect = state.rects.popper;
          var preventedOffsets = state.modifiersData.preventOverflow;
          var referenceOverflow = detectOverflow(state, {
            elementContext: 'reference'
          });
          var popperAltOverflow = detectOverflow(state, {
            altBoundary: true
          });
          var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
          var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
          var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
          var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
          state.modifiersData[name] = {
            referenceClippingOffsets: referenceClippingOffsets,
            popperEscapeOffsets: popperEscapeOffsets,
            isReferenceHidden: isReferenceHidden,
            hasPopperEscaped: hasPopperEscaped
          };
          state.attributes.popper = Object.assign({}, state.attributes.popper, {
            'data-popper-reference-hidden': isReferenceHidden,
            'data-popper-escaped': hasPopperEscaped
          });
        } // eslint-disable-next-line import/no-unused-modules

        var hide$1 = {
          name: 'hide',
          enabled: true,
          phase: 'main',
          requiresIfExists: ['preventOverflow'],
          fn: hide
        };
        function distanceAndSkiddingToXY(placement, rects, offset) {
          var basePlacement = getBasePlacement(placement);
          var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
          var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
              placement: placement
            })) : offset,
            skidding = _ref[0],
            distance = _ref[1];
          skidding = skidding || 0;
          distance = (distance || 0) * invertDistance;
          return [left, right].indexOf(basePlacement) >= 0 ? {
            x: distance,
            y: skidding
          } : {
            x: skidding,
            y: distance
          };
        }
        function offset(_ref2) {
          var state = _ref2.state,
            options = _ref2.options,
            name = _ref2.name;
          var _options$offset = options.offset,
            offset = _options$offset === void 0 ? [0, 0] : _options$offset;
          var data = placements.reduce(function (acc, placement) {
            acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
            return acc;
          }, {});
          var _data$state$placement = data[state.placement],
            x = _data$state$placement.x,
            y = _data$state$placement.y;
          if (state.modifiersData.popperOffsets != null) {
            state.modifiersData.popperOffsets.x += x;
            state.modifiersData.popperOffsets.y += y;
          }
          state.modifiersData[name] = data;
        } // eslint-disable-next-line import/no-unused-modules

        var offset$1 = {
          name: 'offset',
          enabled: true,
          phase: 'main',
          requires: ['popperOffsets'],
          fn: offset
        };
        function popperOffsets(_ref) {
          var state = _ref.state,
            name = _ref.name;
          // Offsets are the actual position the popper needs to have to be
          // properly positioned near its reference element
          // This is the most basic placement, and will be adjusted by
          // the modifiers in the next step
          state.modifiersData[name] = computeOffsets({
            reference: state.rects.reference,
            element: state.rects.popper,
            strategy: 'absolute',
            placement: state.placement
          });
        } // eslint-disable-next-line import/no-unused-modules

        var popperOffsets$1 = {
          name: 'popperOffsets',
          enabled: true,
          phase: 'read',
          fn: popperOffsets,
          data: {}
        };
        function getAltAxis(axis) {
          return axis === 'x' ? 'y' : 'x';
        }
        function preventOverflow(_ref) {
          var state = _ref.state,
            options = _ref.options,
            name = _ref.name;
          var _options$mainAxis = options.mainAxis,
            checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
            _options$altAxis = options.altAxis,
            checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
            boundary = options.boundary,
            rootBoundary = options.rootBoundary,
            altBoundary = options.altBoundary,
            padding = options.padding,
            _options$tether = options.tether,
            tether = _options$tether === void 0 ? true : _options$tether,
            _options$tetherOffset = options.tetherOffset,
            tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
          var overflow = detectOverflow(state, {
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding,
            altBoundary: altBoundary
          });
          var basePlacement = getBasePlacement(state.placement);
          var variation = getVariation(state.placement);
          var isBasePlacement = !variation;
          var mainAxis = getMainAxisFromPlacement(basePlacement);
          var altAxis = getAltAxis(mainAxis);
          var popperOffsets = state.modifiersData.popperOffsets;
          var referenceRect = state.rects.reference;
          var popperRect = state.rects.popper;
          var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
            placement: state.placement
          })) : tetherOffset;
          var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
            mainAxis: tetherOffsetValue,
            altAxis: tetherOffsetValue
          } : Object.assign({
            mainAxis: 0,
            altAxis: 0
          }, tetherOffsetValue);
          var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
          var data = {
            x: 0,
            y: 0
          };
          if (!popperOffsets) {
            return;
          }
          if (checkMainAxis) {
            var _offsetModifierState$;
            var mainSide = mainAxis === 'y' ? top : left;
            var altSide = mainAxis === 'y' ? bottom : right;
            var len = mainAxis === 'y' ? 'height' : 'width';
            var offset = popperOffsets[mainAxis];
            var min$1 = offset + overflow[mainSide];
            var max$1 = offset - overflow[altSide];
            var additive = tether ? -popperRect[len] / 2 : 0;
            var minLen = variation === start ? referenceRect[len] : popperRect[len];
            var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
            // outside the reference bounds

            var arrowElement = state.elements.arrow;
            var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
              width: 0,
              height: 0
            };
            var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
            var arrowPaddingMin = arrowPaddingObject[mainSide];
            var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
            // to include its full size in the calculation. If the reference is small
            // and near the edge of a boundary, the popper can overflow even if the
            // reference is not overflowing as well (e.g. virtual elements with no
            // width or height)

            var arrowLen = within(0, referenceRect[len], arrowRect[len]);
            var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
            var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
            var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
            var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
            var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
            var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
            var tetherMax = offset + maxOffset - offsetModifierValue;
            var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
            popperOffsets[mainAxis] = preventedOffset;
            data[mainAxis] = preventedOffset - offset;
          }
          if (checkAltAxis) {
            var _offsetModifierState$2;
            var _mainSide = mainAxis === 'x' ? top : left;
            var _altSide = mainAxis === 'x' ? bottom : right;
            var _offset = popperOffsets[altAxis];
            var _len = altAxis === 'y' ? 'height' : 'width';
            var _min = _offset + overflow[_mainSide];
            var _max = _offset - overflow[_altSide];
            var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
            var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
            var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
            var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
            var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
            popperOffsets[altAxis] = _preventedOffset;
            data[altAxis] = _preventedOffset - _offset;
          }
          state.modifiersData[name] = data;
        } // eslint-disable-next-line import/no-unused-modules

        var preventOverflow$1 = {
          name: 'preventOverflow',
          enabled: true,
          phase: 'main',
          fn: preventOverflow,
          requiresIfExists: ['offset']
        };
        function getHTMLElementScroll(element) {
          return {
            scrollLeft: element.scrollLeft,
            scrollTop: element.scrollTop
          };
        }
        function getNodeScroll(node) {
          if (node === getWindow(node) || !isHTMLElement(node)) {
            return getWindowScroll(node);
          } else {
            return getHTMLElementScroll(node);
          }
        }
        function isElementScaled(element) {
          var rect = element.getBoundingClientRect();
          var scaleX = round$1(rect.width) / element.offsetWidth || 1;
          var scaleY = round$1(rect.height) / element.offsetHeight || 1;
          return scaleX !== 1 || scaleY !== 1;
        } // Returns the composite rect of an element relative to its offsetParent.
        // Composite means it takes into account transforms as well as layout.

        function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
          if (isFixed === void 0) {
            isFixed = false;
          }
          var isOffsetParentAnElement = isHTMLElement(offsetParent);
          var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
          var documentElement = getDocumentElement(offsetParent);
          var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
          var scroll = {
            scrollLeft: 0,
            scrollTop: 0
          };
          var offsets = {
            x: 0,
            y: 0
          };
          if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
            if (getNodeName(offsetParent) !== 'body' ||
            // https://github.com/popperjs/popper-core/issues/1078
            isScrollParent(documentElement)) {
              scroll = getNodeScroll(offsetParent);
            }
            if (isHTMLElement(offsetParent)) {
              offsets = getBoundingClientRect(offsetParent, true);
              offsets.x += offsetParent.clientLeft;
              offsets.y += offsetParent.clientTop;
            } else if (documentElement) {
              offsets.x = getWindowScrollBarX(documentElement);
            }
          }
          return {
            x: rect.left + scroll.scrollLeft - offsets.x,
            y: rect.top + scroll.scrollTop - offsets.y,
            width: rect.width,
            height: rect.height
          };
        }
        function order(modifiers) {
          var map = new Map();
          var visited = new Set();
          var result = [];
          modifiers.forEach(function (modifier) {
            map.set(modifier.name, modifier);
          }); // On visiting object, check for its dependencies and visit them recursively

          function sort(modifier) {
            visited.add(modifier.name);
            var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
            requires.forEach(function (dep) {
              if (!visited.has(dep)) {
                var depModifier = map.get(dep);
                if (depModifier) {
                  sort(depModifier);
                }
              }
            });
            result.push(modifier);
          }
          modifiers.forEach(function (modifier) {
            if (!visited.has(modifier.name)) {
              // check for visited object
              sort(modifier);
            }
          });
          return result;
        }
        function orderModifiers(modifiers) {
          // order based on dependencies
          var orderedModifiers = order(modifiers); // order based on phase

          return modifierPhases.reduce(function (acc, phase) {
            return acc.concat(orderedModifiers.filter(function (modifier) {
              return modifier.phase === phase;
            }));
          }, []);
        }
        function debounce(fn) {
          var pending;
          return function () {
            if (!pending) {
              pending = new Promise(function (resolve) {
                Promise.resolve().then(function () {
                  pending = undefined;
                  resolve(fn());
                });
              });
            }
            return pending;
          };
        }
        function mergeByName(modifiers) {
          var merged = modifiers.reduce(function (merged, current) {
            var existing = merged[current.name];
            merged[current.name] = existing ? Object.assign({}, existing, current, {
              options: Object.assign({}, existing.options, current.options),
              data: Object.assign({}, existing.data, current.data)
            }) : current;
            return merged;
          }, {}); // IE11 does not support Object.values

          return Object.keys(merged).map(function (key) {
            return merged[key];
          });
        }
        var DEFAULT_OPTIONS = {
          placement: 'bottom',
          modifiers: [],
          strategy: 'absolute'
        };
        function areValidElements() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return !args.some(function (element) {
            return !(element && typeof element.getBoundingClientRect === 'function');
          });
        }
        function popperGenerator(generatorOptions) {
          if (generatorOptions === void 0) {
            generatorOptions = {};
          }
          var _generatorOptions = generatorOptions,
            _generatorOptions$def = _generatorOptions.defaultModifiers,
            defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
            _generatorOptions$def2 = _generatorOptions.defaultOptions,
            defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
          return function createPopper(reference, popper, options) {
            if (options === void 0) {
              options = defaultOptions;
            }
            var state = {
              placement: 'bottom',
              orderedModifiers: [],
              options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
              modifiersData: {},
              elements: {
                reference: reference,
                popper: popper
              },
              attributes: {},
              styles: {}
            };
            var effectCleanupFns = [];
            var isDestroyed = false;
            var instance = {
              state: state,
              setOptions: function setOptions(setOptionsAction) {
                var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
                cleanupModifierEffects();
                state.options = Object.assign({}, defaultOptions, state.options, options);
                state.scrollParents = {
                  reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
                  popper: listScrollParents(popper)
                }; // Orders the modifiers based on their dependencies and `phase`
                // properties

                var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

                state.orderedModifiers = orderedModifiers.filter(function (m) {
                  return m.enabled;
                }); // Validate the provided modifiers so that the consumer will get warned

                runModifierEffects();
                return instance.update();
              },
              // Sync update – it will always be executed, even if not necessary. This
              // is useful for low frequency updates where sync behavior simplifies the
              // logic.
              // For high frequency updates (e.g. `resize` and `scroll` events), always
              // prefer the async Popper#update method
              forceUpdate: function forceUpdate() {
                if (isDestroyed) {
                  return;
                }
                var _state$elements = state.elements,
                  reference = _state$elements.reference,
                  popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
                // anymore

                if (!areValidElements(reference, popper)) {
                  return;
                } // Store the reference and popper rects to be read by modifiers

                state.rects = {
                  reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
                  popper: getLayoutRect(popper)
                }; // Modifiers have the ability to reset the current update cycle. The
                // most common use case for this is the `flip` modifier changing the
                // placement, which then needs to re-run all the modifiers, because the
                // logic was previously ran for the previous placement and is therefore
                // stale/incorrect

                state.reset = false;
                state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
                // is filled with the initial data specified by the modifier. This means
                // it doesn't persist and is fresh on each update.
                // To ensure persistent data, use `${name}#persistent`

                state.orderedModifiers.forEach(function (modifier) {
                  return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                });
                for (var index = 0; index < state.orderedModifiers.length; index++) {
                  if (state.reset === true) {
                    state.reset = false;
                    index = -1;
                    continue;
                  }
                  var _state$orderedModifie = state.orderedModifiers[index],
                    fn = _state$orderedModifie.fn,
                    _state$orderedModifie2 = _state$orderedModifie.options,
                    _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                    name = _state$orderedModifie.name;
                  if (typeof fn === 'function') {
                    state = fn({
                      state: state,
                      options: _options,
                      name: name,
                      instance: instance
                    }) || state;
                  }
                }
              },
              // Async and optimistically optimized update – it will not be executed if
              // not necessary (debounced to run at most once-per-tick)
              update: debounce(function () {
                return new Promise(function (resolve) {
                  instance.forceUpdate();
                  resolve(state);
                });
              }),
              destroy: function destroy() {
                cleanupModifierEffects();
                isDestroyed = true;
              }
            };
            if (!areValidElements(reference, popper)) {
              return instance;
            }
            instance.setOptions(options).then(function (state) {
              if (!isDestroyed && options.onFirstUpdate) {
                options.onFirstUpdate(state);
              }
            }); // Modifiers have the ability to execute arbitrary code before the first
            // update cycle runs. They will be executed in the same order as the update
            // cycle. This is useful when a modifier adds some persistent data that
            // other modifiers need to use, but the modifier is run after the dependent
            // one.

            function runModifierEffects() {
              state.orderedModifiers.forEach(function (_ref3) {
                var name = _ref3.name,
                  _ref3$options = _ref3.options,
                  options = _ref3$options === void 0 ? {} : _ref3$options,
                  effect = _ref3.effect;
                if (typeof effect === 'function') {
                  var cleanupFn = effect({
                    state: state,
                    name: name,
                    instance: instance,
                    options: options
                  });
                  var noopFn = function noopFn() {};
                  effectCleanupFns.push(cleanupFn || noopFn);
                }
              });
            }
            function cleanupModifierEffects() {
              effectCleanupFns.forEach(function (fn) {
                return fn();
              });
              effectCleanupFns = [];
            }
            return instance;
          };
        }
        var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
        var createPopper = /*#__PURE__*/popperGenerator({
          defaultModifiers: defaultModifiers
        }); // eslint-disable-next-line import/no-unused-modules

        var Tooltip_svelte_svelte_type_style_lang = '';

        /* src/lib/Tooltip.svelte generated by Svelte v3.55.0 */

        function create_fragment$3(ctx) {
          var div1;
          var t0;
          var t1;
          var div0;
          return {
            c: function c() {
              div1 = element("div");
              t0 = text( /*text*/ctx[0]);
              t1 = space();
              div0 = element("div");
              attr(div0, "id", "arrow");
              attr(div0, "data-popper-arrow", "");
              attr(div0, "class", "svelte-1qky7dz");
              attr(div1, "id", "tooltip");
              attr(div1, "role", "tooltip");
              attr(div1, "class", "z-50 svelte-1qky7dz");
            },
            m: function m(target, anchor) {
              insert(target, div1, anchor);
              append(div1, t0);
              append(div1, t1);
              append(div1, div0);
              /*div1_binding*/
              ctx[2](div1);
            },
            p: function p(ctx, _ref56) {
              var _ref57 = _slicedToArray(_ref56, 1),
                dirty = _ref57[0];
              if (dirty & /*text*/1) set_data(t0, /*text*/ctx[0]);
            },
            i: noop,
            o: noop,
            d: function d(detaching) {
              if (detaching) detach(div1);
              /*div1_binding*/
              ctx[2](null);
            }
          };
        }
        function instance$3($$self, $$props, $$invalidate) {
          var text = $$props.text;
          var tooltip;
          var tooltipPopper = null;
          var parentNode = null;
          function show() {
            if (!tooltipPopper && tooltip) {
              tooltipPopper = createPopper(parentNode, tooltip, {
                modifiers: [{
                  name: 'offset',
                  options: {
                    offset: [0, 8]
                  }
                }],
                placement: 'bottom'
              });
            }
            tooltip.setAttribute('data-show', '');
          }
          function hide() {
            tooltip.removeAttribute('data-show');
          }
          onMount(function () {
            parentNode = tooltip.parentElement;
            parentNode.addEventListener('mouseenter', show);
            parentNode.addEventListener('mouseleave', hide);
          });
          onDestroy(function () {
            parentNode.removeEventListener('mouseenter', show);
            parentNode.removeEventListener('mouseleave', hide);
          });
          function div1_binding($$value) {
            binding_callbacks[$$value ? 'unshift' : 'push'](function () {
              tooltip = $$value;
              $$invalidate(1, tooltip);
            });
          }
          $$self.$$set = function ($$props) {
            if ('text' in $$props) $$invalidate(0, text = $$props.text);
          };
          return [text, tooltip, div1_binding];
        }
        var Tooltip = /*#__PURE__*/function (_SvelteComponent6) {
          _inherits(Tooltip, _SvelteComponent6);
          var _super14 = _createSuper(Tooltip);
          function Tooltip(options) {
            var _this36;
            _classCallCheck(this, Tooltip);
            _this36 = _super14.call(this);
            init$1(_assertThisInitialized2(_this36), options, instance$3, create_fragment$3, safe_not_equal, {
              text: 0
            });
            return _this36;
          }
          return _createClass(Tooltip);
        }(SvelteComponent);
        var Popover_svelte_svelte_type_style_lang = '';

        /* src/lib/Popover.svelte generated by Svelte v3.55.0 */

        function create_fragment$2(ctx) {
          var div1;
          var t0;
          var t1;
          var div0;
          return {
            c: function c() {
              div1 = element("div");
              t0 = text( /*text*/ctx[0]);
              t1 = space();
              div0 = element("div");
              attr(div0, "id", "arrow");
              attr(div0, "data-popper-arrow", "");
              attr(div0, "class", "svelte-1hel9pb");
              attr(div1, "id", "popover");
              attr(div1, "role", "tooltip");
              attr(div1, "class", "z-50 svelte-1hel9pb");
            },
            m: function m(target, anchor) {
              insert(target, div1, anchor);
              append(div1, t0);
              append(div1, t1);
              append(div1, div0);
              /*div1_binding*/
              ctx[2](div1);
            },
            p: function p(ctx, _ref58) {
              var _ref59 = _slicedToArray(_ref58, 1),
                dirty = _ref59[0];
              if (dirty & /*text*/1) set_data(t0, /*text*/ctx[0]);
            },
            i: noop,
            o: noop,
            d: function d(detaching) {
              if (detaching) detach(div1);
              /*div1_binding*/
              ctx[2](null);
            }
          };
        }
        function instance$2($$self, $$props, $$invalidate) {
          var text = $$props.text;
          var popover;
          var popoverPopper = null;
          var parentNode = null;
          var timeout = null;
          function show() {
            if (!popoverPopper && popover) {
              popoverPopper = createPopper(parentNode, popover, {
                modifiers: [{
                  name: 'offset',
                  options: {
                    offset: [0, 8]
                  }
                }],
                placement: 'top'
              });
            }
            popover.setAttribute('data-show', '');
            if (timeout) {
              clearTimeout(timeout);
            }
            timeout = setTimeout(function () {
              popover.removeAttribute('data-show');
            }, 1000);
          }
          onMount(function () {
            parentNode = popover.parentElement;
            parentNode.addEventListener('click', show);
          });
          onDestroy(function () {
            parentNode.removeEventListener('click', show);
          });
          function div1_binding($$value) {
            binding_callbacks[$$value ? 'unshift' : 'push'](function () {
              popover = $$value;
              $$invalidate(1, popover);
            });
          }
          $$self.$$set = function ($$props) {
            if ('text' in $$props) $$invalidate(0, text = $$props.text);
          };
          return [text, popover, div1_binding];
        }
        var Popover = /*#__PURE__*/function (_SvelteComponent7) {
          _inherits(Popover, _SvelteComponent7);
          var _super15 = _createSuper(Popover);
          function Popover(options) {
            var _this37;
            _classCallCheck(this, Popover);
            _this37 = _super15.call(this);
            init$1(_assertThisInitialized2(_this37), options, instance$2, create_fragment$2, safe_not_equal, {
              text: 0
            });
            return _this37;
          }
          return _createClass(Popover);
        }(SvelteComponent);
        /* src/lib/Logger.svelte generated by Svelte v3.55.0 */
        function get_each_context$1(ctx, list, i) {
          var child_ctx = ctx.slice();
          child_ctx[6] = list[i];
          return child_ctx;
        }

        // (30:6) {#each log.toArray() as logLine}
        function create_each_block$1(ctx) {
          var div;
          var t_value = /*logLine*/ctx[6] + "";
          var t;
          return {
            c: function c() {
              div = element("div");
              t = text(t_value);
              attr(div, "class", "text-xs text-left font-mono border border-b-1 border-t-0 border-l-0 border-r-0");
            },
            m: function m(target, anchor) {
              insert(target, div, anchor);
              append(div, t);
            },
            p: function p(ctx, dirty) {
              if (dirty & /*log*/1 && t_value !== (t_value = /*logLine*/ctx[6] + "")) set_data(t, t_value);
            },
            d: function d(detaching) {
              if (detaching) detach(div);
            }
          };
        }
        function create_fragment$1(ctx) {
          var div;
          var each_value = /*log*/ctx[0].toArray();
          var each_blocks = [];
          for (var _i29 = 0; _i29 < each_value.length; _i29 += 1) {
            each_blocks[_i29] = create_each_block$1(get_each_context$1(ctx, each_value, _i29));
          }
          return {
            c: function c() {
              div = element("div");
              for (var _i30 = 0; _i30 < each_blocks.length; _i30 += 1) {
                each_blocks[_i30].c();
              }
              attr(div, "class", "fixed w-full sm:w-1/2 md:w-2/3 lg:w-3/4 h-1/4 bg-white bottom-0 p-1 overflow-y-scroll");
            },
            m: function m(target, anchor) {
              insert(target, div, anchor);
              for (var _i31 = 0; _i31 < each_blocks.length; _i31 += 1) {
                each_blocks[_i31].m(div, null);
              }

              /*div_binding*/
              ctx[4](div);
            },
            p: function p(ctx, _ref60) {
              var _ref61 = _slicedToArray(_ref60, 1),
                dirty = _ref61[0];
              if (dirty & /*log*/1) {
                each_value = /*log*/ctx[0].toArray();
                var _i32;
                for (_i32 = 0; _i32 < each_value.length; _i32 += 1) {
                  var child_ctx = get_each_context$1(ctx, each_value, _i32);
                  if (each_blocks[_i32]) {
                    each_blocks[_i32].p(child_ctx, dirty);
                  } else {
                    each_blocks[_i32] = create_each_block$1(child_ctx);
                    each_blocks[_i32].c();
                    each_blocks[_i32].m(div, null);
                  }
                }
                for (; _i32 < each_blocks.length; _i32 += 1) {
                  each_blocks[_i32].d(1);
                }
                each_blocks.length = each_value.length;
              }
            },
            i: noop,
            o: noop,
            d: function d(detaching) {
              if (detaching) detach(div);
              destroy_each(each_blocks, detaching);
              /*div_binding*/
              ctx[4](null);
            }
          };
        }
        function instance$1($$self, $$props, $$invalidate) {
          var _$$props$capacity = $$props.capacity,
            capacity = _$$props$capacity === void 0 ? 1000 : _$$props$capacity;
          var log = new deque(capacity);
          function addLine(text) {
            log.push(text);
            if (log.length > capacity) {
              log.unshift();
            }
            $$invalidate(0, log);
          }
          var loggerDiv;
          var autoscroll;
          beforeUpdate(function () {
            autoscroll = loggerDiv && loggerDiv.offsetHeight + loggerDiv.scrollTop > loggerDiv.scrollHeight - 20;
          });
          afterUpdate(function () {
            if (autoscroll) loggerDiv.scrollTo(0, loggerDiv.scrollHeight);
          });
          function div_binding($$value) {
            binding_callbacks[$$value ? 'unshift' : 'push'](function () {
              loggerDiv = $$value;
              $$invalidate(1, loggerDiv);
            });
          }
          $$self.$$set = function ($$props) {
            if ('capacity' in $$props) $$invalidate(2, capacity = $$props.capacity);
          };
          return [log, loggerDiv, capacity, addLine, div_binding];
        }
        var Logger = /*#__PURE__*/function (_SvelteComponent8) {
          _inherits(Logger, _SvelteComponent8);
          var _super16 = _createSuper(Logger);
          function Logger(options) {
            var _this38;
            _classCallCheck(this, Logger);
            _this38 = _super16.call(this);
            init$1(_assertThisInitialized2(_this38), options, instance$1, create_fragment$1, safe_not_equal, {
              capacity: 2,
              addLine: 3
            });
            return _this38;
          }
          _createClass(Logger, [{
            key: "addLine",
            get: function get() {
              return this.$$.ctx[3];
            }
          }]);
          return Logger;
        }(SvelteComponent);
        /*! Hammer.JS - v2.0.17-rc - 2019-12-16
         * http://naver.github.io/egjs
         *
         * Forked By Naver egjs
         * Copyright (c) hammerjs
         * Licensed under the MIT license */
        function _extends() {
          _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          return _extends.apply(this, arguments);
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        function _assertThisInitialized(self) {
          if (self === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self;
        }

        /**
         * @private
         * extend object.
         * means that properties in dest will be overwritten by the ones in src.
         * @param {Object} target
         * @param {...Object} objects_to_assign
         * @returns {Object} target
         */
        var assign$1;
        if (typeof Object.assign !== 'function') {
          assign$1 = function assign(target) {
            if (target === undefined || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
            }
            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
              var source = arguments[index];
              if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                  if (source.hasOwnProperty(nextKey)) {
                    output[nextKey] = source[nextKey];
                  }
                }
              }
            }
            return output;
          };
        } else {
          assign$1 = Object.assign;
        }
        var assign$1$1 = assign$1;
        var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
        var TEST_ELEMENT = typeof document === "undefined" ? {
          style: {}
        } : document.createElement('div');
        var TYPE_FUNCTION = 'function';
        var round = Math.round,
          abs = Math.abs;
        var now = Date.now;

        /**
         * @private
         * get the prefixed property
         * @param {Object} obj
         * @param {String} property
         * @returns {String|Undefined} prefixed
         */

        function prefixed(obj, property) {
          var prefix;
          var prop;
          var camelProp = property[0].toUpperCase() + property.slice(1);
          var i = 0;
          while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
              return prop;
            }
            i++;
          }
          return undefined;
        }

        /* eslint-disable no-new-func, no-nested-ternary */
        var win;
        if (typeof window === "undefined") {
          // window is undefined in node.js
          win = {};
        } else {
          win = window;
        }
        var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
        var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
        function getTouchActionProps() {
          if (!NATIVE_TOUCH_ACTION) {
            return false;
          }
          var touchMap = {};
          var cssSupports = win.CSS && win.CSS.supports;
          ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
            // If css.supports is not supported but there is native touch-action assume it supports
            // all values. This is the case for IE 10 and 11.
            return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;
          });
          return touchMap;
        }
        var TOUCH_ACTION_COMPUTE = 'compute';
        var TOUCH_ACTION_AUTO = 'auto';
        var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented

        var TOUCH_ACTION_NONE = 'none';
        var TOUCH_ACTION_PAN_X = 'pan-x';
        var TOUCH_ACTION_PAN_Y = 'pan-y';
        var TOUCH_ACTION_MAP = getTouchActionProps();
        var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
        var SUPPORT_TOUCH = ('ontouchstart' in win);
        var SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;
        var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
        var INPUT_TYPE_TOUCH = 'touch';
        var INPUT_TYPE_PEN = 'pen';
        var INPUT_TYPE_MOUSE = 'mouse';
        var INPUT_TYPE_KINECT = 'kinect';
        var COMPUTE_INTERVAL = 25;
        var INPUT_START = 1;
        var INPUT_MOVE = 2;
        var INPUT_END = 4;
        var INPUT_CANCEL = 8;
        var DIRECTION_NONE = 1;
        var DIRECTION_LEFT = 2;
        var DIRECTION_RIGHT = 4;
        var DIRECTION_UP = 8;
        var DIRECTION_DOWN = 16;
        var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
        var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
        var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
        var PROPS_XY = ['x', 'y'];
        var PROPS_CLIENT_XY = ['clientX', 'clientY'];

        /**
         * @private
         * walk objects and arrays
         * @param {Object} obj
         * @param {Function} iterator
         * @param {Object} context
         */
        function each(obj, iterator, context) {
          var i;
          if (!obj) {
            return;
          }
          if (obj.forEach) {
            obj.forEach(iterator, context);
          } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
              iterator.call(context, obj[i], i, obj);
              i++;
            }
          } else {
            for (i in obj) {
              obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
          }
        }

        /**
         * @private
         * let a boolean value also be a function that must return a boolean
         * this first item in args will be used as the context
         * @param {Boolean|Function} val
         * @param {Array} [args]
         * @returns {Boolean}
         */

        function boolOrFn(val, args) {
          if (_typeof(val) === TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
          }
          return val;
        }

        /**
         * @private
         * small indexOf wrapper
         * @param {String} str
         * @param {String} find
         * @returns {Boolean} found
         */
        function inStr(str, find) {
          return str.indexOf(find) > -1;
        }

        /**
         * @private
         * when the touchActions are collected they are not a valid value, so we need to clean things up. *
         * @param {String} actions
         * @returns {*}
         */

        function cleanTouchActions(actions) {
          // none
          if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
          }
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers
          // for different directions, e.g. horizontal pan but vertical swipe?)
          // we need none (as otherwise with pan-x pan-y combined none of these
          // recognizers will work, since the browser would handle all panning

          if (hasPanX && hasPanY) {
            return TOUCH_ACTION_NONE;
          } // pan-x OR pan-y

          if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
          } // manipulation

          if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
          }
          return TOUCH_ACTION_AUTO;
        }

        /**
         * @private
         * Touch Action
         * sets the touchAction property or uses the js alternative
         * @param {Manager} manager
         * @param {String} value
         * @constructor
         */

        var TouchAction = /*#__PURE__*/
        function () {
          function TouchAction(manager, value) {
            this.manager = manager;
            this.set(value);
          }
          /**
           * @private
           * set the touchAction value on the element or enable the polyfill
           * @param {String} value
           */

          var _proto = TouchAction.prototype;
          _proto.set = function set(value) {
            // find out the touch-action by the event handlers
            if (value === TOUCH_ACTION_COMPUTE) {
              value = this.compute();
            }
            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
              this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
          };
          /**
           * @private
           * just re-set the touchAction value
           */

          _proto.update = function update() {
            this.set(this.manager.options.touchAction);
          };
          /**
           * @private
           * compute the value for the touchAction property based on the recognizer's settings
           * @returns {String} value
           */

          _proto.compute = function compute() {
            var actions = [];
            each(this.manager.recognizers, function (recognizer) {
              if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
              }
            });
            return cleanTouchActions(actions.join(' '));
          };
          /**
           * @private
           * this method is called on each input cycle and provides the preventing of the browser behavior
           * @param {Object} input
           */

          _proto.preventDefaults = function preventDefaults(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection; // if the touch action did prevented once this session

            if (this.manager.session.prevented) {
              srcEvent.preventDefault();
              return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
            if (hasNone) {
              // do not prevent defaults if this is a tap gesture
              var isTapPointer = input.pointers.length === 1;
              var isTapMovement = input.distance < 2;
              var isTapTouchTime = input.deltaTime < 250;
              if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
              }
            }
            if (hasPanX && hasPanY) {
              // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
              return;
            }
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
              return this.preventSrc(srcEvent);
            }
          };
          /**
           * @private
           * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
           * @param {Object} srcEvent
           */

          _proto.preventSrc = function preventSrc(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
          };
          return TouchAction;
        }();

        /**
         * @private
         * find if a node is in the given parent
         * @method hasParent
         * @param {HTMLElement} node
         * @param {HTMLElement} parent
         * @return {Boolean} found
         */
        function hasParent(node, parent) {
          while (node) {
            if (node === parent) {
              return true;
            }
            node = node.parentNode;
          }
          return false;
        }

        /**
         * @private
         * get the center of all the pointers
         * @param {Array} pointers
         * @return {Object} center contains `x` and `y` properties
         */

        function getCenter(pointers) {
          var pointersLength = pointers.length; // no need to loop when only one touch

          if (pointersLength === 1) {
            return {
              x: round(pointers[0].clientX),
              y: round(pointers[0].clientY)
            };
          }
          var x = 0;
          var y = 0;
          var i = 0;
          while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
          }
          return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
          };
        }

        /**
         * @private
         * create a simple clone from the input used for storage of firstInput and firstMultiple
         * @param {Object} input
         * @returns {Object} clonedInputData
         */

        function simpleCloneInputData(input) {
          // make a simple copy of the pointers because we will get a reference if we don't
          // we only need clientXY for the calculations
          var pointers = [];
          var i = 0;
          while (i < input.pointers.length) {
            pointers[i] = {
              clientX: round(input.pointers[i].clientX),
              clientY: round(input.pointers[i].clientY)
            };
            i++;
          }
          return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
          };
        }

        /**
         * @private
         * calculate the absolute distance between two points
         * @param {Object} p1 {x, y}
         * @param {Object} p2 {x, y}
         * @param {Array} [props] containing x and y keys
         * @return {Number} distance
         */

        function getDistance(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x = p2[props[0]] - p1[props[0]];
          var y = p2[props[1]] - p1[props[1]];
          return Math.sqrt(x * x + y * y);
        }

        /**
         * @private
         * calculate the angle between two coordinates
         * @param {Object} p1
         * @param {Object} p2
         * @param {Array} [props] containing x and y keys
         * @return {Number} angle
         */

        function getAngle(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x = p2[props[0]] - p1[props[0]];
          var y = p2[props[1]] - p1[props[1]];
          return Math.atan2(y, x) * 180 / Math.PI;
        }

        /**
         * @private
         * get the direction between two points
         * @param {Number} x
         * @param {Number} y
         * @return {Number} direction
         */

        function getDirection(x, y) {
          if (x === y) {
            return DIRECTION_NONE;
          }
          if (abs(x) >= abs(y)) {
            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
          return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        }
        function computeDeltaXY(session, input) {
          var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;
          // jscs throwing error on defalut destructured values and without defaults tests fail

          var offset = session.offsetDelta || {};
          var prevDelta = session.prevDelta || {};
          var prevInput = session.prevInput || {};
          if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
              x: prevInput.deltaX || 0,
              y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
              x: center.x,
              y: center.y
            };
          }
          input.deltaX = prevDelta.x + (center.x - offset.x);
          input.deltaY = prevDelta.y + (center.y - offset.y);
        }

        /**
         * @private
         * calculate the velocity between two points. unit is in px per ms.
         * @param {Number} deltaTime
         * @param {Number} x
         * @param {Number} y
         * @return {Object} velocity `x` and `y`
         */
        function getVelocity(deltaTime, x, y) {
          return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
          };
        }

        /**
         * @private
         * calculate the scale factor between two pointersets
         * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
         * @param {Array} start array of pointers
         * @param {Array} end array of pointers
         * @return {Number} scale
         */

        function getScale(start, end) {
          return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
        }

        /**
         * @private
         * calculate the rotation degrees between two pointersets
         * @param {Array} start array of pointers
         * @param {Array} end array of pointers
         * @return {Number} rotation
         */

        function getRotation(start, end) {
          return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
        }

        /**
         * @private
         * velocity is calculated every x ms
         * @param {Object} session
         * @param {Object} input
         */

        function computeIntervalInputData(session, input) {
          var last = session.lastInterval || input;
          var deltaTime = input.timeStamp - last.timeStamp;
          var velocity;
          var velocityX;
          var velocityY;
          var direction;
          if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
          } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
          }
          input.velocity = velocity;
          input.velocityX = velocityX;
          input.velocityY = velocityY;
          input.direction = direction;
        }

        /**
        * @private
         * extend the data with some usable properties like scale, rotate, velocity etc
         * @param {Object} manager
         * @param {Object} input
         */

        function computeInputData(manager, input) {
          var session = manager.session;
          var pointers = input.pointers;
          var pointersLength = pointers.length; // store the first input to calculate the distance and direction

          if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
          } // to compute scale and rotation we need to store the multiple touches

          if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
          } else if (pointersLength === 1) {
            session.firstMultiple = false;
          }
          var firstInput = session.firstInput,
            firstMultiple = session.firstMultiple;
          var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
          var center = input.center = getCenter(pointers);
          input.timeStamp = now();
          input.deltaTime = input.timeStamp - firstInput.timeStamp;
          input.angle = getAngle(offsetCenter, center);
          input.distance = getDistance(offsetCenter, center);
          computeDeltaXY(session, input);
          input.offsetDirection = getDirection(input.deltaX, input.deltaY);
          var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
          input.overallVelocityX = overallVelocity.x;
          input.overallVelocityY = overallVelocity.y;
          input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
          input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
          input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
          input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
          computeIntervalInputData(session, input); // find the correct target

          var target = manager.element;
          var srcEvent = input.srcEvent;
          var srcEventTarget;
          if (srcEvent.composedPath) {
            srcEventTarget = srcEvent.composedPath()[0];
          } else if (srcEvent.path) {
            srcEventTarget = srcEvent.path[0];
          } else {
            srcEventTarget = srcEvent.target;
          }
          if (hasParent(srcEventTarget, target)) {
            target = srcEventTarget;
          }
          input.target = target;
        }

        /**
         * @private
         * handle input events
         * @param {Manager} manager
         * @param {String} eventType
         * @param {Object} input
         */

        function inputHandler(manager, eventType, input) {
          var pointersLen = input.pointers.length;
          var changedPointersLen = input.changedPointers.length;
          var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
          var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
          input.isFirst = !!isFirst;
          input.isFinal = !!isFinal;
          if (isFirst) {
            manager.session = {};
          } // source event is the normalized value of the domEvents
          // like 'touchstart, mouseup, pointerdown'

          input.eventType = eventType; // compute scale, rotation etc

          computeInputData(manager, input); // emit secret event

          manager.emit('hammer.input', input);
          manager.recognize(input);
          manager.session.prevInput = input;
        }

        /**
         * @private
         * split string on whitespace
         * @param {String} str
         * @returns {Array} words
         */
        function splitStr(str) {
          return str.trim().split(/\s+/g);
        }

        /**
         * @private
         * addEventListener with multiple events at once
         * @param {EventTarget} target
         * @param {String} types
         * @param {Function} handler
         */

        function addEventListeners(target, types, handler) {
          each(splitStr(types), function (type) {
            target.addEventListener(type, handler, false);
          });
        }

        /**
         * @private
         * removeEventListener with multiple events at once
         * @param {EventTarget} target
         * @param {String} types
         * @param {Function} handler
         */

        function removeEventListeners(target, types, handler) {
          each(splitStr(types), function (type) {
            target.removeEventListener(type, handler, false);
          });
        }

        /**
         * @private
         * get the window object of an element
         * @param {HTMLElement} element
         * @returns {DocumentView|Window}
         */
        function getWindowForElement(element) {
          var doc = element.ownerDocument || element;
          return doc.defaultView || doc.parentWindow || window;
        }

        /**
         * @private
         * create new input type manager
         * @param {Manager} manager
         * @param {Function} callback
         * @returns {Input}
         * @constructor
         */

        var Input = /*#__PURE__*/
        function () {
          function Input(manager, callback) {
            var self = this;
            this.manager = manager;
            this.callback = callback;
            this.element = manager.element;
            this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,
            // so when disabled the input events are completely bypassed.

            this.domHandler = function (ev) {
              if (boolOrFn(manager.options.enable, [manager])) {
                self.handler(ev);
              }
            };
            this.init();
          }
          /**
           * @private
           * should handle the inputEvent data and trigger the callback
           * @virtual
           */

          var _proto = Input.prototype;
          _proto.handler = function handler() {};
          /**
           * @private
           * bind the events
           */

          _proto.init = function init() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          };
          /**
           * @private
           * unbind the events
           */

          _proto.destroy = function destroy() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          };
          return Input;
        }();

        /**
         * @private
         * find if a array contains the object using indexOf or a simple polyFill
         * @param {Array} src
         * @param {String} find
         * @param {String} [findByKey]
         * @return {Boolean|Number} false when not found, or the index
         */
        function inArray(src, find, findByKey) {
          if (src.indexOf && !findByKey) {
            return src.indexOf(find);
          } else {
            var i = 0;
            while (i < src.length) {
              if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                // do not use === here, test fails
                return i;
              }
              i++;
            }
            return -1;
          }
        }
        var POINTER_INPUT_MAP = {
          pointerdown: INPUT_START,
          pointermove: INPUT_MOVE,
          pointerup: INPUT_END,
          pointercancel: INPUT_CANCEL,
          pointerout: INPUT_CANCEL
        }; // in IE10 the pointer types is defined as an enum

        var IE10_POINTER_TYPE_ENUM = {
          2: INPUT_TYPE_TOUCH,
          3: INPUT_TYPE_PEN,
          4: INPUT_TYPE_MOUSE,
          5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
        };

        var POINTER_ELEMENT_EVENTS = 'pointerdown';
        var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive

        if (win.MSPointerEvent && !win.PointerEvent) {
          POINTER_ELEMENT_EVENTS = 'MSPointerDown';
          POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
        }
        /**
         * @private
         * Pointer events input
         * @constructor
         * @extends Input
         */

        var PointerEventInput = /*#__PURE__*/
        function (_Input) {
          _inheritsLoose(PointerEventInput, _Input);
          function PointerEventInput() {
            var _this;
            var proto = PointerEventInput.prototype;
            proto.evEl = POINTER_ELEMENT_EVENTS;
            proto.evWin = POINTER_WINDOW_EVENTS;
            _this = _Input.apply(this, arguments) || this;
            _this.store = _this.manager.session.pointerEvents = [];
            return _this;
          }
          /**
           * @private
           * handle mouse events
           * @param {Object} ev
           */

          var _proto = PointerEventInput.prototype;
          _proto.handler = function handler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store

            var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down

            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
              if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
              }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
              removePointer = true;
            } // it not found, so the pointer hasn't been down (so it's probably a hover)

            if (storeIndex < 0) {
              return;
            } // update the event in the store

            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
              pointers: store,
              changedPointers: [ev],
              pointerType: pointerType,
              srcEvent: ev
            });
            if (removePointer) {
              // remove from the store
              store.splice(storeIndex, 1);
            }
          };
          return PointerEventInput;
        }(Input);

        /**
         * @private
         * convert array-like objects to real arrays
         * @param {Object} obj
         * @returns {Array}
         */
        function toArray(obj) {
          return Array.prototype.slice.call(obj, 0);
        }

        /**
         * @private
         * unique array with objects based on a key (like 'id') or just by the array's value
         * @param {Array} src [{id:1},{id:2},{id:1}]
         * @param {String} [key]
         * @param {Boolean} [sort=False]
         * @returns {Array} [{id:1},{id:2}]
         */

        function uniqueArray(src, key, sort) {
          var results = [];
          var values = [];
          var i = 0;
          while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
              results.push(src[i]);
            }
            values[i] = val;
            i++;
          }
          if (sort) {
            if (!key) {
              results = results.sort();
            } else {
              results = results.sort(function (a, b) {
                return a[key] > b[key];
              });
            }
          }
          return results;
        }
        var TOUCH_INPUT_MAP = {
          touchstart: INPUT_START,
          touchmove: INPUT_MOVE,
          touchend: INPUT_END,
          touchcancel: INPUT_CANCEL
        };
        var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
        /**
         * @private
         * Multi-user touch events input
         * @constructor
         * @extends Input
         */

        var TouchInput = /*#__PURE__*/
        function (_Input) {
          _inheritsLoose(TouchInput, _Input);
          function TouchInput() {
            var _this;
            TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;
            _this = _Input.apply(this, arguments) || this;
            _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;

            return _this;
          }
          var _proto = TouchInput.prototype;
          _proto.handler = function handler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
              return;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          };
          return TouchInput;
        }(Input);
        function getTouches(ev, type) {
          var allTouches = toArray(ev.touches);
          var targetIds = this.targetIds; // when there is only one touch, the process can be simplified

          if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
          }
          var i;
          var targetTouches;
          var changedTouches = toArray(ev.changedTouches);
          var changedTargetTouches = [];
          var target = this.target; // get target touches from touches

          targetTouches = allTouches.filter(function (touch) {
            return hasParent(touch.target, target);
          }); // collect touches

          if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
              targetIds[targetTouches[i].identifier] = true;
              i++;
            }
          } // filter changed touches to only contain touches that exist in the collected target ids

          i = 0;
          while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
              changedTargetTouches.push(changedTouches[i]);
            } // cleanup removed touches

            if (type & (INPUT_END | INPUT_CANCEL)) {
              delete targetIds[changedTouches[i].identifier];
            }
            i++;
          }
          if (!changedTargetTouches.length) {
            return;
          }
          return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
        }
        var MOUSE_INPUT_MAP = {
          mousedown: INPUT_START,
          mousemove: INPUT_MOVE,
          mouseup: INPUT_END
        };
        var MOUSE_ELEMENT_EVENTS = 'mousedown';
        var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
        /**
         * @private
         * Mouse events input
         * @constructor
         * @extends Input
         */

        var MouseInput = /*#__PURE__*/
        function (_Input) {
          _inheritsLoose(MouseInput, _Input);
          function MouseInput() {
            var _this;
            var proto = MouseInput.prototype;
            proto.evEl = MOUSE_ELEMENT_EVENTS;
            proto.evWin = MOUSE_WINDOW_EVENTS;
            _this = _Input.apply(this, arguments) || this;
            _this.pressed = false; // mousedown state

            return _this;
          }
          /**
           * @private
           * handle mouse events
           * @param {Object} ev
           */

          var _proto = MouseInput.prototype;
          _proto.handler = function handler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down

            if (eventType & INPUT_START && ev.button === 0) {
              this.pressed = true;
            }
            if (eventType & INPUT_MOVE && ev.which !== 1) {
              eventType = INPUT_END;
            } // mouse must be down

            if (!this.pressed) {
              return;
            }
            if (eventType & INPUT_END) {
              this.pressed = false;
            }
            this.callback(this.manager, eventType, {
              pointers: [ev],
              changedPointers: [ev],
              pointerType: INPUT_TYPE_MOUSE,
              srcEvent: ev
            });
          };
          return MouseInput;
        }(Input);

        /**
         * @private
         * Combined touch and mouse input
         *
         * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
         * This because touch devices also emit mouse events while doing a touch.
         *
         * @constructor
         * @extends Input
         */

        var DEDUP_TIMEOUT = 2500;
        var DEDUP_DISTANCE = 25;
        function setLastTouch(eventData) {
          var _eventData$changedPoi = eventData.changedPointers,
            touch = _eventData$changedPoi[0];
          if (touch.identifier === this.primaryTouch) {
            var lastTouch = {
              x: touch.clientX,
              y: touch.clientY
            };
            var lts = this.lastTouches;
            this.lastTouches.push(lastTouch);
            var removeLastTouch = function removeLastTouch() {
              var i = lts.indexOf(lastTouch);
              if (i > -1) {
                lts.splice(i, 1);
              }
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
          }
        }
        function recordTouches(eventType, eventData) {
          if (eventType & INPUT_START) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            setLastTouch.call(this, eventData);
          }
        }
        function isSyntheticEvent(eventData) {
          var x = eventData.srcEvent.clientX;
          var y = eventData.srcEvent.clientY;
          for (var i = 0; i < this.lastTouches.length; i++) {
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x);
            var dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
              return true;
            }
          }
          return false;
        }
        var TouchMouseInput = /*#__PURE__*/
        function () {
          var TouchMouseInput = /*#__PURE__*/
          function (_Input) {
            _inheritsLoose(TouchMouseInput, _Input);
            function TouchMouseInput(_manager, callback) {
              var _this;
              _this = _Input.call(this, _manager, callback) || this;
              _this.handler = function (manager, inputEvent, inputData) {
                var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;
                var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;
                if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
                  return;
                } // when we're in a touch event, record touches to  de-dupe synthetic mouse event

                if (isTouch) {
                  recordTouches.call(_assertThisInitialized(_assertThisInitialized(_this)), inputEvent, inputData);
                } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized(_assertThisInitialized(_this)), inputData)) {
                  return;
                }
                _this.callback(manager, inputEvent, inputData);
              };
              _this.touch = new TouchInput(_this.manager, _this.handler);
              _this.mouse = new MouseInput(_this.manager, _this.handler);
              _this.primaryTouch = null;
              _this.lastTouches = [];
              return _this;
            }
            /**
             * @private
             * handle mouse and touch events
             * @param {Hammer} manager
             * @param {String} inputEvent
             * @param {Object} inputData
             */

            var _proto = TouchMouseInput.prototype;

            /**
             * @private
             * remove the event listeners
             */
            _proto.destroy = function destroy() {
              this.touch.destroy();
              this.mouse.destroy();
            };
            return TouchMouseInput;
          }(Input);
          return TouchMouseInput;
        }();

        /**
         * @private
         * create new input type manager
         * called by the Manager constructor
         * @param {Hammer} manager
         * @returns {Input}
         */

        function createInputInstance(manager) {
          var Type; // let inputClass = manager.options.inputClass;

          var inputClass = manager.options.inputClass;
          if (inputClass) {
            Type = inputClass;
          } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
          } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
          } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
          } else {
            Type = TouchMouseInput;
          }
          return new Type(manager, inputHandler);
        }

        /**
         * @private
         * if the argument is an array, we want to execute the fn on each entry
         * if it aint an array we don't want to do a thing.
         * this is used by all the methods that accept a single and array argument.
         * @param {*|Array} arg
         * @param {String} fn
         * @param {Object} [context]
         * @returns {Boolean}
         */

        function invokeArrayArg(arg, fn, context) {
          if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
          }
          return false;
        }
        var STATE_POSSIBLE = 1;
        var STATE_BEGAN = 2;
        var STATE_CHANGED = 4;
        var STATE_ENDED = 8;
        var STATE_RECOGNIZED = STATE_ENDED;
        var STATE_CANCELLED = 16;
        var STATE_FAILED = 32;

        /**
         * @private
         * get a unique id
         * @returns {number} uniqueId
         */
        var _uniqueId = 1;
        function uniqueId() {
          return _uniqueId++;
        }

        /**
         * @private
         * get a recognizer by name if it is bound to a manager
         * @param {Recognizer|String} otherRecognizer
         * @param {Recognizer} recognizer
         * @returns {Recognizer}
         */
        function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
          var manager = recognizer.manager;
          if (manager) {
            return manager.get(otherRecognizer);
          }
          return otherRecognizer;
        }

        /**
         * @private
         * get a usable string, used as event postfix
         * @param {constant} state
         * @returns {String} state
         */

        function stateStr(state) {
          if (state & STATE_CANCELLED) {
            return 'cancel';
          } else if (state & STATE_ENDED) {
            return 'end';
          } else if (state & STATE_CHANGED) {
            return 'move';
          } else if (state & STATE_BEGAN) {
            return 'start';
          }
          return '';
        }

        /**
         * @private
         * Recognizer flow explained; *
         * All recognizers have the initial state of POSSIBLE when a input session starts.
         * The definition of a input session is from the first input until the last input, with all it's movement in it. *
         * Example session for mouse-input: mousedown -> mousemove -> mouseup
         *
         * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
         * which determines with state it should be.
         *
         * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
         * POSSIBLE to give it another change on the next cycle.
         *
         *               Possible
         *                  |
         *            +-----+---------------+
         *            |                     |
         *      +-----+-----+               |
         *      |           |               |
         *   Failed      Cancelled          |
         *                          +-------+------+
         *                          |              |
         *                      Recognized       Began
         *                                         |
         *                                      Changed
         *                                         |
         *                                  Ended/Recognized
         */

        /**
         * @private
         * Recognizer
         * Every recognizer needs to extend from this class.
         * @constructor
         * @param {Object} options
         */

        var Recognizer = /*#__PURE__*/
        function () {
          function Recognizer(options) {
            if (options === void 0) {
              options = {};
            }
            this.options = _extends({
              enable: true
            }, options);
            this.id = uniqueId();
            this.manager = null; // default is enable true

            this.state = STATE_POSSIBLE;
            this.simultaneous = {};
            this.requireFail = [];
          }
          /**
           * @private
           * set options
           * @param {Object} options
           * @return {Recognizer}
           */

          var _proto = Recognizer.prototype;
          _proto.set = function set(options) {
            assign$1$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state

            this.manager && this.manager.touchAction.update();
            return this;
          };
          /**
           * @private
           * recognize simultaneous with an other recognizer.
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */

          _proto.recognizeWith = function recognizeWith(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
              return this;
            }
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
              simultaneous[otherRecognizer.id] = otherRecognizer;
              otherRecognizer.recognizeWith(this);
            }
            return this;
          };
          /**
           * @private
           * drop the simultaneous link. it doesnt remove the link on the other recognizer.
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */

          _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
          };
          /**
           * @private
           * recognizer can only run when an other is failing
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */

          _proto.requireFailure = function requireFailure(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
              return this;
            }
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
              requireFail.push(otherRecognizer);
              otherRecognizer.requireFailure(this);
            }
            return this;
          };
          /**
           * @private
           * drop the requireFailure link. it does not remove the link on the other recognizer.
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */

          _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) {
              this.requireFail.splice(index, 1);
            }
            return this;
          };
          /**
           * @private
           * has require failures boolean
           * @returns {boolean}
           */

          _proto.hasRequireFailures = function hasRequireFailures() {
            return this.requireFail.length > 0;
          };
          /**
           * @private
           * if the recognizer can recognize simultaneous with an other recognizer
           * @param {Recognizer} otherRecognizer
           * @returns {Boolean}
           */

          _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
          };
          /**
           * @private
           * You should use `tryEmit` instead of `emit` directly to check
           * that all the needed recognizers has failed before emitting.
           * @param {Object} input
           */

          _proto.emit = function emit(input) {
            var self = this;
            var state = this.state;
            function emit(event) {
              self.manager.emit(event, input);
            } // 'panstart' and 'panmove'

            if (state < STATE_ENDED) {
              emit(self.options.event + stateStr(state));
            }
            emit(self.options.event); // simple 'eventName' events

            if (input.additionalEvent) {
              // additional event(panleft, panright, pinchin, pinchout...)
              emit(input.additionalEvent);
            } // panend and pancancel

            if (state >= STATE_ENDED) {
              emit(self.options.event + stateStr(state));
            }
          };
          /**
           * @private
           * Check that all the require failure recognizers has failed,
           * if true, it emits a gesture event,
           * otherwise, setup the state to FAILED.
           * @param {Object} input
           */

          _proto.tryEmit = function tryEmit(input) {
            if (this.canEmit()) {
              return this.emit(input);
            } // it's failing anyway

            this.state = STATE_FAILED;
          };
          /**
           * @private
           * can we emit?
           * @returns {boolean}
           */

          _proto.canEmit = function canEmit() {
            var i = 0;
            while (i < this.requireFail.length) {
              if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
              }
              i++;
            }
            return true;
          };
          /**
           * @private
           * update the recognizer
           * @param {Object} inputData
           */

          _proto.recognize = function recognize(inputData) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = assign$1$1({}, inputData); // is is enabled and allow recognizing?

            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
              this.reset();
              this.state = STATE_FAILED;
              return;
            } // reset when we've reached the end

            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
              this.state = STATE_POSSIBLE;
            }
            this.state = this.process(inputDataClone); // the recognizer has recognized a gesture
            // so trigger an event

            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
              this.tryEmit(inputDataClone);
            }
          };
          /**
           * @private
           * return the state of the recognizer
           * the actual recognizing happens in this method
           * @virtual
           * @param {Object} inputData
           * @returns {constant} STATE
           */

          /* jshint ignore:start */

          _proto.process = function process(inputData) {};
          /* jshint ignore:end */

          /**
           * @private
           * return the preferred touch-action
           * @virtual
           * @returns {Array}
           */

          _proto.getTouchAction = function getTouchAction() {};
          /**
           * @private
           * called when the gesture isn't allowed to recognize
           * like when another is being recognized or it is disabled
           * @virtual
           */

          _proto.reset = function reset() {};
          return Recognizer;
        }();

        /**
         * @private
         * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
         * between the given interval and position. The delay option can be used to recognize multi-taps without firing
         * a single tap.
         *
         * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
         * multi-taps being recognized.
         * @constructor
         * @extends Recognizer
         */

        var TapRecognizer = /*#__PURE__*/
        function (_Recognizer) {
          _inheritsLoose(TapRecognizer, _Recognizer);
          function TapRecognizer(options) {
            var _this;
            if (options === void 0) {
              options = {};
            }
            _this = _Recognizer.call(this, _extends({
              event: 'tap',
              pointers: 1,
              taps: 1,
              interval: 300,
              // max time between the multi-tap taps
              time: 250,
              // max time of the pointer to be down (like finger on the screen)
              threshold: 9,
              // a minimal movement is ok, but keep it low
              posThreshold: 10
            }, options)) || this; // previous time and center,
            // used for tap counting

            _this.pTime = false;
            _this.pCenter = false;
            _this._timer = null;
            _this._input = null;
            _this.count = 0;
            return _this;
          }
          var _proto = TapRecognizer.prototype;
          _proto.getTouchAction = function getTouchAction() {
            return [TOUCH_ACTION_MANIPULATION];
          };
          _proto.process = function process(input) {
            var _this2 = this;
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START && this.count === 0) {
              return this.failTimeout();
            } // we only allow little movement
            // and we've reached an end event, so a tap is possible

            if (validMovement && validTouchTime && validPointers) {
              if (input.eventType !== INPUT_END) {
                return this.failTimeout();
              }
              var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
              var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
              this.pTime = input.timeStamp;
              this.pCenter = input.center;
              if (!validMultiTap || !validInterval) {
                this.count = 1;
              } else {
                this.count += 1;
              }
              this._input = input; // if tap count matches we have recognized it,
              // else it has began recognizing...

              var tapCount = this.count % options.taps;
              if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                  return STATE_RECOGNIZED;
                } else {
                  this._timer = setTimeout(function () {
                    _this2.state = STATE_RECOGNIZED;
                    _this2.tryEmit();
                  }, options.interval);
                  return STATE_BEGAN;
                }
              }
            }
            return STATE_FAILED;
          };
          _proto.failTimeout = function failTimeout() {
            var _this3 = this;
            this._timer = setTimeout(function () {
              _this3.state = STATE_FAILED;
            }, this.options.interval);
            return STATE_FAILED;
          };
          _proto.reset = function reset() {
            clearTimeout(this._timer);
          };
          _proto.emit = function emit() {
            if (this.state === STATE_RECOGNIZED) {
              this._input.tapCount = this.count;
              this.manager.emit(this.options.event, this._input);
            }
          };
          return TapRecognizer;
        }(Recognizer);

        /**
         * @private
         * This recognizer is just used as a base for the simple attribute recognizers.
         * @constructor
         * @extends Recognizer
         */

        var AttrRecognizer = /*#__PURE__*/
        function (_Recognizer) {
          _inheritsLoose(AttrRecognizer, _Recognizer);
          function AttrRecognizer(options) {
            if (options === void 0) {
              options = {};
            }
            return _Recognizer.call(this, _extends({
              pointers: 1
            }, options)) || this;
          }
          /**
           * @private
           * Used to check if it the recognizer receives valid input, like input.distance > 10.
           * @memberof AttrRecognizer
           * @param {Object} input
           * @returns {Boolean} recognized
           */

          var _proto = AttrRecognizer.prototype;
          _proto.attrTest = function attrTest(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
          };
          /**
           * @private
           * Process the input and return the state for the recognizer
           * @memberof AttrRecognizer
           * @param {Object} input
           * @returns {*} State
           */

          _proto.process = function process(input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED

            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
              return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
              if (eventType & INPUT_END) {
                return state | STATE_ENDED;
              } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
              }
              return state | STATE_CHANGED;
            }
            return STATE_FAILED;
          };
          return AttrRecognizer;
        }(Recognizer);

        /**
         * @private
         * direction cons to string
         * @param {constant} direction
         * @returns {String}
         */

        function directionStr(direction) {
          if (direction === DIRECTION_DOWN) {
            return 'down';
          } else if (direction === DIRECTION_UP) {
            return 'up';
          } else if (direction === DIRECTION_LEFT) {
            return 'left';
          } else if (direction === DIRECTION_RIGHT) {
            return 'right';
          }
          return '';
        }

        /**
         * @private
         * Pan
         * Recognized when the pointer is down and moved in the allowed direction.
         * @constructor
         * @extends AttrRecognizer
         */

        var PanRecognizer = /*#__PURE__*/
        function (_AttrRecognizer) {
          _inheritsLoose(PanRecognizer, _AttrRecognizer);
          function PanRecognizer(options) {
            var _this;
            if (options === void 0) {
              options = {};
            }
            _this = _AttrRecognizer.call(this, _extends({
              event: 'pan',
              threshold: 10,
              pointers: 1,
              direction: DIRECTION_ALL
            }, options)) || this;
            _this.pX = null;
            _this.pY = null;
            return _this;
          }
          var _proto = PanRecognizer.prototype;
          _proto.getTouchAction = function getTouchAction() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
              actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
              actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
          };
          _proto.directionTest = function directionTest(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY; // lock to axis?

            if (!(direction & options.direction)) {
              if (options.direction & DIRECTION_HORIZONTAL) {
                direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x !== this.pX;
                distance = Math.abs(input.deltaX);
              } else {
                direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y !== this.pY;
                distance = Math.abs(input.deltaY);
              }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
          };
          _proto.attrTest = function attrTest(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (
            // replace with a super call
            this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
          };
          _proto.emit = function emit(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) {
              input.additionalEvent = this.options.event + direction;
            }
            _AttrRecognizer.prototype.emit.call(this, input);
          };
          return PanRecognizer;
        }(AttrRecognizer);

        /**
         * @private
         * Swipe
         * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
         * @constructor
         * @extends AttrRecognizer
         */

        var SwipeRecognizer = /*#__PURE__*/
        function (_AttrRecognizer) {
          _inheritsLoose(SwipeRecognizer, _AttrRecognizer);
          function SwipeRecognizer(options) {
            if (options === void 0) {
              options = {};
            }
            return _AttrRecognizer.call(this, _extends({
              event: 'swipe',
              threshold: 10,
              velocity: 0.3,
              direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
              pointers: 1
            }, options)) || this;
          }
          var _proto = SwipeRecognizer.prototype;
          _proto.getTouchAction = function getTouchAction() {
            return PanRecognizer.prototype.getTouchAction.call(this);
          };
          _proto.attrTest = function attrTest(input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
              velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
              velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
              velocity = input.overallVelocityY;
            }
            return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
          };
          _proto.emit = function emit(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) {
              this.manager.emit(this.options.event + direction, input);
            }
            this.manager.emit(this.options.event, input);
          };
          return SwipeRecognizer;
        }(AttrRecognizer);

        /**
         * @private
         * Pinch
         * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
         * @constructor
         * @extends AttrRecognizer
         */

        var PinchRecognizer = /*#__PURE__*/
        function (_AttrRecognizer) {
          _inheritsLoose(PinchRecognizer, _AttrRecognizer);
          function PinchRecognizer(options) {
            if (options === void 0) {
              options = {};
            }
            return _AttrRecognizer.call(this, _extends({
              event: 'pinch',
              threshold: 0,
              pointers: 2
            }, options)) || this;
          }
          var _proto = PinchRecognizer.prototype;
          _proto.getTouchAction = function getTouchAction() {
            return [TOUCH_ACTION_NONE];
          };
          _proto.attrTest = function attrTest(input) {
            return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
          };
          _proto.emit = function emit(input) {
            if (input.scale !== 1) {
              var inOut = input.scale < 1 ? 'in' : 'out';
              input.additionalEvent = this.options.event + inOut;
            }
            _AttrRecognizer.prototype.emit.call(this, input);
          };
          return PinchRecognizer;
        }(AttrRecognizer);

        /**
         * @private
         * Rotate
         * Recognized when two or more pointer are moving in a circular motion.
         * @constructor
         * @extends AttrRecognizer
         */

        var RotateRecognizer = /*#__PURE__*/
        function (_AttrRecognizer) {
          _inheritsLoose(RotateRecognizer, _AttrRecognizer);
          function RotateRecognizer(options) {
            if (options === void 0) {
              options = {};
            }
            return _AttrRecognizer.call(this, _extends({
              event: 'rotate',
              threshold: 0,
              pointers: 2
            }, options)) || this;
          }
          var _proto = RotateRecognizer.prototype;
          _proto.getTouchAction = function getTouchAction() {
            return [TOUCH_ACTION_NONE];
          };
          _proto.attrTest = function attrTest(input) {
            return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
          };
          return RotateRecognizer;
        }(AttrRecognizer);

        /**
         * @private
         * Press
         * Recognized when the pointer is down for x ms without any movement.
         * @constructor
         * @extends Recognizer
         */

        var PressRecognizer = /*#__PURE__*/
        function (_Recognizer) {
          _inheritsLoose(PressRecognizer, _Recognizer);
          function PressRecognizer(options) {
            var _this;
            if (options === void 0) {
              options = {};
            }
            _this = _Recognizer.call(this, _extends({
              event: 'press',
              pointers: 1,
              time: 251,
              // minimal time of the pointer to be pressed
              threshold: 9
            }, options)) || this;
            _this._timer = null;
            _this._input = null;
            return _this;
          }
          var _proto = PressRecognizer.prototype;
          _proto.getTouchAction = function getTouchAction() {
            return [TOUCH_ACTION_AUTO];
          };
          _proto.process = function process(input) {
            var _this2 = this;
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input; // we only allow little movement
            // and we've reached an end event, so a tap is possible

            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
              this.reset();
            } else if (input.eventType & INPUT_START) {
              this.reset();
              this._timer = setTimeout(function () {
                _this2.state = STATE_RECOGNIZED;
                _this2.tryEmit();
              }, options.time);
            } else if (input.eventType & INPUT_END) {
              return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
          };
          _proto.reset = function reset() {
            clearTimeout(this._timer);
          };
          _proto.emit = function emit(input) {
            if (this.state !== STATE_RECOGNIZED) {
              return;
            }
            if (input && input.eventType & INPUT_END) {
              this.manager.emit(this.options.event + "up", input);
            } else {
              this._input.timeStamp = now();
              this.manager.emit(this.options.event, this._input);
            }
          };
          return PressRecognizer;
        }(Recognizer);
        var defaults$2 = {
          /**
           * @private
           * set if DOM events are being triggered.
           * But this is slower and unused by simple implementations, so disabled by default.
           * @type {Boolean}
           * @default false
           */
          domEvents: false,
          /**
           * @private
           * The value for the touchAction property/fallback.
           * When set to `compute` it will magically set the correct value based on the added recognizers.
           * @type {String}
           * @default compute
           */
          touchAction: TOUCH_ACTION_COMPUTE,
          /**
           * @private
           * @type {Boolean}
           * @default true
           */
          enable: true,
          /**
           * @private
           * EXPERIMENTAL FEATURE -- can be removed/changed
           * Change the parent input target element.
           * If Null, then it is being set the to main element.
           * @type {Null|EventTarget}
           * @default null
           */
          inputTarget: null,
          /**
           * @private
           * force an input class
           * @type {Null|Function}
           * @default null
           */
          inputClass: null,
          /**
           * @private
           * Some CSS properties can be used to improve the working of Hammer.
           * Add them to this method and they will be set when creating a new Manager.
           * @namespace
           */
          cssProps: {
            /**
             * @private
             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userSelect: "none",
            /**
             * @private
             * Disable the Windows Phone grippers when pressing an element.
             * @type {String}
             * @default 'none'
             */
            touchSelect: "none",
            /**
             * @private
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @type {String}
             * @default 'none'
             */
            touchCallout: "none",
            /**
             * @private
             * Specifies whether zooming is enabled. Used by IE10>
             * @type {String}
             * @default 'none'
             */
            contentZooming: "none",
            /**
             * @private
             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userDrag: "none",
            /**
             * @private
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in iOS. This property obeys the alpha value, if specified.
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: "rgba(0,0,0,0)"
          }
        };
        /**
         * @private
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * This is separated with other defaults because of tree-shaking.
         * @type {Array}
         */

        var preset = [[RotateRecognizer, {
          enable: false
        }], [PinchRecognizer, {
          enable: false
        }, ['rotate']], [SwipeRecognizer, {
          direction: DIRECTION_HORIZONTAL
        }], [PanRecognizer, {
          direction: DIRECTION_HORIZONTAL
        }, ['swipe']], [TapRecognizer], [TapRecognizer, {
          event: 'doubletap',
          taps: 2
        }, ['tap']], [PressRecognizer]];
        var STOP = 1;
        var FORCED_STOP = 2;
        /**
         * @private
         * add/remove the css properties as defined in manager.options.cssProps
         * @param {Manager} manager
         * @param {Boolean} add
         */

        function toggleCssProps(manager, add) {
          var element = manager.element;
          if (!element.style) {
            return;
          }
          var prop;
          each(manager.options.cssProps, function (value, name) {
            prop = prefixed(element.style, name);
            if (add) {
              manager.oldCssProps[prop] = element.style[prop];
              element.style[prop] = value;
            } else {
              element.style[prop] = manager.oldCssProps[prop] || "";
            }
          });
          if (!add) {
            manager.oldCssProps = {};
          }
        }
        /**
         * @private
         * trigger dom event
         * @param {String} event
         * @param {Object} data
         */

        function triggerDomEvent(event, data) {
          var gestureEvent = document.createEvent("Event");
          gestureEvent.initEvent(event, true, true);
          gestureEvent.gesture = data;
          data.target.dispatchEvent(gestureEvent);
        }
        /**
        * @private
         * Manager
         * @param {HTMLElement} element
         * @param {Object} [options]
         * @constructor
         */

        var Manager = /*#__PURE__*/
        function () {
          function Manager(element, options) {
            var _this = this;
            this.options = assign$1$1({}, defaults$2, options || {});
            this.options.inputTarget = this.options.inputTarget || element;
            this.handlers = {};
            this.session = {};
            this.recognizers = [];
            this.oldCssProps = {};
            this.element = element;
            this.input = createInputInstance(this);
            this.touchAction = new TouchAction(this, this.options.touchAction);
            toggleCssProps(this, true);
            each(this.options.recognizers, function (item) {
              var recognizer = _this.add(new item[0](item[1]));
              item[2] && recognizer.recognizeWith(item[2]);
              item[3] && recognizer.requireFailure(item[3]);
            }, this);
          }
          /**
           * @private
           * set options
           * @param {Object} options
           * @returns {Manager}
           */

          var _proto = Manager.prototype;
          _proto.set = function set(options) {
            assign$1$1(this.options, options); // Options that need a little more setup

            if (options.touchAction) {
              this.touchAction.update();
            }
            if (options.inputTarget) {
              // Clean up existing event listeners and reinitialize
              this.input.destroy();
              this.input.target = options.inputTarget;
              this.input.init();
            }
            return this;
          };
          /**
           * @private
           * stop recognizing for this session.
           * This session will be discarded, when a new [input]start event is fired.
           * When forced, the recognizer cycle is stopped immediately.
           * @param {Boolean} [force]
           */

          _proto.stop = function stop(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
          };
          /**
           * @private
           * run the recognizers!
           * called by the inputHandler function on every movement of the pointers (touches)
           * it walks through all the recognizers and tries to detect the gesture that is being made
           * @param {Object} inputData
           */

          _proto.recognize = function recognize(inputData) {
            var session = this.session;
            if (session.stopped) {
              return;
            } // run the touch-action polyfill

            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers; // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`

            var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized
            // or when we're in a new session

            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
              session.curRecognizer = null;
              curRecognizer = null;
            }
            var i = 0;
            while (i < recognizers.length) {
              recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.
              // 1.   allow if the session is NOT forced stopped (see the .stop() method)
              // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
              //      that is being recognized.
              // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
              //      this can be setup with the `recognizeWith()` method on the recognizer.

              if (session.stopped !== FORCED_STOP && (
              // 1
              !curRecognizer || recognizer === curRecognizer ||
              // 2
              recognizer.canRecognizeWith(curRecognizer))) {
                // 3
                recognizer.recognize(inputData);
              } else {
                recognizer.reset();
              } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
              // current active recognizer. but only if we don't already have an active recognizer

              if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                session.curRecognizer = recognizer;
                curRecognizer = recognizer;
              }
              i++;
            }
          };
          /**
           * @private
           * get a recognizer by its event name.
           * @param {Recognizer|String} recognizer
           * @returns {Recognizer|Null}
           */

          _proto.get = function get(recognizer) {
            if (recognizer instanceof Recognizer) {
              return recognizer;
            }
            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++) {
              if (recognizers[i].options.event === recognizer) {
                return recognizers[i];
              }
            }
            return null;
          };
          /**
           * @private add a recognizer to the manager
           * existing recognizers with the same event name will be removed
           * @param {Recognizer} recognizer
           * @returns {Recognizer|Manager}
           */

          _proto.add = function add(recognizer) {
            if (invokeArrayArg(recognizer, "add", this)) {
              return this;
            } // remove existing

            var existing = this.get(recognizer.options.event);
            if (existing) {
              this.remove(existing);
            }
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
          };
          /**
           * @private
           * remove a recognizer by name or instance
           * @param {Recognizer|String} recognizer
           * @returns {Manager}
           */

          _proto.remove = function remove(recognizer) {
            if (invokeArrayArg(recognizer, "remove", this)) {
              return this;
            }
            var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists

            if (recognizer) {
              var recognizers = this.recognizers;
              var index = inArray(recognizers, targetRecognizer);
              if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
              }
            }
            return this;
          };
          /**
           * @private
           * bind event
           * @param {String} events
           * @param {Function} handler
           * @returns {EventEmitter} this
           */

          _proto.on = function on(events, handler) {
            if (events === undefined || handler === undefined) {
              return this;
            }
            var handlers = this.handlers;
            each(splitStr(events), function (event) {
              handlers[event] = handlers[event] || [];
              handlers[event].push(handler);
            });
            return this;
          };
          /**
           * @private unbind event, leave emit blank to remove all handlers
           * @param {String} events
           * @param {Function} [handler]
           * @returns {EventEmitter} this
           */

          _proto.off = function off(events, handler) {
            if (events === undefined) {
              return this;
            }
            var handlers = this.handlers;
            each(splitStr(events), function (event) {
              if (!handler) {
                delete handlers[event];
              } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
              }
            });
            return this;
          };
          /**
           * @private emit event to the listeners
           * @param {String} event
           * @param {Object} data
           */

          _proto.emit = function emit(event, data) {
            // we also want to trigger dom events
            if (this.options.domEvents) {
              triggerDomEvent(event, data);
            } // no handlers, so skip it all

            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
              return;
            }
            data.type = event;
            data.preventDefault = function () {
              data.srcEvent.preventDefault();
            };
            var i = 0;
            while (i < handlers.length) {
              handlers[i](data);
              i++;
            }
          };
          /**
           * @private
           * destroy the manager and unbinds all events
           * it doesn't unbind dom events, that is the user own responsibility
           */

          _proto.destroy = function destroy() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
          };
          return Manager;
        }();
        var SINGLE_TOUCH_INPUT_MAP = {
          touchstart: INPUT_START,
          touchmove: INPUT_MOVE,
          touchend: INPUT_END,
          touchcancel: INPUT_CANCEL
        };
        var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
        var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
        /**
         * @private
         * Touch events input
         * @constructor
         * @extends Input
         */

        var SingleTouchInput = /*#__PURE__*/
        function (_Input) {
          _inheritsLoose(SingleTouchInput, _Input);
          function SingleTouchInput() {
            var _this;
            var proto = SingleTouchInput.prototype;
            proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
            proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
            _this = _Input.apply(this, arguments) || this;
            _this.started = false;
            return _this;
          }
          var _proto = SingleTouchInput.prototype;
          _proto.handler = function handler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?

            if (type === INPUT_START) {
              this.started = true;
            }
            if (!this.started) {
              return;
            }
            var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state

            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
              this.started = false;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          };
          return SingleTouchInput;
        }(Input);
        function normalizeSingleTouches(ev, type) {
          var all = toArray(ev.touches);
          var changed = toArray(ev.changedTouches);
          if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), 'identifier', true);
          }
          return [all, changed];
        }

        /**
         * @private
         * wrap a method with a deprecation warning and stack trace
         * @param {Function} method
         * @param {String} name
         * @param {String} message
         * @returns {Function} A new function wrapping the supplied method.
         */
        function deprecate(method, name, message) {
          var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
          return function () {
            var e = new Error('get-stack-trace');
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
            var log = window.console && (window.console.warn || window.console.log);
            if (log) {
              log.call(window.console, deprecationMessage, stack);
            }
            return method.apply(this, arguments);
          };
        }

        /**
         * @private
         * extend object.
         * means that properties in dest will be overwritten by the ones in src.
         * @param {Object} dest
         * @param {Object} src
         * @param {Boolean} [merge=false]
         * @returns {Object} dest
         */

        var extend = deprecate(function (dest, src, merge) {
          var keys = Object.keys(src);
          var i = 0;
          while (i < keys.length) {
            if (!merge || merge && dest[keys[i]] === undefined) {
              dest[keys[i]] = src[keys[i]];
            }
            i++;
          }
          return dest;
        }, 'extend', 'Use `assign`.');

        /**
         * @private
         * merge the values from src in the dest.
         * means that properties that exist in dest will not be overwritten by src
         * @param {Object} dest
         * @param {Object} src
         * @returns {Object} dest
         */

        var merge$1 = deprecate(function (dest, src) {
          return extend(dest, src, true);
        }, 'merge', 'Use `assign`.');

        /**
         * @private
         * simple class inheritance
         * @param {Function} child
         * @param {Function} base
         * @param {Object} [properties]
         */

        function inherit(child, base, properties) {
          var baseP = base.prototype;
          var childP;
          childP = child.prototype = Object.create(baseP);
          childP.constructor = child;
          childP._super = baseP;
          if (properties) {
            assign$1$1(childP, properties);
          }
        }

        /**
         * @private
         * simple function bind
         * @param {Function} fn
         * @param {Object} context
         * @returns {Function}
         */
        function bindFn(fn, context) {
          return function boundFn() {
            return fn.apply(context, arguments);
          };
        }

        /**
         * @private
         * Simple way to create a manager with a default set of recognizers.
         * @param {HTMLElement} element
         * @param {Object} [options]
         * @constructor
         */

        var Hammer = /*#__PURE__*/
        function () {
          var Hammer =
          /**
            * @private
            * @const {string}
            */
          function Hammer(element, options) {
            if (options === void 0) {
              options = {};
            }
            return new Manager(element, _extends({
              recognizers: preset.concat()
            }, options));
          };
          Hammer.VERSION = "2.0.17-rc";
          Hammer.DIRECTION_ALL = DIRECTION_ALL;
          Hammer.DIRECTION_DOWN = DIRECTION_DOWN;
          Hammer.DIRECTION_LEFT = DIRECTION_LEFT;
          Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;
          Hammer.DIRECTION_UP = DIRECTION_UP;
          Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
          Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;
          Hammer.DIRECTION_NONE = DIRECTION_NONE;
          Hammer.DIRECTION_DOWN = DIRECTION_DOWN;
          Hammer.INPUT_START = INPUT_START;
          Hammer.INPUT_MOVE = INPUT_MOVE;
          Hammer.INPUT_END = INPUT_END;
          Hammer.INPUT_CANCEL = INPUT_CANCEL;
          Hammer.STATE_POSSIBLE = STATE_POSSIBLE;
          Hammer.STATE_BEGAN = STATE_BEGAN;
          Hammer.STATE_CHANGED = STATE_CHANGED;
          Hammer.STATE_ENDED = STATE_ENDED;
          Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;
          Hammer.STATE_CANCELLED = STATE_CANCELLED;
          Hammer.STATE_FAILED = STATE_FAILED;
          Hammer.Manager = Manager;
          Hammer.Input = Input;
          Hammer.TouchAction = TouchAction;
          Hammer.TouchInput = TouchInput;
          Hammer.MouseInput = MouseInput;
          Hammer.PointerEventInput = PointerEventInput;
          Hammer.TouchMouseInput = TouchMouseInput;
          Hammer.SingleTouchInput = SingleTouchInput;
          Hammer.Recognizer = Recognizer;
          Hammer.AttrRecognizer = AttrRecognizer;
          Hammer.Tap = TapRecognizer;
          Hammer.Pan = PanRecognizer;
          Hammer.Swipe = SwipeRecognizer;
          Hammer.Pinch = PinchRecognizer;
          Hammer.Rotate = RotateRecognizer;
          Hammer.Press = PressRecognizer;
          Hammer.on = addEventListeners;
          Hammer.off = removeEventListeners;
          Hammer.each = each;
          Hammer.merge = merge$1;
          Hammer.extend = extend;
          Hammer.bindFn = bindFn;
          Hammer.assign = assign$1$1;
          Hammer.inherit = inherit;
          Hammer.bindFn = bindFn;
          Hammer.prefixed = prefixed;
          Hammer.toArray = toArray;
          Hammer.inArray = inArray;
          Hammer.uniqueArray = uniqueArray;
          Hammer.splitStr = splitStr;
          Hammer.boolOrFn = boolOrFn;
          Hammer.hasParent = hasParent;
          Hammer.addEventListeners = addEventListeners;
          Hammer.removeEventListeners = removeEventListeners;
          Hammer.defaults = assign$1$1({}, defaults$2, {
            preset: preset
          });
          return Hammer;
        }();
        var Hammer$1 = Hammer;
        function pinch(node) {
          var hammer = new Hammer$1.Manager(node);
          var pinch = new Hammer$1.Pinch();
          hammer.add(pinch);
          hammer.on('pinchmove', function (e) {
            node.dispatchEvent(new CustomEvent('pinchmove', {
              detail: e
            }));
          });
          hammer.on('pinchstart', function (e) {
            node.dispatchEvent(new CustomEvent('pinchstart', {
              detail: e
            }));
          });
          return {
            destroy: function destroy() {}
          };
        }
        function pan(node) {
          var hammer = new Hammer$1.Manager(node);
          var pan = new Hammer$1.Pan();
          hammer.add(pan);
          hammer.on('panmove', function (e) {
            node.dispatchEvent(new CustomEvent('panmove', {
              detail: e
            }));
          });
          return {
            destroy: function destroy() {}
          };
        }

        /* eslint complexity: [2, 18], max-statements: [2, 33] */
        var shams = function hasSymbols() {
          if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
            return false;
          }
          if (_typeof(Symbol.iterator) === 'symbol') {
            return true;
          }
          var obj = {};
          var sym = Symbol('test');
          var symObj = Object(sym);
          if (typeof sym === 'string') {
            return false;
          }
          if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
            return false;
          }
          if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
            return false;
          }

          // temp disabled per https://github.com/ljharb/object.assign/issues/17
          // if (sym instanceof Symbol) { return false; }
          // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
          // if (!(symObj instanceof Symbol)) { return false; }

          // if (typeof Symbol.prototype.toString !== 'function') { return false; }
          // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

          var symVal = 42;
          obj[sym] = symVal;
          for (sym in obj) {
            return false;
          } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
          if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
            return false;
          }
          if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
            return false;
          }
          var syms = Object.getOwnPropertySymbols(obj);
          if (syms.length !== 1 || syms[0] !== sym) {
            return false;
          }
          if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
            return false;
          }
          if (typeof Object.getOwnPropertyDescriptor === 'function') {
            var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
            if (descriptor.value !== symVal || descriptor.enumerable !== true) {
              return false;
            }
          }
          return true;
        };
        var origSymbol = typeof Symbol !== 'undefined' && Symbol;
        var hasSymbolSham = shams;
        var hasSymbols$1 = function hasNativeSymbols() {
          if (typeof origSymbol !== 'function') {
            return false;
          }
          if (typeof Symbol !== 'function') {
            return false;
          }
          if (_typeof(origSymbol('foo')) !== 'symbol') {
            return false;
          }
          if (_typeof(Symbol('bar')) !== 'symbol') {
            return false;
          }
          return hasSymbolSham();
        };

        /* eslint no-invalid-this: 1 */

        var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
        var slice = Array.prototype.slice;
        var toStr$1 = Object.prototype.toString;
        var funcType = '[object Function]';
        var implementation$1 = function bind(that) {
          var target = this;
          if (typeof target !== 'function' || toStr$1.call(target) !== funcType) {
            throw new TypeError(ERROR_MESSAGE + target);
          }
          var args = slice.call(arguments, 1);
          var bound;
          var binder = function binder() {
            if (this instanceof bound) {
              var result = target.apply(this, args.concat(slice.call(arguments)));
              if (Object(result) === result) {
                return result;
              }
              return this;
            } else {
              return target.apply(that, args.concat(slice.call(arguments)));
            }
          };
          var boundLength = Math.max(0, target.length - args.length);
          var boundArgs = [];
          for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
          }
          bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);
          if (target.prototype) {
            var Empty = function Empty() {};
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
          }
          return bound;
        };
        var implementation = implementation$1;
        var functionBind = Function.prototype.bind || implementation;
        var bind$1 = functionBind;
        var src = bind$1.call(Function.call, Object.prototype.hasOwnProperty);
        var undefined$1;
        var $SyntaxError = SyntaxError;
        var $Function = Function;
        var $TypeError$1 = TypeError;

        // eslint-disable-next-line consistent-return
        var getEvalledConstructor = function getEvalledConstructor(expressionSyntax) {
          try {
            return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
          } catch (e) {}
        };
        var $gOPD = Object.getOwnPropertyDescriptor;
        if ($gOPD) {
          try {
            $gOPD({}, '');
          } catch (e) {
            $gOPD = null; // this is IE 8, which has a broken gOPD
          }
        }

        var throwTypeError = function throwTypeError() {
          throw new $TypeError$1();
        };
        var ThrowTypeError = $gOPD ? function () {
          try {
            // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
            arguments.callee; // IE 8 does not throw here
            return throwTypeError;
          } catch (calleeThrows) {
            try {
              // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
              return $gOPD(arguments, 'callee').get;
            } catch (gOPDthrows) {
              return throwTypeError;
            }
          }
        }() : throwTypeError;
        var hasSymbols = hasSymbols$1();
        var getProto = Object.getPrototypeOf || function (x) {
          return x.__proto__;
        }; // eslint-disable-line no-proto

        var needsEval = {};
        var TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto(Uint8Array);
        var INTRINSICS = {
          '%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
          '%Array%': Array,
          '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
          '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined$1,
          '%AsyncFromSyncIteratorPrototype%': undefined$1,
          '%AsyncFunction%': needsEval,
          '%AsyncGenerator%': needsEval,
          '%AsyncGeneratorFunction%': needsEval,
          '%AsyncIteratorPrototype%': needsEval,
          '%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
          '%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
          '%Boolean%': Boolean,
          '%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
          '%Date%': Date,
          '%decodeURI%': decodeURI,
          '%decodeURIComponent%': decodeURIComponent,
          '%encodeURI%': encodeURI,
          '%encodeURIComponent%': encodeURIComponent,
          '%Error%': Error,
          '%eval%': eval,
          // eslint-disable-line no-eval
          '%EvalError%': EvalError,
          '%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
          '%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
          '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
          '%Function%': $Function,
          '%GeneratorFunction%': needsEval,
          '%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
          '%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
          '%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
          '%isFinite%': isFinite,
          '%isNaN%': isNaN,
          '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
          '%JSON%': (typeof JSON === "undefined" ? "undefined" : _typeof(JSON)) === 'object' ? JSON : undefined$1,
          '%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
          '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
          '%Math%': Math,
          '%Number%': Number,
          '%Object%': Object,
          '%parseFloat%': parseFloat,
          '%parseInt%': parseInt,
          '%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
          '%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
          '%RangeError%': RangeError,
          '%ReferenceError%': ReferenceError,
          '%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
          '%RegExp%': RegExp,
          '%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
          '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
          '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
          '%String%': String,
          '%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined$1,
          '%Symbol%': hasSymbols ? Symbol : undefined$1,
          '%SyntaxError%': $SyntaxError,
          '%ThrowTypeError%': ThrowTypeError,
          '%TypedArray%': TypedArray,
          '%TypeError%': $TypeError$1,
          '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
          '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
          '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
          '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
          '%URIError%': URIError,
          '%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
          '%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
          '%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet
        };
        var doEval = function doEval(name) {
          var value;
          if (name === '%AsyncFunction%') {
            value = getEvalledConstructor('async function () {}');
          } else if (name === '%GeneratorFunction%') {
            value = getEvalledConstructor('function* () {}');
          } else if (name === '%AsyncGeneratorFunction%') {
            value = getEvalledConstructor('async function* () {}');
          } else if (name === '%AsyncGenerator%') {
            var fn = doEval('%AsyncGeneratorFunction%');
            if (fn) {
              value = fn.prototype;
            }
          } else if (name === '%AsyncIteratorPrototype%') {
            var gen = doEval('%AsyncGenerator%');
            if (gen) {
              value = getProto(gen.prototype);
            }
          }
          INTRINSICS[name] = value;
          return value;
        };
        var LEGACY_ALIASES = {
          '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
          '%ArrayPrototype%': ['Array', 'prototype'],
          '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
          '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
          '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
          '%ArrayProto_values%': ['Array', 'prototype', 'values'],
          '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
          '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
          '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
          '%BooleanPrototype%': ['Boolean', 'prototype'],
          '%DataViewPrototype%': ['DataView', 'prototype'],
          '%DatePrototype%': ['Date', 'prototype'],
          '%ErrorPrototype%': ['Error', 'prototype'],
          '%EvalErrorPrototype%': ['EvalError', 'prototype'],
          '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
          '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
          '%FunctionPrototype%': ['Function', 'prototype'],
          '%Generator%': ['GeneratorFunction', 'prototype'],
          '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
          '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
          '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
          '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
          '%JSONParse%': ['JSON', 'parse'],
          '%JSONStringify%': ['JSON', 'stringify'],
          '%MapPrototype%': ['Map', 'prototype'],
          '%NumberPrototype%': ['Number', 'prototype'],
          '%ObjectPrototype%': ['Object', 'prototype'],
          '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
          '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
          '%PromisePrototype%': ['Promise', 'prototype'],
          '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
          '%Promise_all%': ['Promise', 'all'],
          '%Promise_reject%': ['Promise', 'reject'],
          '%Promise_resolve%': ['Promise', 'resolve'],
          '%RangeErrorPrototype%': ['RangeError', 'prototype'],
          '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
          '%RegExpPrototype%': ['RegExp', 'prototype'],
          '%SetPrototype%': ['Set', 'prototype'],
          '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
          '%StringPrototype%': ['String', 'prototype'],
          '%SymbolPrototype%': ['Symbol', 'prototype'],
          '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
          '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
          '%TypeErrorPrototype%': ['TypeError', 'prototype'],
          '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
          '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
          '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
          '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
          '%URIErrorPrototype%': ['URIError', 'prototype'],
          '%WeakMapPrototype%': ['WeakMap', 'prototype'],
          '%WeakSetPrototype%': ['WeakSet', 'prototype']
        };
        var bind = functionBind;
        var hasOwn$1 = src;
        var $concat$1 = bind.call(Function.call, Array.prototype.concat);
        var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
        var $replace$1 = bind.call(Function.call, String.prototype.replace);
        var $strSlice = bind.call(Function.call, String.prototype.slice);
        var $exec = bind.call(Function.call, RegExp.prototype.exec);

        /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
        var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
        var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
        var stringToPath = function stringToPath(string) {
          var first = $strSlice(string, 0, 1);
          var last = $strSlice(string, -1);
          if (first === '%' && last !== '%') {
            throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
          } else if (last === '%' && first !== '%') {
            throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
          }
          var result = [];
          $replace$1(string, rePropName, function (match, number, quote, subString) {
            result[result.length] = quote ? $replace$1(subString, reEscapeChar, '$1') : number || match;
          });
          return result;
        };
        /* end adaptation */

        var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
          var intrinsicName = name;
          var alias;
          if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
            alias = LEGACY_ALIASES[intrinsicName];
            intrinsicName = '%' + alias[0] + '%';
          }
          if (hasOwn$1(INTRINSICS, intrinsicName)) {
            var value = INTRINSICS[intrinsicName];
            if (value === needsEval) {
              value = doEval(intrinsicName);
            }
            if (typeof value === 'undefined' && !allowMissing) {
              throw new $TypeError$1('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
            }
            return {
              alias: alias,
              name: intrinsicName,
              value: value
            };
          }
          throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
        };
        var getIntrinsic = function GetIntrinsic(name, allowMissing) {
          if (typeof name !== 'string' || name.length === 0) {
            throw new $TypeError$1('intrinsic name must be a non-empty string');
          }
          if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
            throw new $TypeError$1('"allowMissing" argument must be a boolean');
          }
          if ($exec(/^%?[^%]*%?$/, name) === null) {
            throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
          }
          var parts = stringToPath(name);
          var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
          var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
          var intrinsicRealName = intrinsic.name;
          var value = intrinsic.value;
          var skipFurtherCaching = false;
          var alias = intrinsic.alias;
          if (alias) {
            intrinsicBaseName = alias[0];
            $spliceApply(parts, $concat$1([0, 1], alias));
          }
          for (var i = 1, isOwn = true; i < parts.length; i += 1) {
            var part = parts[i];
            var first = $strSlice(part, 0, 1);
            var last = $strSlice(part, -1);
            if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
              throw new $SyntaxError('property names with quotes must have matching quotes');
            }
            if (part === 'constructor' || !isOwn) {
              skipFurtherCaching = true;
            }
            intrinsicBaseName += '.' + part;
            intrinsicRealName = '%' + intrinsicBaseName + '%';
            if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
              value = INTRINSICS[intrinsicRealName];
            } else if (value != null) {
              if (!(part in value)) {
                if (!allowMissing) {
                  throw new $TypeError$1('base intrinsic for ' + name + ' exists, but the property is not available.');
                }
                return void undefined$1;
              }
              if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;

                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                  value = desc.get;
                } else {
                  value = value[part];
                }
              } else {
                isOwn = hasOwn$1(value, part);
                value = value[part];
              }
              if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
              }
            }
          }
          return value;
        };
        var callBind$1 = {
          exports: {}
        };
        (function (module) {
          var bind = functionBind;
          var GetIntrinsic = getIntrinsic;
          var $apply = GetIntrinsic('%Function.prototype.apply%');
          var $call = GetIntrinsic('%Function.prototype.call%');
          var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
          var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
          var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
          var $max = GetIntrinsic('%Math.max%');
          if ($defineProperty) {
            try {
              $defineProperty({}, 'a', {
                value: 1
              });
            } catch (e) {
              // IE 8 has a broken defineProperty
              $defineProperty = null;
            }
          }
          module.exports = function callBind(originalFunction) {
            var func = $reflectApply(bind, $call, arguments);
            if ($gOPD && $defineProperty) {
              var desc = $gOPD(func, 'length');
              if (desc.configurable) {
                // original length, plus the receiver, minus any additional arguments (after the receiver)
                $defineProperty(func, 'length', {
                  value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
                });
              }
            }
            return func;
          };
          var applyBind = function applyBind() {
            return $reflectApply(bind, $apply, arguments);
          };
          if ($defineProperty) {
            $defineProperty(module.exports, 'apply', {
              value: applyBind
            });
          } else {
            module.exports.apply = applyBind;
          }
        })(callBind$1);
        var GetIntrinsic$1 = getIntrinsic;
        var callBind = callBind$1.exports;
        var $indexOf = callBind(GetIntrinsic$1('String.prototype.indexOf'));
        var callBound$1 = function callBoundIntrinsic(name, allowMissing) {
          var intrinsic = GetIntrinsic$1(name, !!allowMissing);
          if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
            return callBind(intrinsic);
          }
          return intrinsic;
        };
        var __viteBrowserExternal = {};
        var __viteBrowserExternal$1 = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({
          __proto__: null,
          default: __viteBrowserExternal
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        var require$$0 = /*@__PURE__*/getAugmentedNamespace(__viteBrowserExternal$1);
        var hasMap = typeof Map === 'function' && Map.prototype;
        var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
        var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
        var mapForEach = hasMap && Map.prototype.forEach;
        var hasSet = typeof Set === 'function' && Set.prototype;
        var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
        var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
        var setForEach = hasSet && Set.prototype.forEach;
        var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
        var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
        var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
        var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
        var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
        var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
        var booleanValueOf = Boolean.prototype.valueOf;
        var objectToString = Object.prototype.toString;
        var functionToString = Function.prototype.toString;
        var $match = String.prototype.match;
        var $slice = String.prototype.slice;
        var $replace = String.prototype.replace;
        var $toUpperCase = String.prototype.toUpperCase;
        var $toLowerCase = String.prototype.toLowerCase;
        var $test = RegExp.prototype.test;
        var $concat = Array.prototype.concat;
        var $join = Array.prototype.join;
        var $arrSlice = Array.prototype.slice;
        var $floor = Math.floor;
        var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
        var gOPS = Object.getOwnPropertySymbols;
        var symToString = typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol' ? Symbol.prototype.toString : null;
        var hasShammedSymbols = typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'object';
        // ie, `has-tostringtag/shams
        var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (_typeof(Symbol.toStringTag) === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
        var isEnumerable = Object.prototype.propertyIsEnumerable;
        var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
          return O.__proto__; // eslint-disable-line no-proto
        } : null);
        function addNumericSeparator(num, str) {
          if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) {
            return str;
          }
          var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
          if (typeof num === 'number') {
            var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
            if (int !== num) {
              var intStr = String(int);
              var dec = $slice.call(str, intStr.length + 1);
              return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
            }
          }
          return $replace.call(str, sepRegex, '$&_');
        }
        var utilInspect = require$$0;
        var inspectCustom = utilInspect.custom;
        var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
        var objectInspect = function inspect_(obj, options, depth, seen) {
          var opts = options || {};
          if (has$3(opts, 'quoteStyle') && opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double') {
            throw new TypeError('option "quoteStyle" must be "single" or "double"');
          }
          if (has$3(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number' ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
            throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
          }
          var customInspect = has$3(opts, 'customInspect') ? opts.customInspect : true;
          if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
            throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
          }
          if (has$3(opts, 'indent') && opts.indent !== null && opts.indent !== '\t' && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
            throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
          }
          if (has$3(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
            throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
          }
          var numericSeparator = opts.numericSeparator;
          if (typeof obj === 'undefined') {
            return 'undefined';
          }
          if (obj === null) {
            return 'null';
          }
          if (typeof obj === 'boolean') {
            return obj ? 'true' : 'false';
          }
          if (typeof obj === 'string') {
            return inspectString(obj, opts);
          }
          if (typeof obj === 'number') {
            if (obj === 0) {
              return Infinity / obj > 0 ? '0' : '-0';
            }
            var str = String(obj);
            return numericSeparator ? addNumericSeparator(obj, str) : str;
          }
          if (typeof obj === 'bigint') {
            var bigIntStr = String(obj) + 'n';
            return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
          }
          var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
          if (typeof depth === 'undefined') {
            depth = 0;
          }
          if (depth >= maxDepth && maxDepth > 0 && _typeof(obj) === 'object') {
            return isArray$3(obj) ? '[Array]' : '[Object]';
          }
          var indent = getIndent(opts, depth);
          if (typeof seen === 'undefined') {
            seen = [];
          } else if (indexOf(seen, obj) >= 0) {
            return '[Circular]';
          }
          function inspect(value, from, noIndent) {
            if (from) {
              seen = $arrSlice.call(seen);
              seen.push(from);
            }
            if (noIndent) {
              var newOpts = {
                depth: opts.depth
              };
              if (has$3(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
              }
              return inspect_(value, newOpts, depth + 1, seen);
            }
            return inspect_(value, opts, depth + 1, seen);
          }
          if (typeof obj === 'function' && !isRegExp$1(obj)) {
            // in older engines, regexes are callable
            var name = nameOf(obj);
            var keys = arrObjKeys(obj, inspect);
            return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
          }
          if (isSymbol(obj)) {
            var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
            return _typeof(obj) === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
          }
          if (isElement(obj)) {
            var s = '<' + $toLowerCase.call(String(obj.nodeName));
            var attrs = obj.attributes || [];
            for (var i = 0; i < attrs.length; i++) {
              s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
            }
            s += '>';
            if (obj.childNodes && obj.childNodes.length) {
              s += '...';
            }
            s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
            return s;
          }
          if (isArray$3(obj)) {
            if (obj.length === 0) {
              return '[]';
            }
            var xs = arrObjKeys(obj, inspect);
            if (indent && !singleLineValues(xs)) {
              return '[' + indentedJoin(xs, indent) + ']';
            }
            return '[ ' + $join.call(xs, ', ') + ' ]';
          }
          if (isError(obj)) {
            var parts = arrObjKeys(obj, inspect);
            if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
              return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
            }
            if (parts.length === 0) {
              return '[' + String(obj) + ']';
            }
            return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
          }
          if (_typeof(obj) === 'object' && customInspect) {
            if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
              return utilInspect(obj, {
                depth: maxDepth - depth
              });
            } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
              return obj.inspect();
            }
          }
          if (isMap(obj)) {
            var mapParts = [];
            mapForEach.call(obj, function (value, key) {
              mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
            return collectionOf('Map', mapSize.call(obj), mapParts, indent);
          }
          if (isSet(obj)) {
            var setParts = [];
            setForEach.call(obj, function (value) {
              setParts.push(inspect(value, obj));
            });
            return collectionOf('Set', setSize.call(obj), setParts, indent);
          }
          if (isWeakMap(obj)) {
            return weakCollectionOf('WeakMap');
          }
          if (isWeakSet(obj)) {
            return weakCollectionOf('WeakSet');
          }
          if (isWeakRef(obj)) {
            return weakCollectionOf('WeakRef');
          }
          if (isNumber(obj)) {
            return markBoxed(inspect(Number(obj)));
          }
          if (isBigInt(obj)) {
            return markBoxed(inspect(bigIntValueOf.call(obj)));
          }
          if (isBoolean(obj)) {
            return markBoxed(booleanValueOf.call(obj));
          }
          if (isString(obj)) {
            return markBoxed(inspect(String(obj)));
          }
          if (!isDate(obj) && !isRegExp$1(obj)) {
            var ys = arrObjKeys(obj, inspect);
            var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
            var protoTag = obj instanceof Object ? '' : 'null prototype';
            var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
            var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
            var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
            if (ys.length === 0) {
              return tag + '{}';
            }
            if (indent) {
              return tag + '{' + indentedJoin(ys, indent) + '}';
            }
            return tag + '{ ' + $join.call(ys, ', ') + ' }';
          }
          return String(obj);
        };
        function wrapQuotes(s, defaultStyle, opts) {
          var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
          return quoteChar + s + quoteChar;
        }
        function quote(s) {
          return $replace.call(String(s), /"/g, '&quot;');
        }
        function isArray$3(obj) {
          return toStr(obj) === '[object Array]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
        }
        function isDate(obj) {
          return toStr(obj) === '[object Date]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
        }
        function isRegExp$1(obj) {
          return toStr(obj) === '[object RegExp]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
        }
        function isError(obj) {
          return toStr(obj) === '[object Error]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
        }
        function isString(obj) {
          return toStr(obj) === '[object String]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
        }
        function isNumber(obj) {
          return toStr(obj) === '[object Number]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
        }
        function isBoolean(obj) {
          return toStr(obj) === '[object Boolean]' && (!toStringTag || !(_typeof(obj) === 'object' && toStringTag in obj));
        }

        // Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
        function isSymbol(obj) {
          if (hasShammedSymbols) {
            return obj && _typeof(obj) === 'object' && obj instanceof Symbol;
          }
          if (_typeof(obj) === 'symbol') {
            return true;
          }
          if (!obj || _typeof(obj) !== 'object' || !symToString) {
            return false;
          }
          try {
            symToString.call(obj);
            return true;
          } catch (e) {}
          return false;
        }
        function isBigInt(obj) {
          if (!obj || _typeof(obj) !== 'object' || !bigIntValueOf) {
            return false;
          }
          try {
            bigIntValueOf.call(obj);
            return true;
          } catch (e) {}
          return false;
        }
        var hasOwn = Object.prototype.hasOwnProperty || function (key) {
          return key in this;
        };
        function has$3(obj, key) {
          return hasOwn.call(obj, key);
        }
        function toStr(obj) {
          return objectToString.call(obj);
        }
        function nameOf(f) {
          if (f.name) {
            return f.name;
          }
          var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
          if (m) {
            return m[1];
          }
          return null;
        }
        function indexOf(xs, x) {
          if (xs.indexOf) {
            return xs.indexOf(x);
          }
          for (var i = 0, l = xs.length; i < l; i++) {
            if (xs[i] === x) {
              return i;
            }
          }
          return -1;
        }
        function isMap(x) {
          if (!mapSize || !x || _typeof(x) !== 'object') {
            return false;
          }
          try {
            mapSize.call(x);
            try {
              setSize.call(x);
            } catch (s) {
              return true;
            }
            return x instanceof Map; // core-js workaround, pre-v2.5.0
          } catch (e) {}
          return false;
        }
        function isWeakMap(x) {
          if (!weakMapHas || !x || _typeof(x) !== 'object') {
            return false;
          }
          try {
            weakMapHas.call(x, weakMapHas);
            try {
              weakSetHas.call(x, weakSetHas);
            } catch (s) {
              return true;
            }
            return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
          } catch (e) {}
          return false;
        }
        function isWeakRef(x) {
          if (!weakRefDeref || !x || _typeof(x) !== 'object') {
            return false;
          }
          try {
            weakRefDeref.call(x);
            return true;
          } catch (e) {}
          return false;
        }
        function isSet(x) {
          if (!setSize || !x || _typeof(x) !== 'object') {
            return false;
          }
          try {
            setSize.call(x);
            try {
              mapSize.call(x);
            } catch (m) {
              return true;
            }
            return x instanceof Set; // core-js workaround, pre-v2.5.0
          } catch (e) {}
          return false;
        }
        function isWeakSet(x) {
          if (!weakSetHas || !x || _typeof(x) !== 'object') {
            return false;
          }
          try {
            weakSetHas.call(x, weakSetHas);
            try {
              weakMapHas.call(x, weakMapHas);
            } catch (s) {
              return true;
            }
            return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
          } catch (e) {}
          return false;
        }
        function isElement(x) {
          if (!x || _typeof(x) !== 'object') {
            return false;
          }
          if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
            return true;
          }
          return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
        }
        function inspectString(str, opts) {
          if (str.length > opts.maxStringLength) {
            var remaining = str.length - opts.maxStringLength;
            var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
            return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
          }
          // eslint-disable-next-line no-control-regex
          var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
          return wrapQuotes(s, 'single', opts);
        }
        function lowbyte(c) {
          var n = c.charCodeAt(0);
          var x = {
            8: 'b',
            9: 't',
            10: 'n',
            12: 'f',
            13: 'r'
          }[n];
          if (x) {
            return '\\' + x;
          }
          return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
        }
        function markBoxed(str) {
          return 'Object(' + str + ')';
        }
        function weakCollectionOf(type) {
          return type + ' { ? }';
        }
        function collectionOf(type, size, entries, indent) {
          var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
          return type + ' (' + size + ') {' + joinedEntries + '}';
        }
        function singleLineValues(xs) {
          for (var i = 0; i < xs.length; i++) {
            if (indexOf(xs[i], '\n') >= 0) {
              return false;
            }
          }
          return true;
        }
        function getIndent(opts, depth) {
          var baseIndent;
          if (opts.indent === '\t') {
            baseIndent = '\t';
          } else if (typeof opts.indent === 'number' && opts.indent > 0) {
            baseIndent = $join.call(Array(opts.indent + 1), ' ');
          } else {
            return null;
          }
          return {
            base: baseIndent,
            prev: $join.call(Array(depth + 1), baseIndent)
          };
        }
        function indentedJoin(xs, indent) {
          if (xs.length === 0) {
            return '';
          }
          var lineJoiner = '\n' + indent.prev + indent.base;
          return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
        }
        function arrObjKeys(obj, inspect) {
          var isArr = isArray$3(obj);
          var xs = [];
          if (isArr) {
            xs.length = obj.length;
            for (var i = 0; i < obj.length; i++) {
              xs[i] = has$3(obj, i) ? inspect(obj[i], obj) : '';
            }
          }
          var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
          var symMap;
          if (hasShammedSymbols) {
            symMap = {};
            for (var k = 0; k < syms.length; k++) {
              symMap['$' + syms[k]] = syms[k];
            }
          }
          for (var key in obj) {
            // eslint-disable-line no-restricted-syntax
            if (!has$3(obj, key)) {
              continue;
            } // eslint-disable-line no-restricted-syntax, no-continue
            if (isArr && String(Number(key)) === key && key < obj.length) {
              continue;
            } // eslint-disable-line no-restricted-syntax, no-continue
            if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
              // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
              continue; // eslint-disable-line no-restricted-syntax, no-continue
            } else if ($test.call(/[^\w$]/, key)) {
              xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
            } else {
              xs.push(key + ': ' + inspect(obj[key], obj));
            }
          }
          if (typeof gOPS === 'function') {
            for (var j = 0; j < syms.length; j++) {
              if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
              }
            }
          }
          return xs;
        }
        var GetIntrinsic = getIntrinsic;
        var callBound = callBound$1;
        var inspect = objectInspect;
        var $TypeError = GetIntrinsic('%TypeError%');
        var $WeakMap = GetIntrinsic('%WeakMap%', true);
        var $Map = GetIntrinsic('%Map%', true);
        var $weakMapGet = callBound('WeakMap.prototype.get', true);
        var $weakMapSet = callBound('WeakMap.prototype.set', true);
        var $weakMapHas = callBound('WeakMap.prototype.has', true);
        var $mapGet = callBound('Map.prototype.get', true);
        var $mapSet = callBound('Map.prototype.set', true);
        var $mapHas = callBound('Map.prototype.has', true);

        /*
         * This function traverses the list returning the node corresponding to the
         * given key.
         *
         * That node is also moved to the head of the list, so that if it's accessed
         * again we don't need to traverse the whole list. By doing so, all the recently
         * used nodes can be accessed relatively quickly.
         */
        var listGetNode = function listGetNode(list, key) {
          // eslint-disable-line consistent-return
          for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
            if (curr.key === key) {
              prev.next = curr.next;
              curr.next = list.next;
              list.next = curr; // eslint-disable-line no-param-reassign
              return curr;
            }
          }
        };
        var listGet = function listGet(objects, key) {
          var node = listGetNode(objects, key);
          return node && node.value;
        };
        var listSet = function listSet(objects, key, value) {
          var node = listGetNode(objects, key);
          if (node) {
            node.value = value;
          } else {
            // Prepend the new node to the beginning of the list
            objects.next = {
              // eslint-disable-line no-param-reassign
              key: key,
              next: objects.next,
              value: value
            };
          }
        };
        var listHas = function listHas(objects, key) {
          return !!listGetNode(objects, key);
        };
        var sideChannel = function getSideChannel() {
          var $wm;
          var $m;
          var $o;
          var channel = {
            assert: function assert(key) {
              if (!channel.has(key)) {
                throw new $TypeError('Side channel does not contain ' + inspect(key));
              }
            },
            get: function get(key) {
              // eslint-disable-line consistent-return
              if ($WeakMap && key && (_typeof(key) === 'object' || typeof key === 'function')) {
                if ($wm) {
                  return $weakMapGet($wm, key);
                }
              } else if ($Map) {
                if ($m) {
                  return $mapGet($m, key);
                }
              } else {
                if ($o) {
                  // eslint-disable-line no-lonely-if
                  return listGet($o, key);
                }
              }
            },
            has: function has(key) {
              if ($WeakMap && key && (_typeof(key) === 'object' || typeof key === 'function')) {
                if ($wm) {
                  return $weakMapHas($wm, key);
                }
              } else if ($Map) {
                if ($m) {
                  return $mapHas($m, key);
                }
              } else {
                if ($o) {
                  // eslint-disable-line no-lonely-if
                  return listHas($o, key);
                }
              }
              return false;
            },
            set: function set(key, value) {
              if ($WeakMap && key && (_typeof(key) === 'object' || typeof key === 'function')) {
                if (!$wm) {
                  $wm = new $WeakMap();
                }
                $weakMapSet($wm, key, value);
              } else if ($Map) {
                if (!$m) {
                  $m = new $Map();
                }
                $mapSet($m, key, value);
              } else {
                if (!$o) {
                  /*
                   * Initialize the linked list as an empty node, so that we don't have
                   * to special-case handling of the first node: we can always refer to
                   * it as (previous node).next, instead of something like (list).head
                   */
                  $o = {
                    key: {},
                    next: null
                  };
                }
                listSet($o, key, value);
              }
            }
          };
          return channel;
        };
        var replace = String.prototype.replace;
        var percentTwenties = /%20/g;
        var Format = {
          RFC1738: 'RFC1738',
          RFC3986: 'RFC3986'
        };
        var formats$3 = {
          'default': Format.RFC3986,
          formatters: {
            RFC1738: function RFC1738(value) {
              return replace.call(value, percentTwenties, '+');
            },
            RFC3986: function RFC3986(value) {
              return String(value);
            }
          },
          RFC1738: Format.RFC1738,
          RFC3986: Format.RFC3986
        };
        var formats$2 = formats$3;
        var has$2 = Object.prototype.hasOwnProperty;
        var isArray$2 = Array.isArray;
        var hexTable = function () {
          var array = [];
          for (var i = 0; i < 256; ++i) {
            array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
          }
          return array;
        }();
        var compactQueue = function compactQueue(queue) {
          while (queue.length > 1) {
            var item = queue.pop();
            var obj = item.obj[item.prop];
            if (isArray$2(obj)) {
              var compacted = [];
              for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                  compacted.push(obj[j]);
                }
              }
              item.obj[item.prop] = compacted;
            }
          }
        };
        var arrayToObject = function arrayToObject(source, options) {
          var obj = options && options.plainObjects ? Object.create(null) : {};
          for (var i = 0; i < source.length; ++i) {
            if (typeof source[i] !== 'undefined') {
              obj[i] = source[i];
            }
          }
          return obj;
        };
        var merge = function merge(target, source, options) {
          /* eslint no-param-reassign: 0 */
          if (!source) {
            return target;
          }
          if (_typeof(source) !== 'object') {
            if (isArray$2(target)) {
              target.push(source);
            } else if (target && _typeof(target) === 'object') {
              if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
                target[source] = true;
              }
            } else {
              return [target, source];
            }
            return target;
          }
          if (!target || _typeof(target) !== 'object') {
            return [target].concat(source);
          }
          var mergeTarget = target;
          if (isArray$2(target) && !isArray$2(source)) {
            mergeTarget = arrayToObject(target, options);
          }
          if (isArray$2(target) && isArray$2(source)) {
            source.forEach(function (item, i) {
              if (has$2.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && _typeof(targetItem) === 'object' && item && _typeof(item) === 'object') {
                  target[i] = merge(targetItem, item, options);
                } else {
                  target.push(item);
                }
              } else {
                target[i] = item;
              }
            });
            return target;
          }
          return Object.keys(source).reduce(function (acc, key) {
            var value = source[key];
            if (has$2.call(acc, key)) {
              acc[key] = merge(acc[key], value, options);
            } else {
              acc[key] = value;
            }
            return acc;
          }, mergeTarget);
        };
        var assign = function assignSingleSource(target, source) {
          return Object.keys(source).reduce(function (acc, key) {
            acc[key] = source[key];
            return acc;
          }, target);
        };
        var decode = function decode(str, decoder, charset) {
          var strWithoutPlus = str.replace(/\+/g, ' ');
          if (charset === 'iso-8859-1') {
            // unescape never throws, no try...catch needed:
            return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
          }
          // utf-8
          try {
            return decodeURIComponent(strWithoutPlus);
          } catch (e) {
            return strWithoutPlus;
          }
        };
        var encode = function encode(str, defaultEncoder, charset, kind, format) {
          // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
          // It has been adapted here for stricter adherence to RFC 3986
          if (str.length === 0) {
            return str;
          }
          var string = str;
          if (_typeof(str) === 'symbol') {
            string = Symbol.prototype.toString.call(str);
          } else if (typeof str !== 'string') {
            string = String(str);
          }
          if (charset === 'iso-8859-1') {
            return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
              return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
            });
          }
          var out = '';
          for (var i = 0; i < string.length; ++i) {
            var c = string.charCodeAt(i);
            if (c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || c >= 0x30 && c <= 0x39 // 0-9
            || c >= 0x41 && c <= 0x5A // a-z
            || c >= 0x61 && c <= 0x7A // A-Z
            || format === formats$2.RFC1738 && (c === 0x28 || c === 0x29) // ( )
            ) {
              out += string.charAt(i);
              continue;
            }
            if (c < 0x80) {
              out = out + hexTable[c];
              continue;
            }
            if (c < 0x800) {
              out = out + (hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F]);
              continue;
            }
            if (c < 0xD800 || c >= 0xE000) {
              out = out + (hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F]);
              continue;
            }
            i += 1;
            c = 0x10000 + ((c & 0x3FF) << 10 | string.charCodeAt(i) & 0x3FF);
            /* eslint operator-linebreak: [2, "before"] */
            out += hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
          }
          return out;
        };
        var compact = function compact(value) {
          var queue = [{
            obj: {
              o: value
            },
            prop: 'o'
          }];
          var refs = [];
          for (var i = 0; i < queue.length; ++i) {
            var item = queue[i];
            var obj = item.obj[item.prop];
            var keys = Object.keys(obj);
            for (var j = 0; j < keys.length; ++j) {
              var key = keys[j];
              var val = obj[key];
              if (_typeof(val) === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({
                  obj: obj,
                  prop: key
                });
                refs.push(val);
              }
            }
          }
          compactQueue(queue);
          return value;
        };
        var isRegExp = function isRegExp(obj) {
          return Object.prototype.toString.call(obj) === '[object RegExp]';
        };
        var isBuffer = function isBuffer(obj) {
          if (!obj || _typeof(obj) !== 'object') {
            return false;
          }
          return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
        };
        var combine = function combine(a, b) {
          return [].concat(a, b);
        };
        var maybeMap = function maybeMap(val, fn) {
          if (isArray$2(val)) {
            var mapped = [];
            for (var i = 0; i < val.length; i += 1) {
              mapped.push(fn(val[i]));
            }
            return mapped;
          }
          return fn(val);
        };
        var utils$2 = {
          arrayToObject: arrayToObject,
          assign: assign,
          combine: combine,
          compact: compact,
          decode: decode,
          encode: encode,
          isBuffer: isBuffer,
          isRegExp: isRegExp,
          maybeMap: maybeMap,
          merge: merge
        };
        var getSideChannel = sideChannel;
        var utils$1 = utils$2;
        var formats$1 = formats$3;
        var has$1 = Object.prototype.hasOwnProperty;
        var arrayPrefixGenerators = {
          brackets: function brackets(prefix) {
            return prefix + '[]';
          },
          comma: 'comma',
          indices: function indices(prefix, key) {
            return prefix + '[' + key + ']';
          },
          repeat: function repeat(prefix) {
            return prefix;
          }
        };
        var isArray$1 = Array.isArray;
        var split = String.prototype.split;
        var push = Array.prototype.push;
        var pushToArray = function pushToArray(arr, valueOrArray) {
          push.apply(arr, isArray$1(valueOrArray) ? valueOrArray : [valueOrArray]);
        };
        var toISO = Date.prototype.toISOString;
        var defaultFormat = formats$1['default'];
        var defaults$1 = {
          addQueryPrefix: false,
          allowDots: false,
          charset: 'utf-8',
          charsetSentinel: false,
          delimiter: '&',
          encode: true,
          encoder: utils$1.encode,
          encodeValuesOnly: false,
          format: defaultFormat,
          formatter: formats$1.formatters[defaultFormat],
          // deprecated
          indices: false,
          serializeDate: function serializeDate(date) {
            return toISO.call(date);
          },
          skipNulls: false,
          strictNullHandling: false
        };
        var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
          return typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || _typeof(v) === 'symbol' || typeof v === 'bigint';
        };
        var sentinel = {};
        var stringify$1 = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
          var obj = object;
          var tmpSc = sideChannel;
          var step = 0;
          var findFlag = false;
          while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
            // Where object last appeared in the ref tree
            var pos = tmpSc.get(object);
            step += 1;
            if (typeof pos !== 'undefined') {
              if (pos === step) {
                throw new RangeError('Cyclic object value');
              } else {
                findFlag = true; // Break while
              }
            }

            if (typeof tmpSc.get(sentinel) === 'undefined') {
              step = 0;
            }
          }
          if (typeof filter === 'function') {
            obj = filter(prefix, obj);
          } else if (obj instanceof Date) {
            obj = serializeDate(obj);
          } else if (generateArrayPrefix === 'comma' && isArray$1(obj)) {
            obj = utils$1.maybeMap(obj, function (value) {
              if (value instanceof Date) {
                return serializeDate(value);
              }
              return value;
            });
          }
          if (obj === null) {
            if (strictNullHandling) {
              return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, 'key', format) : prefix;
            }
            obj = '';
          }
          if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
            if (encoder) {
              var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, 'key', format);
              if (generateArrayPrefix === 'comma' && encodeValuesOnly) {
                var valuesArray = split.call(String(obj), ',');
                var valuesJoined = '';
                for (var i = 0; i < valuesArray.length; ++i) {
                  valuesJoined += (i === 0 ? '' : ',') + formatter(encoder(valuesArray[i], defaults$1.encoder, charset, 'value', format));
                }
                return [formatter(keyValue) + (commaRoundTrip && isArray$1(obj) && valuesArray.length === 1 ? '[]' : '') + '=' + valuesJoined];
              }
              return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults$1.encoder, charset, 'value', format))];
            }
            return [formatter(prefix) + '=' + formatter(String(obj))];
          }
          var values = [];
          if (typeof obj === 'undefined') {
            return values;
          }
          var objKeys;
          if (generateArrayPrefix === 'comma' && isArray$1(obj)) {
            // we need to join elements in
            objKeys = [{
              value: obj.length > 0 ? obj.join(',') || null : void undefined
            }];
          } else if (isArray$1(filter)) {
            objKeys = filter;
          } else {
            var keys = Object.keys(obj);
            objKeys = sort ? keys.sort(sort) : keys;
          }
          var adjustedPrefix = commaRoundTrip && isArray$1(obj) && obj.length === 1 ? prefix + '[]' : prefix;
          for (var j = 0; j < objKeys.length; ++j) {
            var key = objKeys[j];
            var value = _typeof(key) === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];
            if (skipNulls && value === null) {
              continue;
            }
            var keyPrefix = isArray$1(obj) ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? '.' + key : '[' + key + ']');
            sideChannel.set(object, step);
            var valueSideChannel = getSideChannel();
            valueSideChannel.set(sentinel, sideChannel);
            pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
          }
          return values;
        };
        var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
          if (!opts) {
            return defaults$1;
          }
          if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
            throw new TypeError('Encoder has to be a function.');
          }
          var charset = opts.charset || defaults$1.charset;
          if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
            throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
          }
          var format = formats$1['default'];
          if (typeof opts.format !== 'undefined') {
            if (!has$1.call(formats$1.formatters, opts.format)) {
              throw new TypeError('Unknown format option provided.');
            }
            format = opts.format;
          }
          var formatter = formats$1.formatters[format];
          var filter = defaults$1.filter;
          if (typeof opts.filter === 'function' || isArray$1(opts.filter)) {
            filter = opts.filter;
          }
          return {
            addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
            allowDots: typeof opts.allowDots === 'undefined' ? defaults$1.allowDots : !!opts.allowDots,
            charset: charset,
            charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults$1.charsetSentinel,
            delimiter: typeof opts.delimiter === 'undefined' ? defaults$1.delimiter : opts.delimiter,
            encode: typeof opts.encode === 'boolean' ? opts.encode : defaults$1.encode,
            encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults$1.encoder,
            encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
            filter: filter,
            format: format,
            formatter: formatter,
            serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults$1.serializeDate,
            skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults$1.skipNulls,
            sort: typeof opts.sort === 'function' ? opts.sort : null,
            strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults$1.strictNullHandling
          };
        };
        var stringify_1 = function stringify_1(object, opts) {
          var obj = object;
          var options = normalizeStringifyOptions(opts);
          var objKeys;
          var filter;
          if (typeof options.filter === 'function') {
            filter = options.filter;
            obj = filter('', obj);
          } else if (isArray$1(options.filter)) {
            filter = options.filter;
            objKeys = filter;
          }
          var keys = [];
          if (_typeof(obj) !== 'object' || obj === null) {
            return '';
          }
          var arrayFormat;
          if (opts && opts.arrayFormat in arrayPrefixGenerators) {
            arrayFormat = opts.arrayFormat;
          } else if (opts && 'indices' in opts) {
            arrayFormat = opts.indices ? 'indices' : 'repeat';
          } else {
            arrayFormat = 'indices';
          }
          var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
          if (opts && 'commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
            throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
          }
          var commaRoundTrip = generateArrayPrefix === 'comma' && opts && opts.commaRoundTrip;
          if (!objKeys) {
            objKeys = Object.keys(obj);
          }
          if (options.sort) {
            objKeys.sort(options.sort);
          }
          var sideChannel = getSideChannel();
          for (var i = 0; i < objKeys.length; ++i) {
            var key = objKeys[i];
            if (options.skipNulls && obj[key] === null) {
              continue;
            }
            pushToArray(keys, stringify$1(obj[key], key, generateArrayPrefix, commaRoundTrip, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
          }
          var joined = keys.join(options.delimiter);
          var prefix = options.addQueryPrefix === true ? '?' : '';
          if (options.charsetSentinel) {
            if (options.charset === 'iso-8859-1') {
              // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
              prefix += 'utf8=%26%2310003%3B&';
            } else {
              // encodeURIComponent('✓')
              prefix += 'utf8=%E2%9C%93&';
            }
          }
          return joined.length > 0 ? prefix + joined : '';
        };
        var utils = utils$2;
        var has = Object.prototype.hasOwnProperty;
        var isArray = Array.isArray;
        var defaults = {
          allowDots: false,
          allowPrototypes: false,
          allowSparse: false,
          arrayLimit: 20,
          charset: 'utf-8',
          charsetSentinel: false,
          comma: false,
          decoder: utils.decode,
          delimiter: '&',
          depth: 5,
          ignoreQueryPrefix: false,
          interpretNumericEntities: false,
          parameterLimit: 1000,
          parseArrays: true,
          plainObjects: false,
          strictNullHandling: false
        };
        var interpretNumericEntities = function interpretNumericEntities(str) {
          return str.replace(/&#(\d+);/g, function ($0, numberStr) {
            return String.fromCharCode(parseInt(numberStr, 10));
          });
        };
        var parseArrayValue = function parseArrayValue(val, options) {
          if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
            return val.split(',');
          }
          return val;
        };

        // This is what browsers will submit when the ✓ character occurs in an
        // application/x-www-form-urlencoded body and the encoding of the page containing
        // the form is iso-8859-1, or when the submitted form has an accept-charset
        // attribute of iso-8859-1. Presumably also with other charsets that do not contain
        // the ✓ character, such as us-ascii.
        var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

        // These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
        var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

        var parseValues = function parseQueryStringValues(str, options) {
          var obj = {};
          var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
          var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
          var parts = cleanStr.split(options.delimiter, limit);
          var skipIndex = -1; // Keep track of where the utf8 sentinel was found
          var i;
          var charset = options.charset;
          if (options.charsetSentinel) {
            for (i = 0; i < parts.length; ++i) {
              if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                  charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                  charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
              }
            }
          }

          for (i = 0; i < parts.length; ++i) {
            if (i === skipIndex) {
              continue;
            }
            var part = parts[i];
            var bracketEqualsPos = part.indexOf(']=');
            var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
            var key, val;
            if (pos === -1) {
              key = options.decoder(part, defaults.decoder, charset, 'key');
              val = options.strictNullHandling ? null : '';
            } else {
              key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
              val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function (encodedVal) {
                return options.decoder(encodedVal, defaults.decoder, charset, 'value');
              });
            }
            if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
              val = interpretNumericEntities(val);
            }
            if (part.indexOf('[]=') > -1) {
              val = isArray(val) ? [val] : val;
            }
            if (has.call(obj, key)) {
              obj[key] = utils.combine(obj[key], val);
            } else {
              obj[key] = val;
            }
          }
          return obj;
        };
        var parseObject = function parseObject(chain, val, options, valuesParsed) {
          var leaf = valuesParsed ? val : parseArrayValue(val, options);
          for (var i = chain.length - 1; i >= 0; --i) {
            var obj;
            var root = chain[i];
            if (root === '[]' && options.parseArrays) {
              obj = [].concat(leaf);
            } else {
              obj = options.plainObjects ? Object.create(null) : {};
              var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
              var index = parseInt(cleanRoot, 10);
              if (!options.parseArrays && cleanRoot === '') {
                obj = {
                  0: leaf
                };
              } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
                obj = [];
                obj[index] = leaf;
              } else if (cleanRoot !== '__proto__') {
                obj[cleanRoot] = leaf;
              }
            }
            leaf = obj;
          }
          return leaf;
        };
        var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
          if (!givenKey) {
            return;
          }

          // Transform dot notation to bracket notation
          var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

          // The regex chunks

          var brackets = /(\[[^[\]]*])/;
          var child = /(\[[^[\]]*])/g;

          // Get the parent

          var segment = options.depth > 0 && brackets.exec(key);
          var parent = segment ? key.slice(0, segment.index) : key;

          // Stash the parent if it exists

          var keys = [];
          if (parent) {
            // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
            if (!options.plainObjects && has.call(Object.prototype, parent)) {
              if (!options.allowPrototypes) {
                return;
              }
            }
            keys.push(parent);
          }

          // Loop through children appending to the array until we hit depth

          var i = 0;
          while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
            i += 1;
            if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
              if (!options.allowPrototypes) {
                return;
              }
            }
            keys.push(segment[1]);
          }

          // If there's a remainder, just add whatever is left

          if (segment) {
            keys.push('[' + key.slice(segment.index) + ']');
          }
          return parseObject(keys, val, options, valuesParsed);
        };
        var normalizeParseOptions = function normalizeParseOptions(opts) {
          if (!opts) {
            return defaults;
          }
          if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
            throw new TypeError('Decoder has to be a function.');
          }
          if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
            throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
          }
          var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;
          return {
            allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
            allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
            allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
            arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
            charset: charset,
            charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
            comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
            decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
            delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
            // eslint-disable-next-line no-implicit-coercion, no-extra-parens
            depth: typeof opts.depth === 'number' || opts.depth === false ? +opts.depth : defaults.depth,
            ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
            interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
            parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
            parseArrays: opts.parseArrays !== false,
            plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
            strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
          };
        };
        var parse$1 = function parse$1(str, opts) {
          var options = normalizeParseOptions(opts);
          if (str === '' || str === null || typeof str === 'undefined') {
            return options.plainObjects ? Object.create(null) : {};
          }
          var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
          var obj = options.plainObjects ? Object.create(null) : {};

          // Iterate over the keys and setup the new object

          var keys = Object.keys(tempObj);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
            obj = utils.merge(obj, newObj, options);
          }
          if (options.allowSparse === true) {
            return obj;
          }
          return utils.compact(obj);
        };
        var stringify = stringify_1;
        var parse = parse$1;
        var formats = formats$3;
        var lib = {
          formats: formats,
          parse: parse,
          stringify: stringify
        };
        function constructLink(parameters) {
          var link = lib.stringify(parameters);
          return link;
        }
        function parseLink(queryString) {
          var parameters = lib.parse(queryString);
          return sanitizeParameters(parameters);
        }
        function storeInLocalStorage(parameters) {
          Object.entries(parameters).forEach(function (_ref62) {
            var _ref63 = _slicedToArray(_ref62, 2),
              k = _ref63[0],
              v = _ref63[1];
            localStorage.setItem(k, v);
          });
        }
        function sanitizeParameters(parameters) {
          var sanitized = {};
          if ('frequency' in parameters && isNumber$1(parameters.frequency)) {
            sanitized.frequency = parseFloat(parameters.frequency);
          }
          if ('modulation' in parameters) {
            sanitized.modulation = parameters.modulation.toUpperCase();
          }
          return sanitized;
        }
        function WorkerWrapper() {
          return new Worker("/assets/decoding-904100a3.js");
        }
        var Decoder = /*#__PURE__*/function () {
          function Decoder(name, samplerate, callback) {
            var _this39 = this;
            _classCallCheck(this, Decoder);
            this.decoder = new WorkerWrapper();
            this.decoder.postMessage({
              msg: 'init',
              decoder: name,
              samplerate: samplerate
            });
            this.callback = callback;
            this.initializedPromise = new Promise(function (resolve, reject) {
              _this39.initializedResolve = resolve;
              _this39.initializedReject = reject;
            });
            this.decoder.onmessage = function (ev) {
              if (ev.data.type === 'log') {
                callback(ev.data.text);
              } else if (ev.data.type === 'initialized') {
                _this39.initializedResolve();
              }
            };
          }
          _createClass(Decoder, [{
            key: "setCallback",
            value: function setCallback(callback) {
              this.callback = callback;
            }
          }, {
            key: "decode",
            value: function decode(pcm) {
              this.decoder.postMessage({
                msg: 'pcm',
                pcm: pcm
              }, pcm.buffer);
            }
          }, {
            key: "promise",
            value: function promise() {
              return this.initializedPromise;
            }
          }, {
            key: "stop",
            value: function stop() {
              this.decoder.terminate();
            }
          }]);
          return Decoder;
        }();
        var App_svelte_svelte_type_style_lang = '';

        /* src/App.svelte generated by Svelte v3.55.0 */

        var window_1 = globals.window;
        function get_each_context(ctx, list, i) {
          var child_ctx = ctx.slice();
          child_ctx[98] = list[i];
          return child_ctx;
        }
        function get_each_context_1(ctx, list, i) {
          var child_ctx = ctx.slice();
          child_ctx[101] = list[i];
          return child_ctx;
        }
        function get_each_context_2(ctx, list, i) {
          var child_ctx = ctx.slice();
          child_ctx[104] = list[i];
          return child_ctx;
        }
        function get_each_context_3(ctx, list, i) {
          var child_ctx = ctx.slice();
          child_ctx[107] = list[i];
          return child_ctx;
        }

        // (499:14) {#each demodulators as demodulator (demodulator)}
        function create_each_block_3(key_1, ctx) {
          var label;
          var input;
          var input_value_value;
          var t0;
          var div;
          var t1_value = /*demodulator*/ctx[107] + "";
          var t1;
          var t2;
          var mounted;
          var dispose;
          return {
            key: key_1,
            first: null,
            c: function c() {
              label = element("label");
              input = element("input");
              t0 = space();
              div = element("div");
              t1 = text(t1_value);
              t2 = space();
              attr(input, "type", "radio");
              attr(input, "class", "hidden peer");
              attr(input, "name", "demodulation");
              input.__value = input_value_value = /*demodulator*/ctx[107];
              input.value = input.__value;
              attr(input, "autocomplete", "off");
              /*$$binding_groups*/
              ctx[64][0].push(input);
              attr(div, "class", "basic-button m-1");
              attr(div, "type", "button");
              this.first = label;
            },
            m: function m(target, anchor) {
              insert(target, label, anchor);
              append(label, input);
              input.checked = input.__value === /*demodulation*/ctx[14];
              append(label, t0);
              append(label, div);
              append(div, t1);
              append(label, t2);
              if (!mounted) {
                dispose = [listen(input, "change", /*input_change_handler*/ctx[63]), listen(input, "click", /*click_handler*/ctx[65]), listen(input, "change", /*change_handler*/ctx[66])];
                mounted = true;
              }
            },
            p: function p(new_ctx, dirty) {
              ctx = new_ctx;
              if (dirty[0] & /*demodulators*/8192 && input_value_value !== (input_value_value = /*demodulator*/ctx[107])) {
                input.__value = input_value_value;
                input.value = input.__value;
              }
              if (dirty[0] & /*demodulation*/16384) {
                input.checked = input.__value === /*demodulation*/ctx[14];
              }
              if (dirty[0] & /*demodulators*/8192 && t1_value !== (t1_value = /*demodulator*/ctx[107] + "")) set_data(t1, t1_value);
            },
            d: function d(detaching) {
              if (detaching) detach(label);
              /*$$binding_groups*/
              ctx[64][0].splice( /*$$binding_groups*/ctx[64][0].indexOf(input), 1);
              mounted = false;
              run_all(dispose);
            }
          };
        }

        // (513:12) {#each bandwithoffsets as bandwidthoffset (bandwidthoffset)}
        function create_each_block_2(key_1, ctx) {
          var button;
          var t_value = /*bandwidthoffset*/ctx[104] + "";
          var t;
          var button_data_expand_value;
          var mounted;
          var dispose;
          function click_handler_1() {
            var _ctx;
            for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
              args[_key10] = arguments[_key10];
            }
            return (/*click_handler_1*/(_ctx = ctx)[67].apply(_ctx, [/*bandwidthoffset*/ctx[104]].concat(args))
            );
          }
          return {
            key: key_1,
            first: null,
            c: function c() {
              button = element("button");
              t = text(t_value);
              attr(button, "class", "click-button w-1/4");
              attr(button, "data-expand", button_data_expand_value = /*bandwidthoffset*/ctx[104]);
              this.first = button;
            },
            m: function m(target, anchor) {
              insert(target, button, anchor);
              append(button, t);
              if (!mounted) {
                dispose = listen(button, "click", click_handler_1);
                mounted = true;
              }
            },
            p: function p(new_ctx, dirty) {
              ctx = new_ctx;
              if (dirty[0] & /*bandwithoffsets*/2097152 && t_value !== (t_value = /*bandwidthoffset*/ctx[104] + "")) set_data(t, t_value);
              if (dirty[0] & /*bandwithoffsets*/2097152 && button_data_expand_value !== (button_data_expand_value = /*bandwidthoffset*/ctx[104])) {
                attr(button, "data-expand", button_data_expand_value);
              }
            },
            d: function d(detaching) {
              if (detaching) detach(button);
              mounted = false;
              dispose();
            }
          };
        }

        // (576:14) <LineThroughButton name="NR" on:change={handleNRChange} bind:checked={NREnabled}>
        function create_default_slot_2(ctx) {
          var tooltip;
          var current;
          tooltip = new Tooltip({
            props: {
              text: "Noise Reduction"
            }
          });
          return {
            c: function c() {
              create_component(tooltip.$$.fragment);
            },
            m: function m(target, anchor) {
              mount_component(tooltip, target, anchor);
              current = true;
            },
            p: noop,
            i: function i(local) {
              if (current) return;
              transition_in(tooltip.$$.fragment, local);
              current = true;
            },
            o: function o(local) {
              transition_out(tooltip.$$.fragment, local);
              current = false;
            },
            d: function d(detaching) {
              destroy_component(tooltip, detaching);
            }
          };
        }

        // (579:14) <LineThroughButton name="NB" on:change={handleNBChange} bind:checked={NBEnabled}>
        function create_default_slot_1(ctx) {
          var tooltip;
          var current;
          tooltip = new Tooltip({
            props: {
              text: "Noise Blanker"
            }
          });
          return {
            c: function c() {
              create_component(tooltip.$$.fragment);
            },
            m: function m(target, anchor) {
              mount_component(tooltip, target, anchor);
              current = true;
            },
            p: noop,
            i: function i(local) {
              if (current) return;
              transition_in(tooltip.$$.fragment, local);
              current = true;
            },
            o: function o(local) {
              transition_out(tooltip.$$.fragment, local);
              current = false;
            },
            d: function d(detaching) {
              destroy_component(tooltip, detaching);
            }
          };
        }

        // (582:14) <LineThroughButton name="AN" on:change={handleANChange} bind:checked={ANEnabled}>
        function create_default_slot(ctx) {
          var tooltip;
          var current;
          tooltip = new Tooltip({
            props: {
              text: "Autonotch"
            }
          });
          return {
            c: function c() {
              create_component(tooltip.$$.fragment);
            },
            m: function m(target, anchor) {
              mount_component(tooltip, target, anchor);
              current = true;
            },
            p: noop,
            i: function i(local) {
              if (current) return;
              transition_in(tooltip.$$.fragment, local);
              current = true;
            },
            o: function o(local) {
              transition_out(tooltip.$$.fragment, local);
              current = false;
            },
            d: function d(detaching) {
              destroy_component(tooltip, detaching);
            }
          };
        }

        // (631:16) {#each availableColormaps as colormap}
        function create_each_block_1(ctx) {
          var option;
          var t0_value = /*colormap*/ctx[101] + "";
          var t0;
          var t1;
          return {
            c: function c() {
              option = element("option");
              t0 = text(t0_value);
              t1 = space();
              attr(option, "class", "m-auto p-auto text-xs bg-black");
              option.__value = /*colormap*/ctx[101];
              option.value = option.__value;
            },
            m: function m(target, anchor) {
              insert(target, option, anchor);
              append(option, t0);
              append(option, t1);
            },
            p: noop,
            d: function d(detaching) {
              if (detaching) detach(option);
            }
          };
        }

        // (661:14) {#each decoders as decoder (decoder)}
        function create_each_block(key_1, ctx) {
          var label;
          var input;
          var t0;
          var div;
          var t1_value = /*decoder*/ctx[98] + "";
          var t1;
          var t2;
          var mounted;
          var dispose;
          return {
            key: key_1,
            first: null,
            c: function c() {
              label = element("label");
              input = element("input");
              t0 = space();
              div = element("div");
              t1 = text(t1_value);
              t2 = space();
              attr(input, "type", "radio");
              attr(input, "class", "hidden peer");
              attr(input, "name", "decoder");
              input.__value = /*decoder*/ctx[98];
              input.value = input.__value;
              attr(input, "autocomplete", "off");
              /*$$binding_groups*/
              ctx[64][1].push(input);
              attr(div, "class", "basic-button m-1");
              attr(div, "type", "button");
              this.first = label;
            },
            m: function m(target, anchor) {
              insert(target, label, anchor);
              append(label, input);
              input.checked = input.__value === /*signalDecoder*/ctx[27];
              append(label, t0);
              append(label, div);
              append(div, t1);
              append(label, t2);
              if (!mounted) {
                dispose = [listen(input, "change", /*input_change_handler_1*/ctx[85]), listen(input, "change", /*change_handler_1*/ctx[86])];
                mounted = true;
              }
            },
            p: function p(new_ctx, dirty) {
              ctx = new_ctx;
              if (dirty[0] & /*signalDecoder*/134217728) {
                input.checked = input.__value === /*signalDecoder*/ctx[27];
              }
            },
            d: function d(detaching) {
              if (detaching) detach(label);
              /*$$binding_groups*/
              ctx[64][1].splice( /*$$binding_groups*/ctx[64][1].indexOf(input), 1);
              mounted = false;
              run_all(dispose);
            }
          };
        }
        function create_fragment(ctx) {
          var main;
          var div49;
          var div2;
          var frequencyinput;
          var t0;
          var canvas0;
          var canvas0_class_value;
          var t1;
          var passbandtuner;
          var t2;
          var frequencymarkers;
          var t3;
          var canvas1;
          var t4;
          var div0;
          var canvas2;
          var canvas2_class_value;
          var t5;
          var div1;
          var logger_1;
          var div1_class_value;
          var t6;
          var div48;
          var div4;
          var t7;
          var div23;
          var div5;
          var t9;
          var div22;
          var div6;
          var each_blocks_3 = [];
          var each0_lookup = new Map();
          var t10;
          var p;
          var t11;
          var t12;
          var t13;
          var t14;
          var div7;
          var each_blocks_2 = [];
          var each1_lookup = new Map();
          var t15;
          var div19;
          var div12;
          var label1;
          var input0;
          var t16;
          var div8;
          var t18;
          var div9;
          var t20;
          var div10;
          var t21;
          var t22;
          var t23;
          var div11;
          var input1;
          var t24;
          var div15;
          var label2;
          var input2;
          var t25;
          var div13;
          var t27;
          var tooltip;
          var t28;
          var span0;
          var t29;
          var t30;
          var t31;
          var div14;
          var input3;
          var t32;
          var div18;
          var span4;
          var span1;
          var t33;
          var span2;
          var t34;
          var span3;
          var t36;
          var span5;
          var t37_value = /*power*/ctx[19].toFixed(1) + "";
          var t37;
          var t38;
          var t39;
          var div17;
          var div16;
          var span6;
          var t40;
          var span7;
          var t41;
          var div21;
          var div20;
          var linethroughbutton0;
          var updating_checked;
          var t42;
          var linethroughbutton1;
          var updating_checked_1;
          var t43;
          var linethroughbutton2;
          var updating_checked_2;
          var t44;
          var div38;
          var div24;
          var t46;
          var div37;
          var div25;
          var checkbutton0;
          var updating_checked_3;
          var t47;
          var checkbutton1;
          var updating_checked_4;
          var t48;
          var div26;
          var button0;
          var t50;
          var button1;
          var t52;
          var button2;
          var t54;
          var button3;
          var t56;
          var div29;
          var div27;
          var t58;
          var span8;
          var t59;
          var t60;
          var div28;
          var input4;
          var div29_class_value;
          var t61;
          var div32;
          var div30;
          var t63;
          var span9;
          var t64;
          var t65;
          var div31;
          var input5;
          var div32_class_value;
          var t66;
          var div36;
          var div33;
          var t68;
          var div34;
          var canvas3;
          var t69;
          var div35;
          var select;
          var div36_class_value;
          var t70;
          var div43;
          var div39;
          var t72;
          var div42;
          var div41;
          var div40;
          var button4;
          var t74;
          var popover;
          var t75;
          var input6;
          var t76;
          var div47;
          var div44;
          var t78;
          var div46;
          var div45;
          var each_blocks = [];
          var each3_lookup = new Map();
          var current;
          var mounted;
          var dispose;
          var frequencyinput_props = {};
          frequencyinput = new FrequencyInput({
            props: frequencyinput_props
          });
          /*frequencyinput_binding*/
          ctx[56](frequencyinput);
          frequencyinput.$on("change", /*handleFrequencyChange*/ctx[39]);
          var passbandtuner_props = {};
          passbandtuner = new PassbandTuner({
            props: passbandtuner_props
          });
          /*passbandtuner_binding*/
          ctx[58](passbandtuner);
          passbandtuner.$on("change", /*handlePassbandChange*/ctx[38]);
          passbandtuner.$on("wheel", /*handleWaterfallWheel*/ctx[28]);
          var frequencymarkers_props = {};
          frequencymarkers = new FrequencyMarkers({
            props: frequencymarkers_props
          });
          /*frequencymarkers_binding*/
          ctx[59](frequencymarkers);
          frequencymarkers.$on("click", function () {
            if (is_function( /*passbandTunerComponent*/ctx[4].handlePassbandClick)) /*passbandTunerComponent*/ctx[4].handlePassbandClick.apply(this, arguments);
          });
          frequencymarkers.$on("wheel", /*handleWaterfallWheel*/ctx[28]);
          frequencymarkers.$on("markerclick", /*handleFrequencyMarkerClick*/ctx[49]);
          var logger_1_props = {
            capacity: 1000
          };
          logger_1 = new Logger({
            props: logger_1_props
          });
          /*logger_1_binding*/
          ctx[62](logger_1);
          var each_value_3 = /*demodulators*/ctx[13];
          var get_key = function get_key(ctx) {
            return (/*demodulator*/ctx[107]
            );
          };
          for (var i = 0; i < each_value_3.length; i += 1) {
            var child_ctx = get_each_context_3(ctx, each_value_3, i);
            var key = get_key(child_ctx);
            each0_lookup.set(key, each_blocks_3[i] = create_each_block_3(key, child_ctx));
          }
          var each_value_2 = /*bandwithoffsets*/ctx[21];
          var get_key_1 = function get_key_1(ctx) {
            return (/*bandwidthoffset*/ctx[104]
            );
          };
          for (var _i33 = 0; _i33 < each_value_2.length; _i33 += 1) {
            var _child_ctx = get_each_context_2(ctx, each_value_2, _i33);
            var _key11 = get_key_1(_child_ctx);
            each1_lookup.set(_key11, each_blocks_2[_i33] = create_each_block_2(_key11, _child_ctx));
          }
          tooltip = new Tooltip({
            props: {
              text: "Squelch"
            }
          });
          function linethroughbutton0_checked_binding(value) {
            /*linethroughbutton0_checked_binding*/ctx[72](value);
          }
          var linethroughbutton0_props = {
            name: "NR",
            $$slots: {
              default: [create_default_slot_2]
            },
            $$scope: {
              ctx: ctx
            }
          };
          if ( /*NREnabled*/ctx[22] !== void 0) {
            linethroughbutton0_props.checked = /*NREnabled*/ctx[22];
          }
          linethroughbutton0 = new LineThroughButton({
            props: linethroughbutton0_props
          });
          binding_callbacks.push(function () {
            return bind$4(linethroughbutton0, 'checked', linethroughbutton0_checked_binding, /*NREnabled*/ctx[22]);
          });
          linethroughbutton0.$on("change", /*handleNRChange*/ctx[46]);
          function linethroughbutton1_checked_binding(value) {
            /*linethroughbutton1_checked_binding*/ctx[73](value);
          }
          var linethroughbutton1_props = {
            name: "NB",
            $$slots: {
              default: [create_default_slot_1]
            },
            $$scope: {
              ctx: ctx
            }
          };
          if ( /*NBEnabled*/ctx[23] !== void 0) {
            linethroughbutton1_props.checked = /*NBEnabled*/ctx[23];
          }
          linethroughbutton1 = new LineThroughButton({
            props: linethroughbutton1_props
          });
          binding_callbacks.push(function () {
            return bind$4(linethroughbutton1, 'checked', linethroughbutton1_checked_binding, /*NBEnabled*/ctx[23]);
          });
          linethroughbutton1.$on("change", /*handleNBChange*/ctx[47]);
          function linethroughbutton2_checked_binding(value) {
            /*linethroughbutton2_checked_binding*/ctx[74](value);
          }
          var linethroughbutton2_props = {
            name: "AN",
            $$slots: {
              default: [create_default_slot]
            },
            $$scope: {
              ctx: ctx
            }
          };
          if ( /*ANEnabled*/ctx[24] !== void 0) {
            linethroughbutton2_props.checked = /*ANEnabled*/ctx[24];
          }
          linethroughbutton2 = new LineThroughButton({
            props: linethroughbutton2_props
          });
          binding_callbacks.push(function () {
            return bind$4(linethroughbutton2, 'checked', linethroughbutton2_checked_binding, /*ANEnabled*/ctx[24]);
          });
          linethroughbutton2.$on("change", /*handleANChange*/ctx[48]);
          function checkbutton0_checked_binding(value) {
            /*checkbutton0_checked_binding*/ctx[75](value);
          }
          var checkbutton0_props = {
            name: "Spectrum Analyzer"
          };
          if ( /*spectrumDisplay*/ctx[8] !== void 0) {
            checkbutton0_props.checked = /*spectrumDisplay*/ctx[8];
          }
          checkbutton0 = new CheckButton({
            props: checkbutton0_props
          });
          binding_callbacks.push(function () {
            return bind$4(checkbutton0, 'checked', checkbutton0_checked_binding, /*spectrumDisplay*/ctx[8]);
          });
          checkbutton0.$on("change", /*handleSpectrumChange*/ctx[32]);
          function checkbutton1_checked_binding(value) {
            /*checkbutton1_checked_binding*/ctx[76](value);
          }
          var checkbutton1_props = {
            name: "Waterfall"
          };
          if ( /*waterfallDisplay*/ctx[7] !== void 0) {
            checkbutton1_props.checked = /*waterfallDisplay*/ctx[7];
          }
          checkbutton1 = new CheckButton({
            props: checkbutton1_props
          });
          binding_callbacks.push(function () {
            return bind$4(checkbutton1, 'checked', checkbutton1_checked_binding, /*waterfallDisplay*/ctx[7]);
          });
          checkbutton1.$on("change", /*handleWaterfallChange*/ctx[33]);
          var each_value_1 = availableColormaps;
          var each_blocks_1 = [];
          for (var _i34 = 0; _i34 < each_value_1.length; _i34 += 1) {
            each_blocks_1[_i34] = create_each_block_1(get_each_context_1(ctx, each_value_1, _i34));
          }
          popover = new Popover({
            props: {
              text: "Copied!"
            }
          });
          var each_value = /*decoders*/ctx[51];
          var get_key_2 = function get_key_2(ctx) {
            return (/*decoder*/ctx[98]
            );
          };
          for (var _i35 = 0; _i35 < each_value.length; _i35 += 1) {
            var _child_ctx2 = get_each_context(ctx, each_value, _i35);
            var _key12 = get_key_2(_child_ctx2);
            each3_lookup.set(_key12, each_blocks[_i35] = create_each_block(_key12, _child_ctx2));
          }
          return {
            c: function c() {
              main = element("main");
              div49 = element("div");
              div2 = element("div");
              create_component(frequencyinput.$$.fragment);
              t0 = space();
              canvas0 = element("canvas");
              t1 = space();
              create_component(passbandtuner.$$.fragment);
              t2 = space();
              create_component(frequencymarkers.$$.fragment);
              t3 = space();
              canvas1 = element("canvas");
              t4 = space();
              div0 = element("div");
              canvas2 = element("canvas");
              t5 = space();
              div1 = element("div");
              create_component(logger_1.$$.fragment);
              t6 = space();
              div48 = element("div");
              div4 = element("div");
              div4.innerHTML = "<div class=\"m-2\"></div>";
              t7 = space();
              div23 = element("div");
              div5 = element("div");
              div5.innerHTML = "<label for=\"tab-multi-one\">Audio</label>";
              t9 = space();
              div22 = element("div");
              div6 = element("div");
              for (var _i36 = 0; _i36 < each_blocks_3.length; _i36 += 1) {
                each_blocks_3[_i36].c();
              }
              t10 = space();
              p = element("p");
              t11 = text("Bandwidth: ");
              t12 = text( /*bandwidth*/ctx[5]);
              t13 = text("kHz");
              t14 = space();
              div7 = element("div");
              for (var _i37 = 0; _i37 < each_blocks_2.length; _i37 += 1) {
                each_blocks_2[_i37].c();
              }
              t15 = space();
              div19 = element("div");
              div12 = element("div");
              label1 = element("label");
              input0 = element("input");
              t16 = space();
              div8 = element("div");
              div8.textContent = "🔊";
              t18 = space();
              div9 = element("div");
              div9.textContent = "🔇";
              t20 = space();
              div10 = element("div");
              t21 = text( /*volume*/ctx[16]);
              t22 = text("%");
              t23 = space();
              div11 = element("div");
              input1 = element("input");
              t24 = space();
              div15 = element("div");
              label2 = element("label");
              input2 = element("input");
              t25 = space();
              div13 = element("div");
              div13.textContent = " Sq ";
              t27 = space();
              create_component(tooltip.$$.fragment);
              t28 = space();
              span0 = element("span");
              t29 = text( /*squelch*/ctx[18]);
              t30 = text("db");
              t31 = space();
              div14 = element("div");
              input3 = element("input");
              t32 = space();
              div18 = element("div");
              span4 = element("span");
              span1 = element("span");
              t33 = space();
              span2 = element("span");
              t34 = space();
              span3 = element("span");
              span3.textContent = "Pwr";
              t36 = space();
              span5 = element("span");
              t37 = text(t37_value);
              t38 = text("db");
              t39 = space();
              div17 = element("div");
              div16 = element("div");
              span6 = element("span");
              t40 = space();
              span7 = element("span");
              t41 = space();
              div21 = element("div");
              div20 = element("div");
              create_component(linethroughbutton0.$$.fragment);
              t42 = space();
              create_component(linethroughbutton1.$$.fragment);
              t43 = space();
              create_component(linethroughbutton2.$$.fragment);
              t44 = space();
              div38 = element("div");
              div24 = element("div");
              div24.innerHTML = "<label for=\"tab-multi-one\">Waterfall</label>";
              t46 = space();
              div37 = element("div");
              div25 = element("div");
              create_component(checkbutton0.$$.fragment);
              t47 = space();
              create_component(checkbutton1.$$.fragment);
              t48 = space();
              div26 = element("div");
              button0 = element("button");
              button0.textContent = "🔎max";
              t50 = space();
              button1 = element("button");
              button1.textContent = "🔎+";
              t52 = space();
              button2 = element("button");
              button2.textContent = "🔎-";
              t54 = space();
              button3 = element("button");
              button3.textContent = "🔎min";
              t56 = space();
              div29 = element("div");
              div27 = element("div");
              div27.textContent = "Smoothing";
              t58 = space();
              span8 = element("span");
              t59 = text( /*alpha*/ctx[11]);
              t60 = space();
              div28 = element("div");
              input4 = element("input");
              t61 = space();
              div32 = element("div");
              div30 = element("div");
              div30.textContent = "Brightness";
              t63 = space();
              span9 = element("span");
              t64 = text( /*brightness*/ctx[12]);
              t65 = space();
              div31 = element("div");
              input5 = element("input");
              t66 = space();
              div36 = element("div");
              div33 = element("div");
              div33.textContent = "Colormap:";
              t68 = space();
              div34 = element("div");
              canvas3 = element("canvas");
              t69 = space();
              div35 = element("div");
              select = element("select");
              for (var _i38 = 0; _i38 < each_blocks_1.length; _i38 += 1) {
                each_blocks_1[_i38].c();
              }
              t70 = space();
              div43 = element("div");
              div39 = element("div");
              div39.innerHTML = "<label for=\"tab-multi-one\">Bookmarks</label>";
              t72 = space();
              div42 = element("div");
              div41 = element("div");
              div40 = element("div");
              button4 = element("button");
              button4.textContent = "📋 Link:";
              t74 = space();
              create_component(popover.$$.fragment);
              t75 = space();
              input6 = element("input");
              t76 = space();
              div47 = element("div");
              div44 = element("div");
              div44.innerHTML = "<label for=\"tab-multi-one\">Decoders</label>";
              t78 = space();
              div46 = element("div");
              div45 = element("div");
              for (var _i39 = 0; _i39 < each_blocks.length; _i39 += 1) {
                each_blocks[_i39].c();
              }
              attr(canvas0, "class", canvas0_class_value = "w-full bg-black peer " + ( /*spectrumDisplay*/ctx[8] ? 'max-h-full' : 'max-h-0'));
              attr(canvas0, "width", "1024");
              attr(canvas0, "height", "128");
              attr(canvas1, "class", "w-full bg-black peer");
              attr(canvas1, "width", "1024");
              attr(canvas1, "height", "20");
              attr(canvas2, "class", canvas2_class_value = "w-full bg-black " + ( /*waterfallDisplay*/ctx[7] ? 'block' : 'hidden'));
              attr(canvas2, "width", "1024");
              attr(canvas2, "height", "2000");
              attr(div0, "class", "w-full peer overflow-hidden");
              attr(div1, "class", div1_class_value = /*signalDecoder*/ctx[27] === 'none' ? 'hidden' : 'block');
              attr(div2, "class", "w-full sm:w-1/2 md:w-2/3 lg:w-3/4 sm:transition-all sm:ease-linear sm:duration-100 cursor-crosshair overflow-x-hidden");
              attr(div4, "class", "tab");
              attr(div5, "class", "bg-gray-500 text-left pl-2");
              attr(div6, "class", "grid grid-cols-4");
              attr(p, "class", "text-white text-sm");
              attr(div7, "class", "flex items-center justify-center pb-1 scale-90 sm:scale-75 md:scale-[0.70]");
              attr(input0, "type", "checkbox");
              attr(input0, "class", "hidden peer");
              attr(input0, "autocomplete", "off");
              attr(div8, "class", "basic-button peer-checked:hidden");
              attr(div9, "class", "basic-button hidden peer-checked:block");
              attr(label1, "class", "w-1/6 text-white");
              attr(div10, "class", "w-1/6 text-white text-xs text-center m-auto");
              attr(input1, "type", "range");
              input1.disabled = /*mute*/ctx[15];
              attr(input1, "min", "0");
              attr(input1, "max", "100");
              attr(input1, "step", "0.1");
              attr(input1, "class", "disabled: cursor-not-allowed w-full align-middle appearance-none h-1 bg-gray-400 rounded outline-none");
              attr(div11, "class", "px-0 w-2/3 align-middle");
              attr(div12, "class", "flex");
              attr(input2, "type", "checkbox");
              attr(input2, "class", "hidden peer");
              attr(input2, "autocomplete", "off");
              attr(div13, "class", "basic-button line-through thick-line-through peer-checked:no-underline");
              attr(label2, "class", "w-1/6 text-white");
              attr(span0, "class", "w-1/6 text-white text-xs text-center m-auto");
              attr(input3, "type", "range");
              attr(input3, "min", "-100");
              attr(input3, "max", "0");
              attr(input3, "step", "0.1");
              attr(input3, "class", "w-full align-middle appearance-none h-1 bg-gray-400 rounded outline-none slider-thumb");
              attr(div14, "class", "px-0 w-2/3 align-middle");
              attr(div15, "class", "flex");
              attr(span1, "class", "bg-green-800 w-full absolute left-0 top-0 z-10 transition-all");
              set_style(span1, "top", - /*power*/ctx[19] + "%");
              set_style(span1, "height", /*power*/ctx[19] + 100 + "%");
              attr(span2, "class", "bg-red-800 w-full absolute left-0 top-0 z-0 transition-all");
              set_style(span2, "top", - /*powerPeak*/ctx[20] + "%");
              set_style(span2, "height", /*powerPeak*/ctx[20] + 100 + "%");
              attr(span3, "class", "relative z-20");
              attr(span4, "class", "w-1/6 text-white text-xs text-center relative basic-button");
              attr(span5, "class", "w-1/6 text-white text-xs text-center m-auto");
              attr(span6, "class", "bg-green-500 h-1 absolute left-0 top-0 rounded-full z-10 transition-all");
              set_style(span6, "width", /*power*/ctx[19] + 100 + "%");
              attr(span7, "class", "bg-red-500 h-1 absolute left-0 top-0 rounded-full z-0 transition-all");
              set_style(span7, "width", /*powerPeak*/ctx[20] + 100 + "%");
              attr(div16, "class", "bg-gray-300 h-1 w-full m-auto rounded-full relative");
              attr(div17, "class", "px-0 w-2/3 align-middle flex");
              attr(div18, "class", "flex");
              attr(div20, "class", "grid grid-cols-4 my-1");
              attr(div22, "class", "m-2");
              attr(div23, "class", "tab");
              attr(div24, "class", "bg-gray-500 text-left pl-2");
              attr(div25, "class", "flex flex-wrap items-center content-center justify-center my-1");
              attr(button0, "class", "click-button w-1/4");
              attr(button1, "class", "click-button w-1/4");
              attr(button2, "class", "click-button w-1/4");
              attr(button3, "class", "click-button w-1/4");
              attr(div26, "class", "flex flex-wrap items-center justify-center w-full");
              attr(div26, "aria-label", "Bandwidth controls");
              attr(div27, "class", "w-1/6 text-white text-xs align-middle p-auto m-auto");
              attr(span8, "class", "w-1/6 text-white text-xs text-center m-auto");
              attr(input4, "type", "range");
              attr(input4, "min", "0");
              attr(input4, "max", "1");
              attr(input4, "step", "0.01");
              attr(input4, "class", "w-full align-middle appearance-none h-1 bg-gray-400 rounded outline-none slider-thumb");
              attr(div28, "class", "px-0 w-2/3 align-middle");
              attr(div29, "class", div29_class_value = /*spectrumDisplay*/ctx[8] ? 'flex' : 'hidden');
              attr(div30, "class", "w-1/6 text-white text-xs align-middle p-auto m-auto");
              attr(span9, "class", "w-1/6 text-white text-xs text-center m-auto");
              attr(input5, "type", "range");
              attr(input5, "min", "0");
              attr(input5, "max", "255");
              attr(input5, "step", "1");
              attr(input5, "class", "w-full align-middle appearance-none h-1 bg-gray-400 rounded outline-none slider-thumb");
              attr(div31, "class", "px-0 w-2/3 align-middle");
              attr(div32, "class", div32_class_value = /*waterfallDisplay*/ctx[7] ? 'flex' : 'hidden');
              attr(div33, "class", "w-1/6 text-white text-xs text-center m-auto");
              attr(canvas3, "class", "w-full h-4");
              attr(canvas3, "width", "256");
              attr(div34, "class", "w-1/3 flex items-center align-middle m-auto px-2");
              attr(select, "class", "h-full w-full py-px bg-transparent text-white text-xs border border-1 border-blue-500");
              if ( /*currentColormap*/ctx[9] === void 0) add_render_callback(function () {
                return (/*select_change_handler*/ctx[84].call(select)
                );
              });
              attr(div35, "class", "px-0 w-1/2 h-full flex align-middle bg-transparent z-50");
              attr(div36, "class", div36_class_value = "" + (( /*waterfallDisplay*/ctx[7] ? 'flex' : 'hidden') + " pt-1"));
              attr(div37, "class", "m-2");
              attr(div38, "class", "tab");
              attr(div39, "class", "bg-gray-500 text-left pl-2");
              attr(div40, "class", "border border-blue-500 text-blue-500 transition-all duration-100 text-center text-xs px-2 py-1 active:bg-blue-600 active:text-white");
              attr(input6, "type", "text");
              attr(input6, "class", "flex-grow bg-transparent text-white border border-l-0 border-blue-500 text-xs px-2");
              input6.value = /*link*/ctx[6];
              input6.readOnly = true;
              attr(div41, "class", "flex");
              attr(div42, "class", "m-2");
              attr(div43, "class", "tab");
              attr(div44, "class", "bg-gray-500 text-left pl-2");
              attr(div45, "class", "grid grid-cols-4");
              attr(div46, "class", "m-2");
              attr(div47, "class", "tab");
              attr(div48, "class", "w-full sm:w-1/2 md:w-1/3 lg:w-1/4 sm:transition-all sm:ease-linear sm:duration-100");
              attr(div49, "class", "flex flex-col-reverse sm:flex-row");
            },
            m: function m(target, anchor) {
              insert(target, main, anchor);
              append(main, div49);
              append(div49, div2);
              mount_component(frequencyinput, div2, null);
              append(div2, t0);
              append(div2, canvas0);
              /*canvas0_binding*/
              ctx[57](canvas0);
              append(div2, t1);
              mount_component(passbandtuner, div2, null);
              append(div2, t2);
              mount_component(frequencymarkers, div2, null);
              append(div2, t3);
              append(div2, canvas1);
              /*canvas1_binding*/
              ctx[60](canvas1);
              append(div2, t4);
              append(div2, div0);
              append(div0, canvas2);
              /*canvas2_binding*/
              ctx[61](canvas2);
              append(div2, t5);
              append(div2, div1);
              mount_component(logger_1, div1, null);
              append(div49, t6);
              append(div49, div48);
              append(div48, div4);
              append(div48, t7);
              append(div48, div23);
              append(div23, div5);
              append(div23, t9);
              append(div23, div22);
              append(div22, div6);
              for (var _i40 = 0; _i40 < each_blocks_3.length; _i40 += 1) {
                each_blocks_3[_i40].m(div6, null);
              }
              append(div22, t10);
              append(div22, p);
              append(p, t11);
              append(p, t12);
              append(p, t13);
              append(div22, t14);
              append(div22, div7);
              for (var _i41 = 0; _i41 < each_blocks_2.length; _i41 += 1) {
                each_blocks_2[_i41].m(div7, null);
              }
              append(div22, t15);
              append(div22, div19);
              append(div19, div12);
              append(div12, label1);
              append(label1, input0);
              input0.checked = /*mute*/ctx[15];
              append(label1, t16);
              append(label1, div8);
              append(label1, t18);
              append(label1, div9);
              append(div12, t20);
              append(div12, div10);
              append(div10, t21);
              append(div10, t22);
              append(div12, t23);
              append(div12, div11);
              append(div11, input1);
              set_input_value(input1, /*volume*/ctx[16]);
              append(div19, t24);
              append(div19, div15);
              append(div15, label2);
              append(label2, input2);
              input2.checked = /*squelchEnable*/ctx[17];
              append(label2, t25);
              append(label2, div13);
              append(label2, t27);
              mount_component(tooltip, label2, null);
              append(div15, t28);
              append(div15, span0);
              append(span0, t29);
              append(span0, t30);
              append(div15, t31);
              append(div15, div14);
              append(div14, input3);
              set_input_value(input3, /*squelch*/ctx[18]);
              append(div19, t32);
              append(div19, div18);
              append(div18, span4);
              append(span4, span1);
              append(span4, t33);
              append(span4, span2);
              append(span4, t34);
              append(span4, span3);
              append(div18, t36);
              append(div18, span5);
              append(span5, t37);
              append(span5, t38);
              append(div18, t39);
              append(div18, div17);
              append(div17, div16);
              append(div16, span6);
              append(div16, t40);
              append(div16, span7);
              append(div22, t41);
              append(div22, div21);
              append(div21, div20);
              mount_component(linethroughbutton0, div20, null);
              append(div20, t42);
              mount_component(linethroughbutton1, div20, null);
              append(div20, t43);
              mount_component(linethroughbutton2, div20, null);
              append(div48, t44);
              append(div48, div38);
              append(div38, div24);
              append(div38, t46);
              append(div38, div37);
              append(div37, div25);
              mount_component(checkbutton0, div25, null);
              append(div25, t47);
              mount_component(checkbutton1, div25, null);
              append(div37, t48);
              append(div37, div26);
              append(div26, button0);
              append(div26, t50);
              append(div26, button1);
              append(div26, t52);
              append(div26, button2);
              append(div26, t54);
              append(div26, button3);
              append(div37, t56);
              append(div37, div29);
              append(div29, div27);
              append(div29, t58);
              append(div29, span8);
              append(span8, t59);
              append(div29, t60);
              append(div29, div28);
              append(div28, input4);
              set_input_value(input4, /*alpha*/ctx[11]);
              append(div37, t61);
              append(div37, div32);
              append(div32, div30);
              append(div32, t63);
              append(div32, span9);
              append(span9, t64);
              append(div32, t65);
              append(div32, div31);
              append(div31, input5);
              set_input_value(input5, /*brightness*/ctx[12]);
              append(div37, t66);
              append(div37, div36);
              append(div36, div33);
              append(div36, t68);
              append(div36, div34);
              append(div34, canvas3);
              /*canvas3_binding*/
              ctx[83](canvas3);
              append(div36, t69);
              append(div36, div35);
              append(div35, select);
              for (var _i42 = 0; _i42 < each_blocks_1.length; _i42 += 1) {
                each_blocks_1[_i42].m(select, null);
              }
              select_option(select, /*currentColormap*/ctx[9]);
              append(div48, t70);
              append(div48, div43);
              append(div43, div39);
              append(div43, t72);
              append(div43, div42);
              append(div42, div41);
              append(div41, div40);
              append(div40, button4);
              append(div40, t74);
              mount_component(popover, div40, null);
              append(div41, t75);
              append(div41, input6);
              append(div48, t76);
              append(div48, div47);
              append(div47, div44);
              append(div47, t78);
              append(div47, div46);
              append(div46, div45);
              for (var _i43 = 0; _i43 < each_blocks.length; _i43 += 1) {
                each_blocks[_i43].m(div45, null);
              }
              current = true;
              if (!mounted) {
                dispose = [listen(window_1, "mousemove", /*handleWindowMouseMove*/ctx[30]), listen(window_1, "mouseup", /*handleWindowMouseUp*/ctx[31]), listen(canvas0, "wheel", /*handleWaterfallWheel*/ctx[28]), listen(canvas0, "click", function () {
                  if (is_function( /*passbandTunerComponent*/ctx[4].handlePassbandClick)) /*passbandTunerComponent*/ctx[4].handlePassbandClick.apply(this, arguments);
                }), listen(canvas1, "wheel", /*handleWaterfallWheel*/ctx[28]), listen(canvas1, "click", function () {
                  if (is_function( /*passbandTunerComponent*/ctx[4].handlePassbandClick)) /*passbandTunerComponent*/ctx[4].handlePassbandClick.apply(this, arguments);
                }), action_destroyer(pinch.call(null, canvas2)), listen(canvas2, "pinchstart", /*handleWaterfallPinchStart*/ctx[53]), listen(canvas2, "pinchmove", /*handleWaterfallPinchMove*/ctx[54]), action_destroyer(pan.call(null, canvas2)), listen(canvas2, "panmove", /*handleWaterfallPanMove*/ctx[55]), listen(canvas2, "wheel", /*handleWaterfallWheel*/ctx[28]), listen(canvas2, "mousedown", /*handleWaterfallMouseDown*/ctx[29]), listen(input0, "change", /*input0_change_handler*/ctx[68]), listen(input0, "change", /*handleMuteChange*/ctx[42]), listen(input1, "change", /*input1_change_input_handler*/ctx[69]), listen(input1, "input", /*input1_change_input_handler*/ctx[69]), listen(input1, "mousemove", /*handleVolumeChange*/ctx[43]), listen(input2, "change", /*input2_change_handler*/ctx[70]), listen(input2, "change", /*handleSquelchChange*/ctx[44]), listen(input3, "change", /*input3_change_input_handler*/ctx[71]), listen(input3, "input", /*input3_change_input_handler*/ctx[71]), listen(input3, "mousemove", /*handleSquelchMove*/ctx[45]), listen(button0, "click", /*click_handler_2*/ctx[77]), listen(button1, "click", /*click_handler_3*/ctx[78]), listen(button2, "click", /*click_handler_4*/ctx[79]), listen(button3, "click", /*click_handler_5*/ctx[80]), listen(input4, "change", /*input4_change_input_handler*/ctx[81]), listen(input4, "input", /*input4_change_input_handler*/ctx[81]), listen(input4, "mousemove", /*handleAlphaMove*/ctx[35]), listen(input5, "change", /*input5_change_input_handler*/ctx[82]), listen(input5, "input", /*input5_change_input_handler*/ctx[82]), listen(input5, "mousemove", /*handleBrightnessMove*/ctx[36]), listen(select, "change", /*select_change_handler*/ctx[84]), listen(select, "change", /*handleWaterfallColormapSelect*/ctx[34]), listen(div40, "click", /*handleLinkCopyClick*/ctx[50])];
                mounted = true;
              }
            },
            p: function p(new_ctx, dirty) {
              ctx = new_ctx;
              var frequencyinput_changes = {};
              frequencyinput.$set(frequencyinput_changes);
              if (!current || dirty[0] & /*spectrumDisplay*/256 && canvas0_class_value !== (canvas0_class_value = "w-full bg-black peer " + ( /*spectrumDisplay*/ctx[8] ? 'max-h-full' : 'max-h-0'))) {
                attr(canvas0, "class", canvas0_class_value);
              }
              var passbandtuner_changes = {};
              passbandtuner.$set(passbandtuner_changes);
              var frequencymarkers_changes = {};
              frequencymarkers.$set(frequencymarkers_changes);
              if (!current || dirty[0] & /*waterfallDisplay*/128 && canvas2_class_value !== (canvas2_class_value = "w-full bg-black " + ( /*waterfallDisplay*/ctx[7] ? 'block' : 'hidden'))) {
                attr(canvas2, "class", canvas2_class_value);
              }
              var logger_1_changes = {};
              logger_1.$set(logger_1_changes);
              if (!current || dirty[0] & /*signalDecoder*/134217728 && div1_class_value !== (div1_class_value = /*signalDecoder*/ctx[27] === 'none' ? 'hidden' : 'block')) {
                attr(div1, "class", div1_class_value);
              }
              if (dirty[0] & /*demodulators, demodulation*/24576 | dirty[1] & /*handleDemodulationChange*/64) {
                each_value_3 = /*demodulators*/ctx[13];
                each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key, 1, ctx, each_value_3, each0_lookup, div6, destroy_block, create_each_block_3, null, get_each_context_3);
              }
              if (!current || dirty[0] & /*bandwidth*/32) set_data(t12, /*bandwidth*/ctx[5]);
              if (dirty[0] & /*bandwithoffsets*/2097152 | dirty[1] & /*handleBandwidthOffsetClick*/1024) {
                each_value_2 = /*bandwithoffsets*/ctx[21];
                each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_1, 1, ctx, each_value_2, each1_lookup, div7, destroy_block, create_each_block_2, null, get_each_context_2);
              }
              if (dirty[0] & /*mute*/32768) {
                input0.checked = /*mute*/ctx[15];
              }
              if (!current || dirty[0] & /*volume*/65536) set_data(t21, /*volume*/ctx[16]);
              if (!current || dirty[0] & /*mute*/32768) {
                input1.disabled = /*mute*/ctx[15];
              }
              if (dirty[0] & /*volume*/65536) {
                set_input_value(input1, /*volume*/ctx[16]);
              }
              if (dirty[0] & /*squelchEnable*/131072) {
                input2.checked = /*squelchEnable*/ctx[17];
              }
              if (!current || dirty[0] & /*squelch*/262144) set_data(t29, /*squelch*/ctx[18]);
              if (dirty[0] & /*squelch*/262144) {
                set_input_value(input3, /*squelch*/ctx[18]);
              }
              if (!current || dirty[0] & /*power*/524288) {
                set_style(span1, "top", - /*power*/ctx[19] + "%");
              }
              if (!current || dirty[0] & /*power*/524288) {
                set_style(span1, "height", /*power*/ctx[19] + 100 + "%");
              }
              if (!current || dirty[0] & /*powerPeak*/1048576) {
                set_style(span2, "top", - /*powerPeak*/ctx[20] + "%");
              }
              if (!current || dirty[0] & /*powerPeak*/1048576) {
                set_style(span2, "height", /*powerPeak*/ctx[20] + 100 + "%");
              }
              if ((!current || dirty[0] & /*power*/524288) && t37_value !== (t37_value = /*power*/ctx[19].toFixed(1) + "")) set_data(t37, t37_value);
              if (!current || dirty[0] & /*power*/524288) {
                set_style(span6, "width", /*power*/ctx[19] + 100 + "%");
              }
              if (!current || dirty[0] & /*powerPeak*/1048576) {
                set_style(span7, "width", /*powerPeak*/ctx[20] + 100 + "%");
              }
              var linethroughbutton0_changes = {};
              if (dirty[3] & /*$$scope*/131072) {
                linethroughbutton0_changes.$$scope = {
                  dirty: dirty,
                  ctx: ctx
                };
              }
              if (!updating_checked && dirty[0] & /*NREnabled*/4194304) {
                updating_checked = true;
                linethroughbutton0_changes.checked = /*NREnabled*/ctx[22];
                add_flush_callback(function () {
                  return updating_checked = false;
                });
              }
              linethroughbutton0.$set(linethroughbutton0_changes);
              var linethroughbutton1_changes = {};
              if (dirty[3] & /*$$scope*/131072) {
                linethroughbutton1_changes.$$scope = {
                  dirty: dirty,
                  ctx: ctx
                };
              }
              if (!updating_checked_1 && dirty[0] & /*NBEnabled*/8388608) {
                updating_checked_1 = true;
                linethroughbutton1_changes.checked = /*NBEnabled*/ctx[23];
                add_flush_callback(function () {
                  return updating_checked_1 = false;
                });
              }
              linethroughbutton1.$set(linethroughbutton1_changes);
              var linethroughbutton2_changes = {};
              if (dirty[3] & /*$$scope*/131072) {
                linethroughbutton2_changes.$$scope = {
                  dirty: dirty,
                  ctx: ctx
                };
              }
              if (!updating_checked_2 && dirty[0] & /*ANEnabled*/16777216) {
                updating_checked_2 = true;
                linethroughbutton2_changes.checked = /*ANEnabled*/ctx[24];
                add_flush_callback(function () {
                  return updating_checked_2 = false;
                });
              }
              linethroughbutton2.$set(linethroughbutton2_changes);
              var checkbutton0_changes = {};
              if (!updating_checked_3 && dirty[0] & /*spectrumDisplay*/256) {
                updating_checked_3 = true;
                checkbutton0_changes.checked = /*spectrumDisplay*/ctx[8];
                add_flush_callback(function () {
                  return updating_checked_3 = false;
                });
              }
              checkbutton0.$set(checkbutton0_changes);
              var checkbutton1_changes = {};
              if (!updating_checked_4 && dirty[0] & /*waterfallDisplay*/128) {
                updating_checked_4 = true;
                checkbutton1_changes.checked = /*waterfallDisplay*/ctx[7];
                add_flush_callback(function () {
                  return updating_checked_4 = false;
                });
              }
              checkbutton1.$set(checkbutton1_changes);
              if (!current || dirty[0] & /*alpha*/2048) set_data(t59, /*alpha*/ctx[11]);
              if (dirty[0] & /*alpha*/2048) {
                set_input_value(input4, /*alpha*/ctx[11]);
              }
              if (!current || dirty[0] & /*spectrumDisplay*/256 && div29_class_value !== (div29_class_value = /*spectrumDisplay*/ctx[8] ? 'flex' : 'hidden')) {
                attr(div29, "class", div29_class_value);
              }
              if (!current || dirty[0] & /*brightness*/4096) set_data(t64, /*brightness*/ctx[12]);
              if (dirty[0] & /*brightness*/4096) {
                set_input_value(input5, /*brightness*/ctx[12]);
              }
              if (!current || dirty[0] & /*waterfallDisplay*/128 && div32_class_value !== (div32_class_value = /*waterfallDisplay*/ctx[7] ? 'flex' : 'hidden')) {
                attr(div32, "class", div32_class_value);
              }
              if (dirty & /*availableColormaps*/0) {
                each_value_1 = availableColormaps;
                var _i44;
                for (_i44 = 0; _i44 < each_value_1.length; _i44 += 1) {
                  var _child_ctx3 = get_each_context_1(ctx, each_value_1, _i44);
                  if (each_blocks_1[_i44]) {
                    each_blocks_1[_i44].p(_child_ctx3, dirty);
                  } else {
                    each_blocks_1[_i44] = create_each_block_1(_child_ctx3);
                    each_blocks_1[_i44].c();
                    each_blocks_1[_i44].m(select, null);
                  }
                }
                for (; _i44 < each_blocks_1.length; _i44 += 1) {
                  each_blocks_1[_i44].d(1);
                }
                each_blocks_1.length = each_value_1.length;
              }
              if (dirty[0] & /*currentColormap*/512) {
                select_option(select, /*currentColormap*/ctx[9]);
              }
              if (!current || dirty[0] & /*waterfallDisplay*/128 && div36_class_value !== (div36_class_value = "" + (( /*waterfallDisplay*/ctx[7] ? 'flex' : 'hidden') + " pt-1"))) {
                attr(div36, "class", div36_class_value);
              }
              if (!current || dirty[0] & /*link*/64 && input6.value !== /*link*/ctx[6]) {
                input6.value = /*link*/ctx[6];
              }
              if (dirty[0] & /*signalDecoder*/134217728 | dirty[1] & /*decoders, handleDecoderChange*/3145728) {
                each_value = /*decoders*/ctx[51];
                each_blocks = update_keyed_each(each_blocks, dirty, get_key_2, 1, ctx, each_value, each3_lookup, div45, destroy_block, create_each_block, null, get_each_context);
              }
            },
            i: function i(local) {
              if (current) return;
              transition_in(frequencyinput.$$.fragment, local);
              transition_in(passbandtuner.$$.fragment, local);
              transition_in(frequencymarkers.$$.fragment, local);
              transition_in(logger_1.$$.fragment, local);
              transition_in(tooltip.$$.fragment, local);
              transition_in(linethroughbutton0.$$.fragment, local);
              transition_in(linethroughbutton1.$$.fragment, local);
              transition_in(linethroughbutton2.$$.fragment, local);
              transition_in(checkbutton0.$$.fragment, local);
              transition_in(checkbutton1.$$.fragment, local);
              transition_in(popover.$$.fragment, local);
              current = true;
            },
            o: function o(local) {
              transition_out(frequencyinput.$$.fragment, local);
              transition_out(passbandtuner.$$.fragment, local);
              transition_out(frequencymarkers.$$.fragment, local);
              transition_out(logger_1.$$.fragment, local);
              transition_out(tooltip.$$.fragment, local);
              transition_out(linethroughbutton0.$$.fragment, local);
              transition_out(linethroughbutton1.$$.fragment, local);
              transition_out(linethroughbutton2.$$.fragment, local);
              transition_out(checkbutton0.$$.fragment, local);
              transition_out(checkbutton1.$$.fragment, local);
              transition_out(popover.$$.fragment, local);
              current = false;
            },
            d: function d(detaching) {
              if (detaching) detach(main);
              /*frequencyinput_binding*/
              ctx[56](null);
              destroy_component(frequencyinput);
              /*canvas0_binding*/
              ctx[57](null);
              /*passbandtuner_binding*/
              ctx[58](null);
              destroy_component(passbandtuner);
              /*frequencymarkers_binding*/
              ctx[59](null);
              destroy_component(frequencymarkers);
              /*canvas1_binding*/
              ctx[60](null);
              /*canvas2_binding*/
              ctx[61](null);
              /*logger_1_binding*/
              ctx[62](null);
              destroy_component(logger_1);
              for (var _i45 = 0; _i45 < each_blocks_3.length; _i45 += 1) {
                each_blocks_3[_i45].d();
              }
              for (var _i46 = 0; _i46 < each_blocks_2.length; _i46 += 1) {
                each_blocks_2[_i46].d();
              }
              destroy_component(tooltip);
              destroy_component(linethroughbutton0);
              destroy_component(linethroughbutton1);
              destroy_component(linethroughbutton2);
              destroy_component(checkbutton0);
              destroy_component(checkbutton1);
              /*canvas3_binding*/
              ctx[83](null);
              destroy_each(each_blocks_1, detaching);
              destroy_component(popover);
              for (var _i47 = 0; _i47 < each_blocks.length; _i47 += 1) {
                each_blocks[_i47].d();
              }
              mounted = false;
              run_all(dispose);
            }
          };
        }
        function roundAudioOffsets(offsets) {
          var _offsets2 = _slicedToArray(offsets, 3),
            l = _offsets2[0],
            m = _offsets2[1],
            r = _offsets2[2];
          return [Math.floor(l), m, Math.floor(r)];
        }
        function instance($$self, $$props, $$invalidate) {
          var waterfallCanvas;
          var spectrumCanvas;
          var graduationCanvas;
          var frequencyInputComponent;
          var passbandTunerComponent;
          var bandwidth;
          var link;

          // Updates the passband display
          function updatePassband(passband) {
            passband = passband || audio.getAudioRange();
            var frequencies = passband.map(FFTOffsetToFrequency);

            // Bandwidth display also needs updating
            $$invalidate(5, bandwidth = ((frequencies[2] - frequencies[0]) / 1000).toFixed(2));

            // Passband Display
            var offsets = frequencies.map(frequencyToWaterfallOffset);
            passbandTunerComponent.changePassband(offsets);
          }

          // Wheel zooming, update passband and markers
          function handleWaterfallWheel(e) {
            waterfall.canvasWheel(e);
            passbandTunerComponent.updatePassbandLimits();
            updatePassband();
            frequencyMarkerComponent.updateFrequencyMarkerPositions();
          }

          // Handling dragging the waterfall left or right
          var waterfallDragging = false;
          var waterfallDragTotal = 0;
          function handleWaterfallMouseDown(e) {
            waterfallDragTotal = 0;
            waterfallDragging = true;
          }
          function handleWindowMouseMove(e) {
            if (waterfallDragging) {
              waterfallDragTotal += Math.abs(e.movementX) + Math.abs(e.movementY);
              waterfall.mouseMove(e);
              updatePassband();
              frequencyMarkerComponent.updateFrequencyMarkerPositions();
            }
          }
          function handleWindowMouseUp(e) {
            if (waterfallDragging) {
              // If mouseup without moving, handle as click
              if (waterfallDragTotal < 2) {
                passbandTunerComponent.handlePassbandClick(e);
              }
              waterfallDragging = false;
            }
          }

          // Sidebar controls for waterfall and spectrum analyzer
          var waterfallDisplay = true;
          var spectrumDisplay = false;
          function handleSpectrumChange() {
            waterfall.setSpectrum(spectrumDisplay);
          }
          function handleWaterfallChange() {
            waterfall.setWaterfall(waterfallDisplay);
          }

          // Waterfall drawing
          var currentColormap = 'gqrx';
          var colormapPreview;
          var alpha = 0.5;
          var brightness = 80;
          function handleWaterfallColormapSelect(event) {
            waterfall.setColormap(currentColormap);
            drawColormapPreview(currentColormap, colormapPreview);
          }

          // Waterfall slider controls
          function handleAlphaMove() {
            waterfall.setAlpha(1 - alpha);
          }
          function handleBrightnessMove() {
            waterfall.setOffset(brightness);
          }

          // Audio demodulation selection
          var demodulators = ['USB', 'LSB', 'CW-U', 'CW-L', 'AM', 'FM'];
          var demodulationDefaults = {
            USB: {
              type: 'USB',
              offsets: [0, 3000]
            },
            LSB: {
              type: 'LSB',
              offsets: [3000, 0]
            },
            'CW-U': {
              type: 'USB',
              offsets: [-500, 1000]
            },
            'CW-L': {
              type: 'LSB',
              offsets: [1000, -500]
            },
            AM: {
              type: 'AM',
              offsets: [5000, 5000]
            },
            FM: {
              type: 'FM',
              offsets: [5000, 5000]
            },
            WBFM: {
              type: 'FM',
              offsets: [95000, 95000]
            }
          };
          var demodulation = 'USB';

          // Demodulation controls
          function handleDemodulationChange(e, changed) {
            var demodulationDefault = demodulationDefaults[demodulation];
            if (changed) {
              if (demodulation === 'WBFM') {
                audio.setFmDeemph(50e-6);
              } else {
                audio.setFmDeemph(0);
              }
              audio.setAudioDemodulation(demodulationDefault.type);
            }
            var _audio$getAudioRange$ = audio.getAudioRange().map(FFTOffsetToFrequency),
              _audio$getAudioRange$2 = _slicedToArray(_audio$getAudioRange$, 3),
              l = _audio$getAudioRange$2[0],
              m = _audio$getAudioRange$2[1],
              r = _audio$getAudioRange$2[2];
            l = m - demodulationDefault.offsets[0];
            r = m + demodulationDefault.offsets[1];
            var audioParameters = roundAudioOffsets([l, m, r].map(frequencyToFFTOffset));
            audio.setAudioRange.apply(audio, _toConsumableArray(audioParameters));
            updatePassband();
            updateLink();
          }

          // When user drags or changes the passband
          function handlePassbandChange(passband) {
            var _passband$detail$map = passband.detail.map(waterfallOffsetToFrequency),
              _passband$detail$map2 = _slicedToArray(_passband$detail$map, 3),
              l = _passband$detail$map2[0],
              m = _passband$detail$map2[1],
              r = _passband$detail$map2[2];
            $$invalidate(5, bandwidth = ((r - l) / 1000).toFixed(2));
            frequencyInputComponent.setFrequency(m);
            var audioParameters = roundAudioOffsets([l, m, r].map(frequencyToFFTOffset));
            audio.setAudioRange.apply(audio, _toConsumableArray(audioParameters));
            updateLink();
          }

          // Entering new frequency into the textbox
          function handleFrequencyChange(event) {
            var frequency = event.detail;
            var audioRange = audio.getAudioRange();
            var _audioRange$map = audioRange.map(FFTOffsetToFrequency),
              _audioRange$map2 = _slicedToArray(_audioRange$map, 3),
              l = _audioRange$map2[0],
              m = _audioRange$map2[1],
              r = _audioRange$map2[2];

            // Preserve current bandwidth settings
            var audioParameters = [frequency - (m - l), frequency, frequency + (r - m)].map(frequencyToFFTOffset);
            var newm = audioParameters[1];

            // If the ranges are not within limit, shift it back
            var _waterfall$getWaterfa7 = waterfall.getWaterfallRange(),
              _waterfall$getWaterfa8 = _slicedToArray(_waterfall$getWaterfa7, 2),
              waterfallL = _waterfall$getWaterfa8[0],
              waterfallR = _waterfall$getWaterfa8[1];
            if (newm < waterfallL || newm >= waterfallR) {
              var limits = Math.floor((waterfallR - waterfallL) / 2);
              var _offset2;
              if (audioRange[1] >= waterfallL && audioRange[1] < waterfallR) {
                _offset2 = audioRange[1] - waterfallL;
              } else {
                _offset2 = limits;
              }
              var newMid = Math.min(waterfall.waterfallMaxSize - limits, Math.max(limits, newm - _offset2 + limits));
              waterfallL = Math.floor(newMid - limits);
              waterfallR = Math.floor(newMid + limits);
              waterfall.setWaterfallRange(waterfallL, waterfallR);
            }
            audioParameters = roundAudioOffsets(audioParameters);
            audio.setAudioRange.apply(audio, _toConsumableArray(audioParameters));
            updatePassband();
            updateLink();
          }

          // Waterfall magnification controls in the sidebar
          function handleWaterfallMagnify(e, type) {
            var _audio$getAudioRange = audio.getAudioRange(),
              _audio$getAudioRange2 = _slicedToArray(_audio$getAudioRange, 3),
              l = _audio$getAudioRange2[0],
              m = _audio$getAudioRange2[1],
              r = _audio$getAudioRange2[2];
            var _waterfall$getWaterfa9 = waterfall.getWaterfallRange(),
              _waterfall$getWaterfa10 = _slicedToArray(_waterfall$getWaterfa9, 2),
              waterfallL = _waterfall$getWaterfa10[0],
              waterfallR = _waterfall$getWaterfa10[1];
            var offset = (m - waterfallL) / (waterfallR - waterfallL) * waterfall.canvasWidth;
            switch (type) {
              case 'max':
                m = Math.min(waterfall.waterfallMaxSize - 512, Math.max(512, m));
                l = m - 512;
                r = m + 512;
                break;
              case '+':
                e.coords = {
                  x: offset
                };
                e.scale = -1;
                waterfall.canvasWheel(e);
                updatePassband();
                return;
              case '-':
                e.coords = {
                  x: offset
                };
                e.scale = 1;
                waterfall.canvasWheel(e);
                updatePassband();
                return;
              case 'min':
                l = 0;
                r = waterfall.waterfallMaxSize;
                break;
            }
            waterfall.setWaterfallRange(l, r);
            updatePassband();
          }
          var mute;
          var volume = 75;
          var squelchEnable;
          var squelch = -50;
          var power = 0;
          var powerPeak = 0;
          var accumulator = efficientRollingStats.RollingMax(10);

          // Bandwidth offset controls
          var bandwithoffsets = ['-10000', '-100', '-10', '+10', '+100', '+10000'];
          function handleBandwidthOffsetClick(e, bandwidthoffset) {
            bandwidthoffset = parseFloat(bandwidthoffset);
            var demodulationDefault = demodulationDefaults[demodulation].type;
            var _audio$getAudioRange$3 = audio.getAudioRange().map(FFTOffsetToFrequency),
              _audio$getAudioRange$4 = _slicedToArray(_audio$getAudioRange$3, 3),
              l = _audio$getAudioRange$4[0],
              m = _audio$getAudioRange$4[1],
              r = _audio$getAudioRange$4[2];
            if (demodulationDefault === 'USB') {
              r = Math.max(m, Math.min(m + getMaximumBandwidth(), r + bandwidthoffset));
            } else if (demodulationDefault === 'LSB') {
              l = Math.max(m - getMaximumBandwidth(), Math.min(m, l - bandwidthoffset));
            } else {
              r = Math.max(0, Math.min(m + getMaximumBandwidth() / 2, r + bandwidthoffset / 2));
              l = Math.max(m - getMaximumBandwidth() / 2, Math.min(m, l - bandwidthoffset / 2));
            }
            var audioParameters = [l, m, r].map(frequencyToFFTOffset);
            audioParameters = roundAudioOffsets(audioParameters);
            audio.setAudioRange.apply(audio, _toConsumableArray(audioParameters));
            updatePassband();
          }

          // Toggle buttons and slides for audio
          function handleMuteChange() {
            audio.setMute(mute);
          }
          function handleVolumeChange() {
            audio.setGain(Math.pow(10, (volume - 50) / 20));
          }
          function handleSquelchChange() {
            audio.setSquelch(squelchEnable);
          }
          function handleSquelchMove() {
            audio.setSquelchThreshold(squelch);
          }
          var NREnabled = false;
          var NBEnabled = false;
          var ANEnabled = false;
          function handleNRChange() {
            audio.audioProcessor.setNR(NREnabled);
          }
          function handleNBChange() {
            audio.audioProcessor.setNB(NBEnabled);
          }
          function handleANChange() {
            audio.audioProcessor.setAN(ANEnabled);
          }

          // Regular updating UI elements:
          // Other user tuning displays
          //
          var updateInterval;
          var lastUpdated = 0;
          function updateTick() {
            $$invalidate(19, power = audio.getPowerDb());
            $$invalidate(20, powerPeak = accumulator(power));
            if (events.getLastModified() > lastUpdated) {
              var myRange = audio.getAudioRange();
              var clients = events.getSignalClients();

              // Don't show our own tuning
              var myId = Object.keys(clients).find(function (k) {
                return clients[k][1] - myRange[1] < 1e-6;
              });
              delete clients[myId];
              waterfall.setClients(clients);
              requestAnimationFrame(function () {
                waterfall.updateGraduation();
                waterfall.drawClients();
              });
              lastUpdated = events.getLastModified();
            }
          }

          // Tune to the frequency when clicked
          var frequencyMarkerComponent;
          function handleFrequencyMarkerClick(event) {
            handleFrequencyChange({
              detail: event.detail.frequency
            });
            $$invalidate(14, demodulation = event.detail.modulation);
            handleDemodulationChange();
          }

          // Permalink handling
          function updateLink() {
            var linkObj = {
              frequency: frequencyInputComponent.getFrequency().toFixed(0),
              modulation: demodulation
            };
            var linkQuery = constructLink(linkObj);
            $$invalidate(6, link = "".concat(location.origin).concat(location.pathname, "?").concat(linkQuery));
            storeInLocalStorage(linkObj);
          }
          function handleLinkCopyClick() {
            copyToClipboard(link);
          }

          // Decoder settings
          var logger;
          var signalDecoder = 'none';
          var decoders = ['none', 'rds', 'ft8'];
          function handleDecoderChange(_x23, _x24) {
            return _handleDecoderChange.apply(this, arguments);
          }
          function _handleDecoderChange() {
            _handleDecoderChange = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(e, changed) {
              var decoder;
              return _regeneratorRuntime().wrap(function _callee15$(_context15) {
                while (1) {
                  switch (_context15.prev = _context15.next) {
                    case 0:
                      if (audio.getSignalDecoder()) {
                        audio.getSignalDecoder().stop();
                        audio.setSignalDecoder(null);
                      }
                      if (!(signalDecoder !== 'none')) {
                        _context15.next = 6;
                        break;
                      }
                      decoder = new Decoder(signalDecoder, audio.trueAudioSps, function (text) {
                        if (logger) {
                          logger.addLine(text);
                        }
                      }); // Wait for the decode to initialize before running
                      _context15.next = 5;
                      return decoder.promise();
                    case 5:
                      audio.setSignalDecoder(decoder);
                    case 6:
                    case "end":
                      return _context15.stop();
                  }
                }
              }, _callee15);
            }));
            return _handleDecoderChange.apply(this, arguments);
          }
          var backendPromise = init();
          onMount( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
            var updateParameters, linkParameters;
            return _regeneratorRuntime().wrap(function _callee14$(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    // Disable all the input to prevent clicking
                    [].concat(_toConsumableArray(document.getElementsByTagName('button')), _toConsumableArray(document.getElementsByTagName('input'))).forEach(function (element) {
                      element.disabled = true;
                    });
                    waterfall.initCanvas({
                      canvasElem: waterfallCanvas,
                      spectrumCanvasElem: spectrumCanvas,
                      graduationCanvasElem: graduationCanvas
                    });
                    _context14.next = 4;
                    return backendPromise;
                  case 4:
                    // Enable after connection established
                    [].concat(_toConsumableArray(document.getElementsByTagName('button')), _toConsumableArray(document.getElementsByTagName('input'))).forEach(function (element) {
                      element.disabled = false;
                    });

                    // Enable WBFM option if bandwidth is wide enough
                    if (audio.trueAudioSps > 170000) {
                      demodulators.push('WBFM');
                      $$invalidate(13, demodulators);
                      bandwithoffsets.unshift('-100000');
                      bandwithoffsets.push('+100000');
                      $$invalidate(21, bandwithoffsets);
                    }
                    frequencyInputComponent.setFrequency(FFTOffsetToFrequency(audio.getAudioRange()[1]));
                    $$invalidate(14, demodulation = audio.settings.defaults.modulation);
                    updateParameters = function updateParameters(linkParameters) {
                      frequencyInputComponent.setFrequency(linkParameters.frequency);
                      if (frequencyInputComponent.getFrequency() === linkParameters.frequency) {
                        handleFrequencyChange({
                          detail: linkParameters.frequency
                        });
                      }
                      if (demodulators.indexOf(linkParameters.modulation) !== -1) {
                        $$invalidate(14, demodulation = linkParameters.modulation);
                        handleDemodulationChange({}, true);
                      }
                      frequencyMarkerComponent.updateFrequencyMarkerPositions();
                    };
                    /* const storageParameters = loadFromLocalStorage()
                    updateParameters(storageParameters) */
                    linkParameters = parseLink(location.search.slice(1));
                    updateParameters(linkParameters);

                    // Refresh all the controls to the initial value
                    updatePassband();
                    passbandTunerComponent.updatePassbandLimits();
                    handleWaterfallColormapSelect();
                    handleDemodulationChange({}, true);
                    handleSpectrumChange();
                    updateLink();
                    updateInterval = setInterval(updateTick, 200);

                    // For debugging
                    window.spectrumAudio = audio;
                    window.spectrumWaterfall = waterfall;
                  case 20:
                  case "end":
                    return _context14.stop();
                }
              }
            }, _callee14);
          })));
          onDestroy(function () {
            // Stop everything
            clearInterval(updateInterval);
            audio.stop();
            waterfall.stop();
          });

          // Mobile gestures
          // Pinch = Mousewheel = Zoom
          var pinchX = 0;
          function handleWaterfallPinchStart(e) {
            pinchX = 0;
          }
          function handleWaterfallPinchMove(e) {
            var diff = e.detail.scale - pinchX;
            pinchX = e.detail.scale;
            var scale = 1 - Math.abs(e.detail.srcEvent.movementX) / waterfallCanvas.getBoundingClientRect().width;
            var evt = e.detail.srcEvent;
            evt.coords = {
              x: e.detail.center.x
            };
            evt.deltaY = -Math.sign(diff);
            evt.scaleAmount = scale;
            waterfall.canvasWheel(evt);
            updatePassband();
          }

          // Pan = Mousewheel = waterfall dragging
          function handleWaterfallPanMove(e) {
            if (e.detail.srcEvent.pointerType === 'touch') {
              waterfall.mouseMove(e.detail.srcEvent);
              updatePassband();
            }
          }
          var $$binding_groups = [[], []];
          function frequencyinput_binding($$value) {
            binding_callbacks[$$value ? 'unshift' : 'push'](function () {
              frequencyInputComponent = $$value;
              $$invalidate(3, frequencyInputComponent);
            });
          }
          function canvas0_binding($$value) {
            binding_callbacks[$$value ? 'unshift' : 'push'](function () {
              spectrumCanvas = $$value;
              $$invalidate(1, spectrumCanvas);
            });
          }
          function passbandtuner_binding($$value) {
            binding_callbacks[$$value ? 'unshift' : 'push'](function () {
              passbandTunerComponent = $$value;
              $$invalidate(4, passbandTunerComponent);
            });
          }
          function frequencymarkers_binding($$value) {
            binding_callbacks[$$value ? 'unshift' : 'push'](function () {
              frequencyMarkerComponent = $$value;
              $$invalidate(25, frequencyMarkerComponent);
            });
          }
          function canvas1_binding($$value) {
            binding_callbacks[$$value ? 'unshift' : 'push'](function () {
              graduationCanvas = $$value;
              $$invalidate(2, graduationCanvas);
            });
          }
          function canvas2_binding($$value) {
            binding_callbacks[$$value ? 'unshift' : 'push'](function () {
              waterfallCanvas = $$value;
              $$invalidate(0, waterfallCanvas);
            });
          }
          function logger_1_binding($$value) {
            binding_callbacks[$$value ? 'unshift' : 'push'](function () {
              logger = $$value;
              $$invalidate(26, logger);
            });
          }
          function input_change_handler() {
            demodulation = this.__value;
            $$invalidate(14, demodulation);
          }
          var click_handler = function click_handler(e) {
            return handleDemodulationChange(e, false);
          };
          var change_handler = function change_handler(e) {
            return handleDemodulationChange(e, true);
          };
          var click_handler_1 = function click_handler_1(bandwidthoffset, e) {
            return handleBandwidthOffsetClick(e, bandwidthoffset);
          };
          function input0_change_handler() {
            mute = this.checked;
            $$invalidate(15, mute);
          }
          function input1_change_input_handler() {
            volume = to_number(this.value);
            $$invalidate(16, volume);
          }
          function input2_change_handler() {
            squelchEnable = this.checked;
            $$invalidate(17, squelchEnable);
          }
          function input3_change_input_handler() {
            squelch = to_number(this.value);
            $$invalidate(18, squelch);
          }
          function linethroughbutton0_checked_binding(value) {
            NREnabled = value;
            $$invalidate(22, NREnabled);
          }
          function linethroughbutton1_checked_binding(value) {
            NBEnabled = value;
            $$invalidate(23, NBEnabled);
          }
          function linethroughbutton2_checked_binding(value) {
            ANEnabled = value;
            $$invalidate(24, ANEnabled);
          }
          function checkbutton0_checked_binding(value) {
            spectrumDisplay = value;
            $$invalidate(8, spectrumDisplay);
          }
          function checkbutton1_checked_binding(value) {
            waterfallDisplay = value;
            $$invalidate(7, waterfallDisplay);
          }
          var click_handler_2 = function click_handler_2(e) {
            return handleWaterfallMagnify(e, 'max');
          };
          var click_handler_3 = function click_handler_3(e) {
            return handleWaterfallMagnify(e, '+');
          };
          var click_handler_4 = function click_handler_4(e) {
            return handleWaterfallMagnify(e, '-');
          };
          var click_handler_5 = function click_handler_5(e) {
            return handleWaterfallMagnify(e, 'min');
          };
          function input4_change_input_handler() {
            alpha = to_number(this.value);
            $$invalidate(11, alpha);
          }
          function input5_change_input_handler() {
            brightness = to_number(this.value);
            $$invalidate(12, brightness);
          }
          function canvas3_binding($$value) {
            binding_callbacks[$$value ? 'unshift' : 'push'](function () {
              colormapPreview = $$value;
              $$invalidate(10, colormapPreview);
            });
          }
          function select_change_handler() {
            currentColormap = select_value(this);
            $$invalidate(9, currentColormap);
          }
          function input_change_handler_1() {
            signalDecoder = this.__value;
            $$invalidate(27, signalDecoder);
          }
          var change_handler_1 = function change_handler_1(e) {
            return handleDecoderChange();
          };
          return [waterfallCanvas, spectrumCanvas, graduationCanvas, frequencyInputComponent, passbandTunerComponent, bandwidth, link, waterfallDisplay, spectrumDisplay, currentColormap, colormapPreview, alpha, brightness, demodulators, demodulation, mute, volume, squelchEnable, squelch, power, powerPeak, bandwithoffsets, NREnabled, NBEnabled, ANEnabled, frequencyMarkerComponent, logger, signalDecoder, handleWaterfallWheel, handleWaterfallMouseDown, handleWindowMouseMove, handleWindowMouseUp, handleSpectrumChange, handleWaterfallChange, handleWaterfallColormapSelect, handleAlphaMove, handleBrightnessMove, handleDemodulationChange, handlePassbandChange, handleFrequencyChange, handleWaterfallMagnify, handleBandwidthOffsetClick, handleMuteChange, handleVolumeChange, handleSquelchChange, handleSquelchMove, handleNRChange, handleNBChange, handleANChange, handleFrequencyMarkerClick, handleLinkCopyClick, decoders, handleDecoderChange, handleWaterfallPinchStart, handleWaterfallPinchMove, handleWaterfallPanMove, frequencyinput_binding, canvas0_binding, passbandtuner_binding, frequencymarkers_binding, canvas1_binding, canvas2_binding, logger_1_binding, input_change_handler, $$binding_groups, click_handler, change_handler, click_handler_1, input0_change_handler, input1_change_input_handler, input2_change_handler, input3_change_input_handler, linethroughbutton0_checked_binding, linethroughbutton1_checked_binding, linethroughbutton2_checked_binding, checkbutton0_checked_binding, checkbutton1_checked_binding, click_handler_2, click_handler_3, click_handler_4, click_handler_5, input4_change_input_handler, input5_change_input_handler, canvas3_binding, select_change_handler, input_change_handler_1, change_handler_1];
        }
        var App = /*#__PURE__*/function (_SvelteComponent9) {
          _inherits(App, _SvelteComponent9);
          var _super17 = _createSuper(App);
          function App(options) {
            var _this40;
            _classCallCheck(this, App);
            _this40 = _super17.call(this);
            init$1(_assertThisInitialized2(_this40), options, instance, create_fragment, safe_not_equal, {}, null, [-1, -1, -1, -1]);
            return _this40;
          }
          return _createClass(App);
        }(SvelteComponent);
        new App({
          target: document.getElementById('app')
        });
      }
    };
  });
})();
